<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"auska.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="随便写点啥">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://auska.github.io/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="随便写点啥">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Auska">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://auska.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Auska"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Auska</p>
  <div class="site-description" itemprop="description">随便写点啥</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Auska" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Auska" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:luodan0709@live.cn" title="E-Mail → mailto:luodan0709@live.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/04/30/ZFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%88%E9%80%82%E5%90%88%E6%8C%82PT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/30/ZFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%88%E9%80%82%E5%90%88%E6%8C%82PT/" class="post-title-link" itemprop="url">ZFS文件系统很适合挂PT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-30 17:34:17" itemprop="dateCreated datePublished" datetime="2022-04-30T17:34:17+08:00">2022-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:22:48" itemprop="dateModified" datetime="2022-05-01T10:22:48+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是ZFS文件系统"><a href="#什么是ZFS文件系统" class="headerlink" title="什么是ZFS文件系统"></a>什么是ZFS文件系统</h1><p>ZFS文件系统的英文名称为Zettabyte File System,也叫动态文件系统（Dynamic File System）,是第一个128位文件系统。最初是由Sun公司为Solaris 10操作系统开发的文件系统。作为OpenSolaris开源计划的一部分，ZFS于2005年11月发布，被Sun称为是终极文件系统，经历了 10 年的活跃开发。而最新的开发将全面开放，并重新命名为 OpenZFS</p>
<hr>
<!---more--->

<h1 id="ZFS文件系统特点"><a href="#ZFS文件系统特点" class="headerlink" title="ZFS文件系统特点"></a>ZFS文件系统特点</h1><h2 id="强大的实时数据缩减技术"><a href="#强大的实时数据缩减技术" class="headerlink" title="强大的实时数据缩减技术"></a>强大的实时数据缩减技术</h2><p>在线实时处理的区块层级 (Block-based) 数据重复删除机制 (Inline Data Deduplication)，让数据在写入磁盘前就已经过删减演算，大幅节省存储空间占用；加上让大档变小档的数据压缩 (Inline Compression)，以及先进的实时数据压实 (Inline Compaction) 技术，对于存储空间的节省程度带来重大的突破。在数据重复性质高或大量小型数据存取的情境下，提升 SSD 空间使用率的效益尤其明显，不仅显著提升全快闪配置的写入效能，对 SSD 的耐用性与使用寿命也有帮助，让全快闪存储架构成本效益更高。</p>
<h2 id="突破想象的-PB-级巨量存储"><a href="#突破想象的-PB-级巨量存储" class="headerlink" title="突破想象的 PB 级巨量存储"></a>突破想象的 PB 级巨量存储</h2><p>128 位的 ZFS 文件系统拥有巨大的存储潜力，且 ZFS 原生就有强大的 RAID 逻辑磁盘管理功能。基于 ZFS 文件系统的存储方案，单一共享文件夹空间高达 1 PB 容量，更能协助企业克服当前大数据分析、边缘预算、AI 应用等巨量数据存储的挑战。面对 PB 等级的存储容量配置时，RAID Z 磁盘阵列架构亦也有传统磁盘阵列所无法实现的高速建置效率，提供弹性更大、存取效率更高的磁盘空间运用。</p>
<h2 id="零秒瞬间，实时的-SnapSync-快照同步"><a href="#零秒瞬间，实时的-SnapSync-快照同步" class="headerlink" title="零秒瞬间，实时的 SnapSync 快照同步"></a>零秒瞬间，实时的 SnapSync 快照同步</h2><p>ZFS 支持 iSCSI LUN 与共享文件夹的快照，快照数量高达 65,535 份 (假设每小时拍 1 张快照，1 天 24 张，可维持 7 年不用删除！)，实现缜密的多版本快照保护。运用 Copy-on-Write 技术，拍摄快照近乎实时，且不影响当下的系统运作性能。利用快照文件还原数据也无需中断系统正在进行的服务，短时间内即刻启动灾难复原计划。更进阶的区块层级 Real-time SnapSync 实时快照同步功能，让本地 NAS 与备份 NAS 随时随地保持数据同步，关键数据得以获得更新、更完整而实时的备份。</p>
<h2 id="至今最快的-LZ4-数据压缩算法"><a href="#至今最快的-LZ4-数据压缩算法" class="headerlink" title="至今最快的 LZ4 数据压缩算法"></a>至今最快的 LZ4 数据压缩算法</h2><p>LZ4 是一种无损数据压缩算法，可提供极快的压缩和解压缩速度，是商用领域中所需 100 MB&#x2F;s 以上的高速传输存储里，能够提供低延迟、高 IO 量的压缩选择。数据存储进采用 ZFS 文件系统的都会经过在线压缩处理 (Inline Compression)，对于需要频繁压缩、时时快速解压的大量数据处理 (例如：虚拟机) 更具存储效率的优势。尤其再搭配数据重复删除机制，数据减量的效果更为显著。</p>
<hr>
<h1 id="为什么适合挂PT"><a href="#为什么适合挂PT" class="headerlink" title="为什么适合挂PT"></a>为什么适合挂PT</h1><h2 id="什么是PT"><a href="#什么是PT" class="headerlink" title="什么是PT"></a>什么是PT</h2><p>PT全名是Private Tracker。很简单的说，就是基于Bittorrent协议的“点”对“点”的文件传输服务。由于是基于Bittorrent协议，在传输过程中要不断与其他节点交流，彼此分享对方所需要的文件块。因此，会对磁盘进行频繁的读写操作；尤其是在早期出种的时候，更为明显。</p>
<h2 id="ZFS文件系统的缓存机制ARC"><a href="#ZFS文件系统的缓存机制ARC" class="headerlink" title="ZFS文件系统的缓存机制ARC"></a>ZFS文件系统的缓存机制ARC</h2><p>ZFS的可调缓存机制ARC是一种同时缓存数据块请求以及频繁的数据块请求的缓存机制。这是IBM专利自适应替换缓存的基础上的一些修改和扩展。它依赖内存作为高频的Cache缓存；所以，内存稳定对于ZFS文件系统至关重要。</p>
<p>由于ARC缓存机制的存在可以大大降低硬盘的读写；提高机械硬盘的使用寿命与读写速度。</p>
<h1 id="一个月长时间测试"><a href="#一个月长时间测试" class="headerlink" title="一个月长时间测试"></a>一个月长时间测试</h1><p>系统：Gentoo<br>硬件：HP Gen8 （G2020T 低配版本）<br>内存：8G（ECC）<br>硬盘：1T（机械硬盘）</p>
<h2 id="ZFS文件系统配置"><a href="#ZFS文件系统配置" class="headerlink" title="ZFS文件系统配置"></a>ZFS文件系统配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">NAME   PROPERTY              VALUE                  SOURCE</span><br><span class="line">data1  type                  filesystem             -</span><br><span class="line">data1  creation              Sat 01 Apr  8:35 2021  -</span><br><span class="line">data1  used                  614G                   -</span><br><span class="line">data1  available             285G                   -</span><br><span class="line">data1  referenced            614G                   -</span><br><span class="line">data1  compressratio         1.00x                  -</span><br><span class="line">data1  mounted               yes                    -</span><br><span class="line">data1  quota                 none                   default</span><br><span class="line">data1  reservation           none                   default</span><br><span class="line">data1  recordsize            128K                   default</span><br><span class="line">data1  mountpoint            /media/data1           local</span><br><span class="line">data1  sharenfs              off                    default</span><br><span class="line">data1  checksum              on                     default</span><br><span class="line">data1  compression           off                    default</span><br><span class="line">data1  atime                 off                    local</span><br><span class="line">data1  devices               on                     default</span><br><span class="line">data1  exec                  on                     default</span><br><span class="line">data1  setuid                on                     default</span><br><span class="line">data1  readonly              off                    default</span><br><span class="line">data1  zoned                 off                    default</span><br><span class="line">data1  snapdir               hidden                 default</span><br><span class="line">data1  aclmode               discard                default</span><br><span class="line">data1  aclinherit            restricted             default</span><br><span class="line">data1  createtxg             1                      -</span><br><span class="line">data1  canmount              on                     default</span><br><span class="line">data1  xattr                 on                     default</span><br><span class="line">data1  copies                1                      default</span><br><span class="line">data1  version               5                      -</span><br><span class="line">data1  utf8only              off                    -</span><br><span class="line">data1  normalization         none                   -</span><br><span class="line">data1  casesensitivity       sensitive              -</span><br><span class="line">data1  vscan                 off                    default</span><br><span class="line">data1  nbmand                off                    default</span><br><span class="line">data1  sharesmb              off                    default</span><br><span class="line">data1  refquota              none                   default</span><br><span class="line">data1  refreservation        none                   default</span><br><span class="line">data1  guid                  6389372042506996733    -</span><br><span class="line">data1  primarycache          all                    default</span><br><span class="line">data1  secondarycache        all                    default</span><br><span class="line">data1  usedbysnapshots       0B                     -</span><br><span class="line">data1  usedbydataset         614G                   -</span><br><span class="line">data1  usedbychildren        55.8M                  -</span><br><span class="line">data1  usedbyrefreservation  0B                     -</span><br><span class="line">data1  logbias               latency                default</span><br><span class="line">data1  objsetid              54                     -</span><br><span class="line">data1  dedup                 off                    default</span><br><span class="line">data1  mlslabel              none                   default</span><br><span class="line">data1  sync                  standard               default</span><br><span class="line">data1  dnodesize             legacy                 default</span><br><span class="line">data1  refcompressratio      1.00x                  -</span><br><span class="line">data1  written               614G                   -</span><br><span class="line">data1  logicalused           614G                   -</span><br><span class="line">data1  logicalreferenced     614G                   -</span><br><span class="line">data1  volmode               default                default</span><br><span class="line">data1  filesystem_limit      none                   default</span><br><span class="line">data1  snapshot_limit        none                   default</span><br><span class="line">data1  filesystem_count      none                   default</span><br><span class="line">data1  snapshot_count        none                   default</span><br><span class="line">data1  snapdev               hidden                 default</span><br><span class="line">data1  acltype               off                    default</span><br><span class="line">data1  context               none                   default</span><br><span class="line">data1  fscontext             none                   default</span><br><span class="line">data1  defcontext            none                   default</span><br><span class="line">data1  rootcontext           none                   default</span><br><span class="line">data1  relatime              off                    default</span><br><span class="line">data1  redundant_metadata    all                    default</span><br><span class="line">data1  overlay               on                     default</span><br><span class="line">data1  encryption            off                    default</span><br><span class="line">data1  keylocation           none                   default</span><br><span class="line">data1  keyformat             none                   default</span><br><span class="line">data1  pbkdf2iters           0                      default</span><br><span class="line">data1  special_small_blocks  0                      default</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>使用的是<code>transmission</code>作为PT客户<br><img src="/images/port2iz.1month.png" alt="port2iz.1month.png"></p>
<p>下图显示的是内存中块的命中情况</p>
<p><img src="/images/zfs2z.1month.png" alt="zfs2z.1month.png"><br>本月实际上传量: 1.633 TB<br>本月实际下载量: 639.5 GB</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/03/20/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E3%80%90%E8%AF%91%E3%80%91BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E3%80%90%E8%AF%91%E3%80%91BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">【转载】【译】BT下载的工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 20:06:02" itemprop="dateCreated datePublished" datetime="2022-03-20T20:06:02+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:51:44" itemprop="dateModified" datetime="2022-05-01T10:51:44+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前有写过几篇关于如何下载、部署Aria2并且进行离线BT下载的文章；但是对于BT的基本原理，如何实现的还是不太明白；</p>
<p>今天RSS上看到一篇非常好的文章，讲的很清楚，但是是英文的，就翻译了一下，分享给大家；</p>
<p>原文链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://skerritt.blog/bit-torrent/">How Does BitTorrent Work? a Plain English Guide</a></li>
</ul>
<p>对于搭建Aria2离线下载服务器感兴趣的可以看我的这几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/01/Aria2%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">Aria2安装与配置</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E4%BD%BF%E7%94%A8Aria2%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/">使用Aria2搭建你自己的离线下载服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E8%A7%A3%E5%86%B3Aria2%E7%9A%84BT%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E6%88%96%E6%B2%A1%E9%80%9F%E5%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98/">解决Aria2的BT下载速度慢或没速度的问题</a></li>
</ul>
<p><a id="more"></a></p>
<h2 id="【译】BT下载的工作原理"><a href="#【译】BT下载的工作原理" class="headerlink" title="【译】BT下载的工作原理"></a><a href="#%E3%80%90%E8%AF%91%E3%80%91BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" title="【译】BT下载的工作原理"></a>【译】BT下载的工作原理</h2><blockquote>
<p>BitTorrent是用于传输大文件的最常见协议之一。2013年2月，BitTorrent占全球所有带宽的3.35％，占文件共享专用总带宽6％的一半以上。– <a target="_blank" rel="noopener" href="https://blog.paloaltonetworks.com/app-usage-risk-report-visualization/">3.35% of all worldwide bandwidth</a></p>
</blockquote>
<p>本文不会讲解如何通过BT下载文件(这是一个好的客户端需要做的)；</p>
<p>我们之间进入正题，来看一看BT使用到了哪些技术；</p>
<p>任何人都可以阅读这篇文章，即使是那些对于网络或BitTorrent的知识一无所知的读者；</p>
<h3 id="谁创造了BitTorrent？"><a href="#谁创造了BitTorrent？" class="headerlink" title="谁创造了BitTorrent？"></a><a href="#%E8%B0%81%E5%88%9B%E9%80%A0%E4%BA%86BitTorrent%EF%BC%9F" title="谁创造了BitTorrent？"></a>谁创造了BitTorrent？</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bram_Cohen">Bram Cohen</a>于2001年发明了BitTorrent协议，并且Cohen用Python编写了第一个客户端实现。</p>
<p>科恩收集了一些免费的不可描述内容，来吸引Beta测试人员在2002年夏天使用BitTorrent。</p>
<h3 id="BT-vs-传统CS下载模式"><a href="#BT-vs-传统CS下载模式" class="headerlink" title="BT vs 传统CS下载模式"></a><a href="#BT-vs-%E4%BC%A0%E7%BB%9FCS%E4%B8%8B%E8%BD%BD%E6%A8%A1%E5%BC%8F" title="BT vs 传统CS下载模式"></a>BT vs 传统CS下载模式</h3><p>在传统下载中，服务器上传文件，而客户端下载文件。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt1.png"><img src="/:/528230d770eb45ed915c7ce317de53cc" alt="bt1.png"></a></p>
<p>而由于服务器的带宽限制，导致一些热门的文件下载效率变得十分低下，例如：500个人下载同一个文件将使服务器承受巨大压力。这种压力会限制服务器的上传速度，因此客户端无法快速下载文件。</p>
<p>其次，CS模式的成本很高。我们支付的带宽会随着文件的热门程度而增加。</p>
<p>最后，CS模式是中心化的。如果服务器挂了，则这个文件就无法被任何人下载了！</p>
<p>而BT下载致力于解决这些问题：</p>
<table>
<thead>
<tr>
<th><strong>Client-Server</strong></th>
<th><strong>BitTorrent</strong></th>
</tr>
</thead>
<tbody><tr>
<td>中心化</td>
<td>去中心化</td>
</tr>
<tr>
<td>热门资源限制服务器性能</td>
<td>热门资源无性能限制</td>
</tr>
<tr>
<td>设备费用昂贵；资源热门程度决定了设备开销</td>
<td>设备开销不会随着资源热门而变化</td>
</tr>
</tbody></table>
<p>我们知道，BT下载是通过对等网实现的(peer-to-peer，P2P)；而在对等网络中，每个对等点都连接到网络中的每个其他对等点。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt2.svg"><img src="/:/125e950f83004defa52f5eb4fddd4424" alt="bt2.svg"></a></p>
<p>而半中心化的对等网络是：拥有一个或多个权限比其他大多数对等点更高的对等网络。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt3.svg"><img src="/:/e2c6db0497f14929bcf95f6a10dd6893" alt="bt3.svg"></a></p>
<h3 id="BitTorrent概述"><a href="#BitTorrent概述" class="headerlink" title="BitTorrent概述"></a><a href="#BitTorrent%E6%A6%82%E8%BF%B0" title="BitTorrent概述"></a>BitTorrent概述</h3><p>BitTorrent是一种共享文件的方式，通常用于大型文件。 BitTorrent是单个下载源共享文件（例如服务器）的一种替代方法。并且，BitTorrent可以有效地在较低带宽上工作。</p>
<p>BitTorrent客户端的第一版没有搜索引擎，也没有对等交换，想要上传文件的用户必须创建一个小的torrent描述符文件(<em>torrent descriptor file</em>)，然后将其上传到torrent索引站点。</p>
<p>当用户想要共享文件时，他们会将文件做成种子文件(seed their file)。该用户称为做种人(<em>seeder</em>)。他们将种子文件上传到交换站点(exchange)（我们稍后再讨论）。想要下载该文件的任何人都将首先下载此种子描述符。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt4.png"><img src="/:/9230cafd9fec4d6d9063fc1b579b2bd8" alt="bt4.png"></a></p>
<p>我们称呼那些下载用户为对等点(peers)。他们的BT客户端将连接到BT tracker服务器（稍后讨论），并且tracker将向对等点发送种子集群中其他种子和对等点的IP地址列表。此处的集群指的是与某种子相关的所有PC。</p>
<p>种子文件描述符中包含了我们正在下载的文件的tracker服务器和元数据的列表。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt5.png"><img src="/:/d1355d5abeef4867938112ae753cd7e2" alt="bt5.png"></a></p>
<p>对等点将会连接到种子对应的IP并下载文件的<strong>一个部分</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt6.png"><img src="/:/1f161e5222014aa99ddc742d04292adf" alt="bt6.png"></a></p>
<p>当对等点完成下载(一个文件分片)后，它们可以充当种子提供者。虽然，可以在下载种子的同时充当种子提供者（这是很常见的）。</p>
<p>种子被文件共享给对等点后，该对等点也将充当种子提供者。在BitTorrent中，多个人可以上传相同的文件，而对于CS来说，只有一个服务器可以上传文件。</p>
<p>BitTorrent会将文件切分成称为pieces的块，每个块都有固定的大小(最后一个文件除外)。但是切分的块大小是不固定的，有时是256KB，有时是1MB。当每个对等点收到一个块时，它们就成为这个文件块的其他对等点的种子(become a seed of that piece for other peers)。</p>
<p>在使用BitTorrent时，我们没有使用单一的下载源。因此，我们可能会从国内下载一些文件块，然后从国外下载一些国内没有的文件块。</p>
<p>协议会对文件块进行哈希(<a target="_blank" rel="noopener" href="https://skerritt.blog/hash-functions/">hashes</a>)处理，以确保种子对应的原始文件没有被篡改。然后将哈希值存储在torrent描述符中，并上传至tracker服务器。</p>
<p>这就是BT下载的基本概述了。接下来我会深入讲解BT下载的底层原理。并回答下列问题：</p>
<ul>
<li>如果对等点仅下载文件但从不上传，会发生什么？</li>
<li>我们从哪里下载，又在给谁上传？</li>
<li>什么是磁力链接( magnet link )？</li>
<li>什么是种子描述符( torrent descriptor )？</li>
<li>哈希使用到的是什么算法？</li>
<li>BT是如何选择下载的文件块的？</li>
<li>……</li>
</ul>
<h3 id="种子描述文件中有什么？"><a href="#种子描述文件中有什么？" class="headerlink" title="种子描述文件中有什么？"></a><a href="#%E7%A7%8D%E5%AD%90%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F" title="种子描述文件中有什么？"></a>种子描述文件中有什么？</h3><p>种子描述文件是一个字典(dictionary)（或被称为哈希表，HashMap）文件。</p>
<p>文件被定义为：</p>
<h4 id="①-声明-Announce"><a href="#①-声明-Announce" class="headerlink" title="① 声明(Announce)"></a><a href="#%E2%91%A0-%E5%A3%B0%E6%98%8E-Announce" title="① 声明(Announce)"></a><strong>① 声明(Announce)</strong></h4><p>这个字段中包括了tracker服务器的URL。还记得我们之前需要连接tracker服务器来查找使用同一文件的其他对等点吗？我们通过使用torrent描述文件中的announce key来找到tracker服务器。</p>
<hr>
<h4 id="②-信息-Info"><a href="#②-信息-Info" class="headerlink" title="② 信息(Info)"></a><a href="#%E2%91%A1-%E4%BF%A1%E6%81%AF-Info" title="② 信息(Info)"></a><strong>② 信息(Info)</strong></h4><p>这个字段映射到了另一个词典列表，而字典列表中的元素个数取决于该种子共享的文件个数。字典列表中的key包括：</p>
<ul>
<li>**Files(Info中的子字典，是一个列表)**：Files仅在共享多个文件时存在，Files中的每个字典对应一个文件。这些列表中的每一个字典都有2个key：<ul>
<li><strong>Length：</strong>文件大小（以字节为单位）。</li>
<li><strong>Path：</strong>对应于子目录名称的字符串列表，最后一个是实际文件名。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="③-共享文件大小-Length"><a href="#③-共享文件大小-Length" class="headerlink" title="③ 共享文件大小(Length)"></a><a href="#%E2%91%A2-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F-Length" title="③ 共享文件大小(Length)"></a><strong>③ 共享文件大小(Length)</strong></h4><p>文件大小（以字节为单位）（仅在共享一个文件时）</p>
<hr>
<h4 id="④-文件名-Name"><a href="#④-文件名-Name" class="headerlink" title="④ 文件名(Name)"></a><a href="#%E2%91%A3-%E6%96%87%E4%BB%B6%E5%90%8D-Name" title="④ 文件名(Name)"></a><strong>④ 文件名(Name)</strong></h4><p>建议的文件名。或建议的目录名称。</p>
<hr>
<h4 id="⑤-文件块大小-Pieces-Length"><a href="#⑤-文件块大小-Pieces-Length" class="headerlink" title="⑤ 文件块大小(Pieces Length)"></a><a href="#%E2%91%A4-%E6%96%87%E4%BB%B6%E5%9D%97%E5%A4%A7%E5%B0%8F-Pieces-Length" title="⑤ 文件块大小(Pieces Length)"></a><strong>⑤ 文件块大小(Pieces Length)</strong></h4><p>单个文件块字节数。</p>
<p>文件块大小必须是2的幂，并且至少为16Kb；</p>
<blockquote>
<p>注： 2^8Kb &#x3D; 256Kb &#x3D; 262144b</p>
</blockquote>
<hr>
<h4 id="⑥-文件块-Pieces"><a href="#⑥-文件块-Pieces" class="headerlink" title="⑥ 文件块(Pieces)"></a><a href="#%E2%91%A5-%E6%96%87%E4%BB%B6%E5%9D%97-Pieces" title="⑥ 文件块(Pieces)"></a><strong>⑥ 文件块(Pieces)</strong></h4><p>一个存放文件块哈希值的列表：我们将文件数据分成几块。分别计算这些块的哈希值，并将其存储在列表中。</p>
<p>BitTorrent使用SHA-1算法，而SHA-1返回160位的哈希值，所以所有文件块的哈希值都将是一个长度为20个字节的倍数的字符串。</p>
<p>如果单个种子文件中包含了多个文件，则将会按照文件在文件目录中出现的顺序串联起来，形成文件块。</p>
<p>种子中的所有文件块均为完整块长度，只有单个文件中的最后一个块可能较短。</p>
<p>现在，我能猜到你在想什么。</p>
<blockquote>
<p>这都0202年了，还在用SHA-1？</p>
</blockquote>
<p>我也同意，并且现在BT下载的哈希算法已经慢慢迁移到了SHA265：<a target="_blank" rel="noopener" href="http://bittorrent.org/beps/bep_0052.html">BitTorrent is moving from SHA-1 to SHA256.</a></p>
<p>如果你对于种子描述文件的结构还是很困惑也不用担心！我设计了下面这个JSON文件，描述了种子文件的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Announce&quot;: &quot;url of tracker&quot;,</span><br><span class="line">    &quot;Info&quot;: &#123;</span><br><span class="line">        &quot;Files&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Length&quot;: 16,</span><br><span class="line">                &quot;path&quot;: &quot;/folder/to/path&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;length&quot;: 193,</span><br><span class="line">                &quot;path&quot;: &quot;/another/folder&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;length&quot;: 192,</span><br><span class="line">    &quot;name&quot;:&quot; Ubuntu.iso&quot;,</span><br><span class="line">    &quot;Pieces length&quot;: 262144,</span><br><span class="line">    &quot;Pieces&quot;: [AAF4C61DDCC5E8A2DABEDE0F3B482CD9AEA9434D, CFEA2496442C091FDDD1BA215D62A69EC34E94D0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BT下载中的块选择算法-Piece-Selection-Algorithm"><a href="#BT下载中的块选择算法-Piece-Selection-Algorithm" class="headerlink" title="BT下载中的块选择算法(Piece Selection Algorithm)"></a><a href="#BT%E4%B8%8B%E8%BD%BD%E4%B8%AD%E7%9A%84%E5%9D%97%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95-Piece-Selection-Algorithm" title="BT下载中的块选择算法(Piece Selection Algorithm)"></a>BT下载中的块选择算法(Piece Selection Algorithm)</h3><p>BitTorrent下载中最大的问题之一是“我应该选择下载哪些文件？”</p>
<p>对于传统的CS模型，我们将下载整个文件；但是现在，我们需要选择要下载的部分。</p>
<p>选择一个好的顺序来下载片断，对提高性能非常重要。一个差的文件块选择算法可能导致所有的文件块都处于下载中，或者另一种情况，没有任何一个片段会被上载给其它对等点。</p>
<p>在BT中块选择的算法思想就是：下载其他人没有的文件块，即稀有文件块。通过下载稀有的文件块，我们可以通过上传该块来减少稀有文件块的稀有度。</p>
<h3 id="什么是子块-Sub-Pieces-和块选择算法-Piece-Selection-Algorithm"><a href="#什么是子块-Sub-Pieces-和块选择算法-Piece-Selection-Algorithm" class="headerlink" title="什么是子块(Sub-Pieces)和块选择算法(Piece Selection Algorithm)"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%90%E5%9D%97-Sub-Pieces-%E5%92%8C%E5%9D%97%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95-Piece-Selection-Algorithm" title="什么是子块(Sub-Pieces)和块选择算法(Piece Selection Algorithm)"></a>什么是子块(Sub-Pieces)和块选择算法(Piece Selection Algorithm)</h3><p>BitTorrent使用TCP，一种用于数据包的传输协议。TCP具有一种被称为慢启动(<a target="_blank" rel="noopener" href="https://www.isi.edu/nsnam/DIRECTED_RESEARCH/DR_HYUNAH/D-Research/slow-start-tcp.html">slow start</a>)的机制。</p>
<p>慢启动是一种平衡TCP网络连接速度的机制。它会逐步增加传输的数据量，直到找到网络的最大承载能力，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt7.svg"><img width="899" height="509" src=":/ef98235883f34b1d91099850e56e12ad"/></a></p>
<p>其中，cwdn代表拥塞窗口。</p>
<p>TCP之所以这样做，是因为：如果我们一次发送16个连接请求，可能会导致服务器无法使用该流量，最终网络发生拥塞。所有，如果我们不定期发送数据，则TCP可能会以比正常速度慢的速度限制网络连接。</p>
<p>BitTorrent协议会保证将数据细分为更多的子数据块来发送数据，每个子块的大小约为16KB。一个块的大小不是固定的，但大约为1MB。</p>
<p>同时BitTorrent协议始终有一定数量的请求连接（五个），用于子块管道(sub-piece pipe-lined)。当下载一个新的子块时，客户端将发送一个新请求，从而有助于加快速度。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt8.svg"><img width="899" height="364" src=":/6db5ad85d5854d2187601d3d3730aaae"/></a></p>
<p>同时子块可以被其他的对等点下载；</p>
<p>对于块选择算法来说，有两大原则：</p>
<ul>
<li>严格规则(Strict Policy)；</li>
<li>稀有度优先(Rarest First)；</li>
</ul>
<h4 id="①-严格优先级-Strict-Policy"><a href="#①-严格优先级-Strict-Policy" class="headerlink" title="① 严格优先级(Strict Policy)"></a><a href="#%E2%91%A0-%E4%B8%A5%E6%A0%BC%E4%BC%98%E5%85%88%E7%BA%A7-Strict-Policy" title="① 严格优先级(Strict Policy)"></a><strong>① 严格优先级(Strict Policy)</strong></h4><p>一旦BitTorrent客户端发起了一个文件块的子块的请求，则该文件块的任何剩余子块都将先于其他文件块的任何子块被请求。 这样，可以尽可能快的获得一个完整的片断。</p>
<blockquote>
<p>Once the BitTorrent client requests a sub-piece of a piece, any remaining sub-pieces of that piece are requested before any sub-pieces from other pieces.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt9.svg"><img width="899" height="539" src=":/1358c4ac10aa48468d80af1578e9b704"/></a></p>
<p>在此图中，就是需要先下载该文件块的其他的所有子块，而不是开始下载另一个文件块。</p>
<hr>
<h4 id="②-稀有度优先-Rarest-First"><a href="#②-稀有度优先-Rarest-First" class="headerlink" title="② 稀有度优先(Rarest First)"></a><a href="#%E2%91%A1-%E7%A8%80%E6%9C%89%E5%BA%A6%E4%BC%98%E5%85%88-Rarest-First" title="② 稀有度优先(Rarest First)"></a><strong>② 稀有度优先(Rarest First)</strong></h4><p>BitTorrent下载的核心策略就是选择最稀有的文件块(pick the rarest first)，所以我们要下载其他对等点拥有的最少的文件块。</p>
<p>这样我们就可以将那些稀有的文件块变得不再稀有(‘un-rare’)。因为，如果只有一个对等点有这个文件块并且他下线了，则将没有人能够获得完整文件。</p>
<p>这个原则带来了很多好处：</p>
<p><strong>Ⅰ。提高种子可靠性(Growing the seed)</strong></p>
<p>首先，选择最稀有的文件块确保了我们仅从种子中下载新的文件块。</p>
<p>例如：稀有种子在一开始会成为下载瓶颈，仅有单个对等点含有该文件快。</p>
<p>而一个下载者可以看到他的对等点拥有哪些文件块，从而最稀有优先原则将使我们从种子中获取那些尚未由其他对等点上传的文件块。</p>
<p>让我们将其可视化：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt10.svg"><img width="899" height="436" src=":/6f32d361bf9f40279f664453e0e3ed35"/></a></p>
<p>虽然图中没有画出，但是各个对等点之间也是是相互连接的。</p>
<p>每个指向子文件块的箭头代表该对等点已下载对应内容。所以可以看到，我们已经下载了除了种子没有其他人拥有的子块，这意味着此子块很稀有。</p>
<p>同时可以看到，我们的上传速度高于种子的上传速度，因此所有其他的对等点都希望从我们这里下载。此外，他们也希望首先下载到最稀有的子块，因为我们是最稀有子块的2位持有者之一。</p>
<p>当每个对等点都从我们这里下载时，我们也可以从他们那里更快地下载。这就是针锋相对算法(“tit-for-tat algorithm”)（稍后讨论）。</p>
<p><strong>Ⅱ。提高下载速度(Increased download speed)</strong></p>
<p>持有文件块的对等点越多，下载速度就越快。这是因为我们可以从其他对等点那里下载子块。</p>
<p><strong>Ⅲ。上传支持(Enable uploading)</strong></p>
<p>稀有文件块是其他对等点最想要的，而获得稀有文件块也意味着对等点会对从我们的上传感兴趣。稍后我们将看到，我们上传的越多，我们可以下载的也越多。</p>
<p><strong>Ⅳ。最常见的块在最后(Most common last)</strong></p>
<p>将最常见的文件块留在下载末尾是明智的。由于许多对等点都拥有此文件块，因此能够下载它们的可能性比稀有文件块大得多。</p>
<p><strong>Ⅴ。避免稀有块丢失(Prevent rarest piece missing)</strong></p>
<p>当种子提供者断开连接时，稀有度优先原则保证了文件的所有部分都会分配到其余对等点。</p>
<hr>
<h4 id="③-随机开始下载的第一个文件块-Random-First-Piece"><a href="#③-随机开始下载的第一个文件块-Random-First-Piece" class="headerlink" title="③ 随机开始下载的第一个文件块(Random First Piece)"></a><a href="#%E2%91%A2-%E9%9A%8F%E6%9C%BA%E5%BC%80%E5%A7%8B%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%9D%97-Random-First-Piece" title="③ 随机开始下载的第一个文件块(Random First Piece)"></a><strong>③ 随机开始下载的第一个文件块(Random First Piece)</strong></h4><p>当我们刚下载时，我们还没有任何可以上传的内容，所以我们需要很快的获取到第一块。而此时，稀有度优先原则是很慢的，所以BT协议会随机选择一块开始下载；直到第一块下载并检查完成。此后，“稀有优先”策略才会开始。</p>
<hr>
<h4 id="④-残局模式-Endgame-Mode"><a href="#④-残局模式-Endgame-Mode" class="headerlink" title="④ 残局模式(Endgame Mode)"></a><a href="#%E2%91%A3-%E6%AE%8B%E5%B1%80%E6%A8%A1%E5%BC%8F-Endgame-Mode" title="④ 残局模式(Endgame Mode)"></a><strong>④ 残局模式(Endgame Mode)</strong></h4><p>当(某个块)下载接近完成，但是还需要等待传输速率较慢的对等点上传时，可能会造成下载延迟，从而降低了传输效率。为了防止这种情况，其余的子块是从当前集群中的所有对等点中请求的。</p>
<p>还记得严格原则(Strict-Policy)吗？BT下载时，总是有数个待处理的子块请求：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt11.svg"><img width="899" height="342" src=":/e32ebebaf91d4d58bb50e7c60a57c311"/></a></p>
<p>假设我们正在从2个对等点下载，而还有另外1个我们未从中下载的对等点。</p>
<p>当请求的对等点缺少相应的子块时，BT协议会将请求广播给集群中所有对等点，而这有助于我们获取文件的最后一块。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt12.svg"><img width="899" height="219" src=":/b4e8dd5b9fc149d8ae15d2a98332bc9a"/></a></p>
<p>如果对等点缺少子块，他们会将消息发送回我们。</p>
<p>一旦一个子块到达，我们将发送一条取消消息，告诉其他对等方忽略我们的请求。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt13.svg"><img width="899" height="255" src=":/096a3b94a1ad45f88e042cc4828b71de"/></a></p>
<h3 id="使用“以牙还牙”算法分配资源"><a href="#使用“以牙还牙”算法分配资源" class="headerlink" title="使用“以牙还牙”算法分配资源"></a><a href="#%E4%BD%BF%E7%94%A8%E2%80%9C%E4%BB%A5%E7%89%99%E8%BF%98%E7%89%99%E2%80%9D%E7%AE%97%E6%B3%95%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90" title="使用“以牙还牙”算法分配资源"></a>使用“以牙还牙”算法分配资源</h3><p><strong>以牙还牙</strong>（英语：tit-for-tat）是一个用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%9A%E5%BC%88%E8%AB%96">博弈论</a>的重复<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83">囚徒困境</a>（reiterated prisoner’s dilemma）非常有效的策略。这策略最先由数学家<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E7%B4%8D%E6%89%98%C2%B7%E6%8B%89%E6%99%AE%E4%BC%AF%E7%89%B9&action=edit&redlink=1">阿纳托·拉普伯特</a>（Anatol Rapoport）提出，并在密歇根大学社会学家<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BE%85%E4%BC%AF%E7%89%B9%C2%B7%E9%98%BF%E5%85%8B%E5%A1%9E%E7%88%BE%E7%BE%85">罗伯特·阿克塞尔罗</a>（Robert Axelrod）有关囚徒困境的研究中击败其他方法，脱颖而出，成为解决囚徒困境的最佳策略。</p>
<p>这一策略有两个步骤：</p>
<ol>
<li>第一个回合选择合作；</li>
<li>下一回合是否选合作要看上一回对方是否合作，若对方上一回背叛，此回合我亦背叛；若对方上一回合作，此回合继续合作；</li>
</ol>
<p>“以牙还牙”策略有四个特点：</p>
<ol>
<li>友善：“以牙还牙”者开始一定采取合作态度，不会背叛对方；</li>
<li>报复性：遭到对方背叛，“以牙还牙”者一定会还击报复；</li>
<li>宽恕：当对方停止背叛，“以牙还牙”者会原谅对方，继续合作；</li>
<li>不羡慕对手：“以牙还牙”者个人永远不会得到最大利益，整个策略以全体的最大利益为依归；</li>
</ol>
<h3 id="阻塞算法-The-choking-Algorithm"><a href="#阻塞算法-The-choking-Algorithm" class="headerlink" title="阻塞算法(The choking Algorithm)"></a><a href="#%E9%98%BB%E5%A1%9E%E7%AE%97%E6%B3%95-The-choking-Algorithm" title="阻塞算法(The choking Algorithm)"></a>阻塞算法(The choking Algorithm)</h3><p>当一个对等点收到另一个对等点的请求时，它可以选择拒绝向该请求发送文件块(但我们仍然可以从他们那里下载)。如果发生这种情况，则称对方被“choked”了。</p>
<p>当对等点合作时，他们上传文件；而当对等点不合作时，他们“阻塞”了与其他对等点的连接；而原则就是上传文件块给那些已上传给过我们的对等点；</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt14.svg"><img width="899" height="244" src=":/ab299c35f70544dd8eca70fbd423314a"/></a></p>
<p>而阻塞算法最终理想的结果就是：同时进行多个双向连接并最终达到帕累托最优(Pareto Efficiency)</p>
<blockquote>
<p>如果没有其他分配方式能够使某个人的状况更好也没有一个人的状况更差，那么我们认为分配是帕累托最优的。</p>
</blockquote>
<p>因此，最大的问题是，如何确定哪些对等点会被阻塞而哪些不会被阻塞呢？</p>
<p>在默认情况下，客户端将仅保留默认的同时上传数量(max_uploads，max_uploads的默认值为4)，而所有对该客户端的其他请求都将标记为“choked”。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt15.png"><img src="/:/976a7793e07746edb3d0e263a85340a5" alt="bt15.png"></a></p>
<p>如上图中，种子阻塞了与对等点的连接，因为它已达到其最大上传数量。此后，对等点将保持阻塞状态，直到发送了取消阻塞消息为止。</p>
<p>而当前的下载速率决定了要取消阻塞对等点。这里以每10秒计算一次最近20秒的下载速率平均值来决定。因为BT下载使用的是TCP协议（慢启动），因此快速阻塞和取消阻塞的效率并不高( 频繁的阻塞和疏通peers造成资源浪费)。</p>
<p>所以，根据这个原则：如果我们的上传速率很高，则会有更多的对等点允许我们从他们那里下载。即，**如果我们是优秀的上传者，我们可以获得更高的下载率(This means that we can get a higher download rate if we are a good uploader)**。这是BitTorrent协议的最重要功能。</p>
<blockquote>
<p>文件下载片断选择是为了提高系统的总效率，而阻塞算法是为了提高个人用户的公平性和效率：作为取自于用户并用之于用户的分布式系统，整个系统的效率和个人用户的公平性至关重要！</p>
<p>BitTorrent的片断下载策略保证了最大的下载效率和稳健的完整性，而阻塞算法鼓励个人用户上传。BitTorrent的阻塞算法并不记录历史，也就是对用户以前的上传、下载行为没有记录。</p>
<p>而有些最近版本的BitTorrent已经能对帐户的上传、下载信息做出统计，然后转化为积分，但积分还没有和用户的下载优先级绑定，而且积分也只是简单的统计上传流量，上传的内容和上传的目标用户也没有分析，简单的积分策略并不能应对五花八门Spamming技术，积分算法应该是上传和下载流量的比数，且积分增加速度随着上传的不同目标用户和不同上传内容数量的增加而增加！</p>
</blockquote>
<p>这个协议禁止了许多“搭便车的人(free riders)”，即：只下载但不上传的对等点。这是为了使整个对等网络高效，所以所有对等都需要为网络做出贡献；</p>
<blockquote>
<p>除此之外：</p>
<p>对方被阻塞的另一个常见例子是，对等点不需要下载文件块。</p>
</blockquote>
<p>同时，为了确保对等点之间的公平，有一个适当的机制确保了各对等点可以轮流下载其他对等点的文件块，这个机制被称为：“开放检测”(optimistic unchoking)。</p>
<h3 id="开放检测-optimistic-unchoking"><a href="#开放检测-optimistic-unchoking" class="headerlink" title="开放检测(optimistic unchoking)"></a><a href="#%E5%BC%80%E6%94%BE%E6%A3%80%E6%B5%8B-optimistic-unchoking" title="开放检测(optimistic unchoking)"></a>开放检测(optimistic unchoking)</h3><p>如果只是简单的为提供最好的下载速率的对等点们提供上传速度，那么就没有办法来发现那些空闲的连接是否比当前正使用的连接更好。</p>
<p>为了解决这个问题，在任何时候，每个对等点都拥有一个被称为“optimistic unchoking”的连接，这个连接总是保持畅通状态，而不论它的下载速率是怎样的。</p>
<p>每隔30秒，会重新计算一次哪个连接应该是“optimistic unchoking”。如果此“optimistic unchoking”连接比当前连接的某个非阻塞的连接下载速率要快，那么这个“optimistic unchoking”将会取代那个连接；</p>
<blockquote>
<p>因为即使是TPC协议，30秒足以让上传能力达到最大，下载能力也相应的达到最大。</p>
</blockquote>
<p>“optimistic unchoking”连接是随机选择的。同时，这也允许了那些不上传并仅下载文件的对等设备下载文件，即使他们拒绝合作（尽管它们将以慢得多的速度下载）</p>
<h3 id="反对歧视-Anti-snubbing"><a href="#反对歧视-Anti-snubbing" class="headerlink" title="反对歧视(Anti-snubbing)"></a><a href="#%E5%8F%8D%E5%AF%B9%E6%AD%A7%E8%A7%86-Anti-snubbing" title="反对歧视(Anti-snubbing)"></a>反对歧视(Anti-snubbing)</h3><p>某些情况下，一个对等点可能会被它所有的对等点都阻塞了，这种情况下，它将会保持较低的下载速率直到通过“optimistic unchoking”找到了更好peers。</p>
<p>为了减轻这种问题，如果某个对等点在60秒钟内没有收到来自特定对等点的任何文件，则将认为它已被对方对等点 “怠慢”了，于是不再为对方提供上传，除非对方是“optimistic unchoking”。如果这种情况频繁发生，会导致多于一个的并发的“optimistic unchoking”。</p>
<h3 id="仅上传对等点-Upload-Only"><a href="#仅上传对等点-Upload-Only" class="headerlink" title="仅上传对等点(Upload Only)"></a><a href="#%E4%BB%85%E4%B8%8A%E4%BC%A0%E5%AF%B9%E7%AD%89%E7%82%B9-Upload-Only" title="仅上传对等点(Upload Only)"></a>仅上传对等点(Upload Only)</h3><p>我们看到，使用在BitTorrent中实现的阻塞算法，我们更喜欢对我们友好的对等点。如果我可以从他们那里快速下载，我们也允许他们从我那里快速上传。</p>
<p>但是如果某个对等点完成了下载，它就无法使用此阻塞算法判断要取消阻塞哪些对等点；</p>
<p>此时，将使用新的阻塞算法：不再通过下载速率（因为下载速率已经为0了）来决定为哪些对等点提供上载，而是优先选择那些从它这里得到更好的上载速率的对等点。这样做的理由是可以尽可能的利用上载带宽，从而确保文件块上传速度更快，并且复制速度更快。</p>
<h3 id="什么是跟踪器-Tracker-？"><a href="#什么是跟踪器-Tracker-？" class="headerlink" title="什么是跟踪器(Tracker)？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%9F%E8%B8%AA%E5%99%A8-Tracker-%EF%BC%9F" title="什么是跟踪器(Tracker)？"></a>什么是跟踪器(Tracker)？</h3><p>Tracker是一种特殊类型的服务器，可帮助对等点之间进行通信。</p>
<p>BitTorrent中的通信很重要。想一下，我们是如何了解其他对等点的存在的？</p>
<p>Tracker知道文件的拥有者以及拥有量。</p>
<p>但是，当对等下载开始后，就无需Tracker即可继续通信。</p>
<p>实际上，自从为无追踪程序的种子创建分布式哈希表(distributed hash table，DHT)方法以来，BitTorrent Tracker在很大程度上是多余的。</p>
<h4 id="公共Tracker"><a href="#公共Tracker" class="headerlink" title="公共Tracker"></a><a href="#%E5%85%AC%E5%85%B1Tracker" title="公共Tracker"></a>公共Tracker</h4><p>公共Tracker是任何人都可以使用的Tracker。</p>
<p>海盗湾（Pirate Bay）是最受欢迎的公共Tracker之一，直到2009年其禁用了Tracker，而选择了磁链（即将讨论）。</p>
<blockquote>
<p>引自： <a target="_blank" rel="noopener" href="https://arstechnica.com/tech-policy/2009/11/pirate-bay-kills-its-own-bittorrent-tracker/">The Pirate Bay operated one of the most popular public trackers until disabling it in 2009</a></p>
</blockquote>
<hr>
<h4 id="私有Tracker"><a href="#私有Tracker" class="headerlink" title="私有Tracker"></a><a href="#%E7%A7%81%E6%9C%89Tracker" title="私有Tracker"></a>私有Tracker</h4><p>私人Tracker是私人的，它们通过要求用户在网站上注册来限制使用。</p>
<p>控制注册的方法通常是邀请系统。要使用此类Tracker，我们需要被邀请。</p>
<hr>
<h4 id="多Tracker种子"><a href="#多Tracker种子" class="headerlink" title="多Tracker种子"></a><a href="#%E5%A4%9ATracker%E7%A7%8D%E5%AD%90" title="多Tracker种子"></a>多Tracker种子</h4><p>多Tracker种子是在一个种子文件中包含多个Tracker。如果一个Tracker发生故障，这将提供冗余，其他Tracker可以继续维护种子文件创建的集群。</p>
<p>但是，使用此配置，单个种子可能有多个未互相连接的集群：一些用户可以连接到一个特定的Tracker，而无法连接到另一个，这很糟糕！因为，这会创建很多不相交的集群，这会阻碍torrent传输其描述的文件的效率。</p>
<h3 id="磁力链接-无Tracker种子-Magnet-Links-Trackerless-Torrents"><a href="#磁力链接-无Tracker种子-Magnet-Links-Trackerless-Torrents" class="headerlink" title="磁力链接 - 无Tracker种子(Magnet Links - Trackerless Torrents)"></a><a href="#%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5-%E6%97%A0Tracker%E7%A7%8D%E5%AD%90-Magnet-Links-Trackerless-Torrents" title="磁力链接 - 无Tracker种子(Magnet Links - Trackerless Torrents)"></a>磁力链接 - 无Tracker种子(Magnet Links - Trackerless Torrents)</h3><p>之前，我谈到了Pirate Bay停用了Tracker并开始使用无tracker的种子。</p>
<p>当我们下载种子时，我们会得到该种子的哈希值。要在没有tracker的情况下下载种子，我们需要找到其他也在下载种子的对等点。为此，我们需要使用分布式哈希表(distributed hash table，DHT)。</p>
<p>下面让我们探索分布式哈希表。</p>
<h3 id="分布式哈希表-Distributed-Hash-Tables-和Kademlia协议"><a href="#分布式哈希表-Distributed-Hash-Tables-和Kademlia协议" class="headerlink" title="分布式哈希表(Distributed Hash Tables)和Kademlia协议"></a><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8-Distributed-Hash-Tables-%E5%92%8CKademlia%E5%8D%8F%E8%AE%AE" title="分布式哈希表(Distributed Hash Tables)和Kademlia协议"></a>分布式哈希表(Distributed Hash Tables)和Kademlia协议</h3><p>分布式哈希表是一种分布式存储方法。这种网络不需要中心节点服务器，而是每个客户端负责一个小范围的路由，并负责存储一小部分资料，从而实现整个DHT网络的定位和存储。和中心节点服务器不同，DHT网络中的各节点并不需要维护整个网络的信息，而是只在节点中存储其临近的后继节点信息，大幅减少了带宽的占用和资源的消耗。DHT网络还在与关键字最接近的节点上复制备份冗余信息，避免了单一节点失效问题。</p>
<p>BitTorrent的DHT网络是使用Kademlia协议（以下简称Kad），一个点对点（P2P）的&lt; 键, 值&gt;元组存储和查询系统。</p>
<blockquote>
<p>Kad是美国纽约大学的PetarP. Maymounkov和David Mazieres.在2002年发布的一项研究结果：《Kademlia: A peerto -peer information system based on the XOR metric》。</p>
<p>Kademlia拥有许多的令人惊喜的特点，这些特点是任何以前的P2P系统所无法同时提供的。它减少了节点必须发送的用来相互认识的配置消息的数量。在做键查询的同时, 配置消息将会被自动传播。节点拥有足够的知识和灵活性来通过低时延路径发送查询请求。</p>
<p>Kademlia使用平行的、异步的查询请求来避免节点失效所带来的超时时延。通过节点记录相互的存在的算法可以抵抗某些基本的拒绝服务（DoS）攻击。</p>
</blockquote>
<p>分布式哈希表为我们提供了类似于字典的接口，但是节点分布在整个网络中。DHT的核心在于：通过散列特定的key可以找到存储对应的特定key的节点。</p>
<p>实际上，这意味着，每个对等点都将成为一个微型tracker(mini-tracker)。</p>
<p>每个节点（实现DHT协议的客户端&#x2F;服务器）都有一个唯一的标识符，称为“节点ID”(Node Id)。我们从与BitTorrent信息哈希相同的160位空间中随机选择节点ID。</p>
<p>信息哈希(Infohashes)是以下内容的SHA-1哈希：</p>
<ul>
<li>ITEM：文件大小和路径（带文件名的路径）；</li>
<li>Name：被索引时的名称；</li>
<li>Piece length：单块文件大小；</li>
<li>Pieces：该种子文件的每一块的SHA-1哈希值；</li>
<li>Private：限制访问标记；</li>
</ul>
<blockquote>
<p>关于Infohashes：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28348678/what-exactly-is-the-info-hash-in-a-torrent-file">What exactly is the info_Hash in a torrent file</a></p>
</blockquote>
<p>我们使用距离度量(distance metric)来比较两个节点ID或 一个节点ID和一个infohash的“接近度”(closeness)；</p>
<p>节点必须具有包含其他几个节点的联系信息的路由表。从而，节点在DHT中知道彼此。他们知道许多节点的id与他们自己的很接近，但也有很少节点的id与他们很远。</p>
<p>距离度量是XOR(异或)，被解释为一个整数：</p>
<p>distance(A,B)&#x3D;|A⊕B|</p>
<p>数值越小越接近。</p>
<p>当一个节点想要为一个种子找到对等节点时，他们使用distance metric来比较种子的infohash和路由表中节点的ID，或者一个节点的ID和另一个节点的ID。</p>
<p>然后，他们联系路由表中最靠近infohash的节点，并向他们请求下载种子的对等点的联系信息。</p>
<p>如果这个被联系的节点知道种子的对等点，他们返回对等点的联系信息响应。否则，被联系的节点必须用他的路由表中最靠近infohash的节点来响应请求种子的信息。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt16.svg"><img width="899" height="317" src=":/953a2035c2404f41b92b546b1ebd5fdd"/></a></p>
<p>原始节点查询更接近infohash的节点，直到找不到更接近的节点为止。在节点完成搜索后，客户端将自己的对等联系信息(peer contact information)插入到与种子信息最接近的id响应节点上。在未来，其他节点可以很容易地找到我们（原始节点）。</p>
<p>对等点查询的返回值包括一个被称为“token”的不透明值(opaque value)。一个节点要宣布它的控制对等点正在下载一个种子，它必须在最近的一次对等查询中展示从同一被查询的对等点接收到的令牌。</p>
<p>当一个节点试图“发布(announce)”一个种子时，被查询的节点会根据查询节点的IP地址检查令牌。这是为了防止恶意主机为种子注册其他主机。(This is to prevent malicious hosts from signing up other hosts for torrents)</p>
<p>查询节点也会将一个令牌返回到他接收令牌的同一个节点。在令牌被分发后，我们必须在一个合理的时间内接受令牌(We must accept tokens for a reasonable amount of time after they have been distributed.)。</p>
<p>BitTorrent对于这个令牌的实现是：使用IP地址和每5分钟更改一次的密码的SHA-1哈希，并且接受最多10分钟以前的令牌。</p>
<h3 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a><a href="#%E8%B7%AF%E7%94%B1%E8%A1%A8-Routing-Table" title="路由表(Routing Table)"></a>路由表(Routing Table)</h3><p>每个节点都会维护一个已知的好节点(known good nodes)的路由表。我们在DHT中使用路由表起始点(starting points)进行查询，同时我们从路由表返回节点以响应来自其他节点的查询。</p>
<p>并非我们了解的所有节点都是平等的。有些是“好”的，有些则不是。许多使用DHT的节点可以发送查询和接收响应，但是不能响应来自其他节点的查询。并且每个节点的路由表必须只包含已知的好节点(good node)：</p>
<p>一个好的节点是一个节点在过去15分钟内响应了我们的一个查询。如果一个节点在过去15分钟内响应了我们的查询并向我们发送了一个查询，那么它也是一个好节点。</p>
<p>一个节点在15分钟不活动之后，节点就会变得可疑(questionable)。</p>
<p>而当节点无法响应一个或者多个连续的查询时(fail to respond to multiple queries in a row)，它们就会变得糟糕(bad)。</p>
<p>并且我们在查询时良好的节点会优先于状态未知的节点。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt17.svg"><img width="899" height="772" src=":/d3304c4403404c30ae41a445e9666085"/></a></p>
<p>一个路由表覆盖了从0到2^160的整个节点ID空间。我们将路由表细分为“桶(buckets)”，每个桶覆盖部分空间。</p>
<p>一个空表有一个bucket，其ID空间范围为min&#x3D;0, max&#x3D;2^160。</p>
<p>空表只有一个bucket，因此任何节点都必须包含在其中。在一个桶变“满(full)*”之前，每个桶只能容纳K个节点，目前是8个。</p>
<p>当一个bucket中已经填满已知的好节点(full of known good nodes)时，我们可以不再添加节点，除非我们自己的节点ID在bucket的范围内。此时，这个桶会被两个桶替换，每个桶都是旧桶的一半。旧桶中的节点被分布在新桶中。</p>
<p>对于只有一个bucket的新表，我们总是将完整的bucket分割为覆盖范围为0 - 2^159 和 2^159 - 2^160。</p>
<p>当桶中满是好的节点时，我们只需丢弃新节点。当桶中的节点变坏(被确认变坏)时，我们才用一个新节点替换它们。</p>
<blockquote>
<p>当节点被认为是有问题(questionable)的，并且在过去15分钟内没有任何响应，那么最近最少无响应的节点将被ping。节点响应或不响应。响应意味着我们移动到下一个节点。我们重复这样做，直到找到一个没有响应的节点。</p>
<p>如果我们没有找到，那么这个桶就被认为是好的。</p>
<p>当我们确实找到一个节点无响应时，我们会在丢弃该节点并用新的好节点替换它们之前，再尝试ping一次。</p>
</blockquote>
<p>同时，每个桶都维护了一个“最后更改(last changed)”属性，以显示其存储内容的“新鲜程度(fresh)”。</p>
<p>当桶中的一个节点被ping并响应，或一个新节点被添加到桶中，或一个节点被另一个节点替换时，将会更新桶的last changed属性。</p>
<p>如果last changed属性在最近15分钟内没有更新，则会刷新bucket。</p>
<h3 id="攻击BitTorrent"><a href="#攻击BitTorrent" class="headerlink" title="攻击BitTorrent"></a><a href="#%E6%94%BB%E5%87%BBBitTorrent" title="攻击BitTorrent"></a>攻击BitTorrent</h3><p>对BitTorrent网络的攻击很少，因为一切都是公开的，比如：我们的IP地址，我们下载的东西等；</p>
<p>有人可能会问，为什么要攻击开放网络？为什么要攻击一个完全开放的网络？</p>
<p>在<a target="_blank" rel="noopener" href="https://www.exploit-db.com/">Exploit-DB</a>上只列出了7个条目，并且大多数都是针对特定的客户��</p>
<p>对BitTorrent网络的主要攻击目的是阻止盗版。我们谈到这里还没有谈到盗版，但它通常是BitTorrent的同义词。</p>
<p>bt的主要攻击手段是bt中毒(Torrent Poisoning)。</p>
<h4 id="Torrent-Poisoning"><a href="#Torrent-Poisoning" class="headerlink" title="Torrent Poisoning"></a><a href="#Torrent-Poisoning" title="Torrent Poisoning"></a>Torrent Poisoning</h4><p>这种攻击的目的是获取盗版内容的对等点的IP地址或以某种方式修改文件内容。</p>
<p>麦当娜(Madonna)发行的《Madonna’s American Life》专辑就是内容中毒的一个例子。在发行之前，曲目发行的长度和文件大小类似。歌曲中有一段麦当娜说：</p>
<blockquote>
<p>“What the fuck do you think you’re doing?”</p>
</blockquote>
<p>随后是几分钟的沉默。</p>
<p>下面是一些使种子中毒的方法。</p>
<p><strong>① Index Poisoning</strong></p>
<p>索引允许用户定位具有所需内容的对等节点的IP地址。这种攻击方法可以让对等点的搜索变得困难。</p>
<p>攻击者会在索引中插入大量无效信息，以阻止用户找到正确的信息。</p>
<p>其思想是通过让对等点尝试从无效对等点下载片段来减慢下载速度。</p>
<p><strong>② Decoy Insertion</strong></p>
<p>他们将文件的损坏版本插入网络。</p>
<p>想象一下，一个文件有500份拷贝，其中只有2份是真正的文件，这会阻止盗版者找到真正的文件。</p>
<p>但是，大多数有种子列表的网站都有投票系统。这阻止了这种攻击，因为搜索的顶部充满了未损坏的文件。</p>
<p>在GameDevTycoon中，损坏的文件是在正版文件上传到盗版网站之前发布的。盗版者不知道的是，文件已经损坏。在盗版游戏中除了无法获得胜利，其他一切都是正常的！</p>
<h3 id="防御BitTorrent攻击"><a href="#防御BitTorrent攻击" class="headerlink" title="防御BitTorrent攻击"></a><a href="#%E9%98%B2%E5%BE%A1BitTorrent%E6%94%BB%E5%87%BB" title="防御BitTorrent攻击"></a>防御BitTorrent攻击</h3><p>最受欢迎的种子是由多年来建立融洽关系的个人或团体发布的。而在私人tracker上，种子的资源可以指向个人。所有，有毒的种子可以很快被贴上标签，从而传播也可以被禁止。</p>
<p>换而言之，在公共tracker上，下载由受信任团体制作的种子更可取。毕竟，你是喜欢从Ubuntu团队下载Ubuntu，还是从用户xxx- hackers - elite - ghost - protocol- xxx下载？</p>
<p>在公共tracker中，如果一个种子是有毒的，该种子会被报告和删除。</p>
<p>防御bt攻击最简单的方法是使用一个与你无关的IP地址，无论这是通过VPN还是其他服务(The simplest way to defend against a BitTorrent attack is to use an IP address not associated with you. Whether this is through a VPN or some other service)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#%E6%80%BB%E7%BB%93" title="总结"></a>总结</h3><p>通过阅读本文，我想你学到了：</p>
<ul>
<li>什么是BitTorrent；</li>
<li>什么是Torrent描述符文件；</li>
<li>BitTorrent如何选择对等点；</li>
<li>BitTorrent如何选择文件块；</li>
<li>严格的优先级（Strict Priority）；</li>
<li>最少的优先（Rarest First）</li>
<li>残局模式（Endgame Mode）</li>
<li>阻塞算法（Choking Algorithms）</li>
<li>以牙还牙算法（tit-for-tat）；</li>
<li>帕累托效率（Pareto Efficiency）</li>
<li>开放检测（Optimistic Unchoking）</li>
<li>反对歧视（Anti-snubbing）</li>
<li>仅仅上传（Upload Only）</li>
<li>什么是tracker；</li>
<li>对BitTorrent网络的攻击；</li>
<li>……</li>
</ul>
<p>如果你想继续深入了解BitTorrent：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://allenkim67.github.io/programming/2016/05/04/how-to-make-your-own-bittorrent-client.html">Build your own BitTorrent client</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bittorrent.org/beps/bep_0000.html">Explore BitTorrent’s proposals (BEPs) to learn more about how it works, and what’s next for the algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bittorrent.org/beps/bep_0003.html">Read the official BitTorrent specification</a></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><a href="#%E9%99%84%E5%BD%95" title="附录"></a>附录</h2><p>原文链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://skerritt.blog/bit-torrent/">How Does BitTorrent Work? a Plain English Guide</a></li>
</ul>
<p>对于搭建Aria2离线下载服务器感兴趣的可以看我的这几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/01/Aria2%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">Aria2安装与配置</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E4%BD%BF%E7%94%A8Aria2%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/">使用Aria2搭建你自己的离线下载服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E8%A7%A3%E5%86%B3Aria2%E7%9A%84BT%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E6%88%96%E6%B2%A1%E9%80%9F%E5%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98/">解决Aria2的BT下载速度慢或没速度的问题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/03/20/Aria2%E5%B1%8F%E8%94%BD%E8%BF%85%E9%9B%B7%E7%AD%89%E5%90%B8%E8%A1%80%E5%AE%A2%E6%88%B7%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/Aria2%E5%B1%8F%E8%94%BD%E8%BF%85%E9%9B%B7%E7%AD%89%E5%90%B8%E8%A1%80%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="post-title-link" itemprop="url">Aria2屏蔽迅雷等吸血客户端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 12:01:50" itemprop="dateCreated datePublished" datetime="2022-03-20T12:01:50+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:52:06" itemprop="dateModified" datetime="2022-05-01T10:52:06+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Aria2屏蔽迅雷等吸血客户端，自动更新tracker，移除wantDigest头的Docker镜像。</p>
<!---more--->
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker create --name=aria2 \</span><br><span class="line">-v &lt;path to downloads&gt;:/mnt \</span><br><span class="line">-v &lt;path to config&gt;:/config \</span><br><span class="line">-e PGID=&lt;gid&gt; -e PUID=&lt;uid&gt; \</span><br><span class="line">-e TZ=&lt;timezone&gt; -e SECRET=&lt;admin&gt; \</span><br><span class="line">-e RPC=&lt;6800&gt; PORT=&lt;16881&gt; WEB=&lt;80&gt; \</span><br><span class="line">-p 6800:6800 -p 16881:16881 -p80:80 \</span><br><span class="line">auska/docker-aria2</span><br></pre></td></tr></table></figure>

<h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><ul>
<li><code>-p 80</code> 网页管理端口</li>
<li><code>-p 6800</code> PRC端口</li>
<li><code>-p 16881</code> - BT软件通讯端口</li>
<li><code>-v /config</code> - 配置文件目录</li>
<li><code>-v /mnt</code> - 下载文件目录</li>
<li><code>-e PGID</code> 用户的GroupID，留空为root</li>
<li><code>-e PUID</code> 用户的UserID，留空为root</li>
<li><code>-e SECRET</code> 登录密钥，默认admin</li>
<li><code>-e TZ</code> 时区 默认 Asia&#x2F;Shanghai</li>
</ul>
<h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>latest ： 自带WEB。</p>
<p>no-web ： 不包括WEB_UI。</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2022-03-17 增加屏蔽迅雷等吸血客户端，webui更新到1.2.3。</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>Docker：<a target="_blank" rel="noopener" href="https://hub.docker.com/repository/docker/auska/docker-aria2">https://hub.docker.com/repository/docker/auska/docker-aria2</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/03/19/qbitttorrent%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/19/qbitttorrent%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB/" class="post-title-link" itemprop="url">qbitttorrent静态编译文件分享</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-19 17:54:12" itemprop="dateCreated datePublished" datetime="2022-03-19T17:54:12+08:00">2022-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:52:20" itemprop="dateModified" datetime="2022-05-01T10:52:20+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>qbitttorrent 静态编译文件分享。</p>
<!---more--->

<h1 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h1><p>原版：<a target="_blank" rel="noopener" href="https://github.com/qbittorrent/qBittorrent">https://github.com/qbittorrent/qBittorrent</a><br>增强版：<a target="_blank" rel="noopener" href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a><br>快校版：<a target="_blank" rel="noopener" href="https://github.com/ChisBread/libtorrent">https://github.com/ChisBread/libtorrent</a><br>增强+快校版：综合和两个版本的功能。</p>
<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>Github：<a target="_blank" rel="noopener" href="https://github.com/Auska/qbittorrent-static/releases">https://github.com/Auska/qbittorrent-static/releases</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2020/06/02/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85-qBittorrent-%E5%A5%97%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/02/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85-qBittorrent-%E5%A5%97%E4%BB%B6/" class="post-title-link" itemprop="url">群晖安装 qBittorrent 套件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 09:11:38" itemprop="dateCreated datePublished" datetime="2020-06-02T09:11:38+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:51:55" itemprop="dateModified" datetime="2022-05-01T10:51:55+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>自从疫情期间，圈养在家无事可做，只能没事玩玩PT。那么即使然是玩PT就不然少不了qBittorrent。但是当时软件版本只有4.19.1，像我这样追新的人肯定不满意，故编译了4.2.5版本。</p>
<!---more--->
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装方法网上有很多，这里简单说一下注意点：</p>
<ol>
<li>首先启动家目录服务。</li>
<li>确认启用了admin账户（需要以自定用户启动的请往下看）。</li>
</ol>
<p>推荐几个链接不再赘述。</p>
<blockquote>
<p>参考1——<a target="_blank" rel="noopener" href="https://blog.zuiyu1818.cn/posts/NAS_qBittorrent.html">点击前往</a><br>参考2——<a target="_blank" rel="noopener" href="https://www.pjs.ink/qbittorrent.html">点击前往</a></p>
</blockquote>
<hr>
<h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><p>本段需要一定的Linux知识。<br>目录说明：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>路径</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>存放配置</td>
<td>&#x2F;var&#x2F;services&#x2F;homes&#x2F;${USER}&#x2F;.config</td>
<td>USER默认为admin</td>
</tr>
<tr>
<td>安装位置</td>
<td>&#x2F;var&#x2F;packages&#x2F;${NAME}&#x2F;target</td>
<td>NAME默认为qBittorrent</td>
</tr>
<tr>
<td>启动脚本</td>
<td>&#x2F;var&#x2F;packages&#x2F;${NAME}&#x2F;scripts</td>
<td>NAME默认为qBittorrent</td>
</tr>
</tbody></table>
<h3 id="调整启动用户"><a href="#调整启动用户" class="headerlink" title="调整启动用户"></a>调整启动用户</h3><p>修改<code>/var/packages/qBittorrent/scripts/start-stop-status</code>文件，将第三行<code>USER=admin</code>的<code>admin</code>改成自己用户的，重启插件。</p>
<h3 id="备份种子信息及设置"><a href="#备份种子信息及设置" class="headerlink" title="备份种子信息及设置"></a>备份种子信息及设置</h3><p>停止插件，复制<code>/var/services/homes/admin/.config</code>文件夹。</p>
<h3 id="直接更换qBittorrent版本"><a href="#直接更换qBittorrent版本" class="headerlink" title="直接更换qBittorrent版本"></a>直接更换qBittorrent版本</h3><p>将<code>qBittorrent</code>的二进制文件替换到<code>/var/packages/qBittorrent/target/qbittorrent-nox</code>，重启插件即可。</p>
<blockquote>
<p>请使用全静态编译的二进制文件，否则无法启动。</p>
</blockquote>
<hr>
<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>后面带<code>+</code>为增强版,否则为原版。</p>
<h3 id="增强版"><a href="#增强版" class="headerlink" title="增强版"></a>增强版</h3><p>即为使用<a target="_blank" rel="noopener" href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">qBittorrent-Enhanced-Edition</a>源码编译的版本，适合BT任务。</p>
<blockquote>
<p>特色功能：会默认断开吸血客户端，根据网址自动添加tracker。</p>
</blockquote>
<hr>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1sKfRwlwEufq9S1AbgtKKog">下载链接</a> 提取码<code>urwi</code></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2018/09/11/Docker%20%E4%B8%AA%E4%BA%BA%E9%95%9C%E5%83%8F%E8%B5%84%E6%BA%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/11/Docker%20%E4%B8%AA%E4%BA%BA%E9%95%9C%E5%83%8F%E8%B5%84%E6%BA%90/" class="post-title-link" itemprop="url">Docker 个人镜像资源</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-09-11 17:54:12" itemprop="dateCreated datePublished" datetime="2018-09-11T17:54:12+08:00">2018-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:52:13" itemprop="dateModified" datetime="2022-05-01T10:52:13+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>平时制作的镜像工具。</p>
<!---more--->

<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>Docker：<a target="_blank" rel="noopener" href="https://hub.docker.com/u/auska">https://hub.docker.com/u/auska</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2016/06/21/Shell-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/06/21/Shell-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">Shell 基本运算符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-06-21 10:32:28" itemprop="dateCreated datePublished" datetime="2016-06-21T10:32:28+08:00">2016-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:33:23" itemprop="dateModified" datetime="2022-05-01T10:33:23+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Shell</code> 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<!---more--->

<p>原生<code>bash</code>不支持简单的数学运算，但是可以通过其他命令来实现，例如 <code>awk</code> 和 <code>expr</code>，<code>expr</code> 最常用。</p>
<p><code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p>两点注意：</p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<hr>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td>`expr $a + $b` 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>`expr $a - $b` 结果为 -10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>`expr $a \* $b` 结果为  200。</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
<td>`expr $b &#x2F; $a` 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>`expr $b % $a` 结果为 0。</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;$b 把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td>[ $a &#x3D;&#x3D; $b ] 返回 false。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td>[ $a !&#x3D; $b ] 返回 true。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>:条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a&#x3D;&#x3D;$b]</strong> 是错误的，必须写成 **[ $a &#x3D;&#x3D; $b ]**。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>乘号(*)前边必须加反斜杠(\)才能实现乘法运算；</li>
<li>if…then…fi 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 expr 语法是：**$((表达式))*<em>，此处表达式中的 “</em>“ 不需要转义符号 “\“ 。</li>
</ul>
</blockquote>
<hr>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td>[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否不相等，不相等返回 true。</td>
<td>[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td>[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td>[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td>[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td>[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<hr>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td>[ ! false ] 返回 true。</td>
</tr>
<tr>
<td>-o</td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td>-a</td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<hr>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑的 AND</td>
<td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>
<tr>
<td>|</td>
<td>逻辑的 OR</td>
<td>[[ $a -lt 100 | $b -gt 100 ]] 返回 true</td>
</tr>
</tbody></table>
<hr>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a &#x3D; $b ] 返回 false。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检测两个字符串是否不相等，不相等返回 true。</td>
<td>[ $a !&#x3D; $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否不为 0，不为 0 返回 true。</td>
<td>[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td>$</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<hr>
<h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td>[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td>[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td>[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td>[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td>[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td>[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是有名管道，如果是，则返回 true。</td>
<td>[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td>[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td>[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td>[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td>[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td>[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td>[ -e $file ] 返回 true。</td>
</tr>
</tbody></table>
<p>其他检查符：</p>
<ul>
<li><strong>-S</strong>: 判断某文件是否 socket。</li>
<li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2016/06/11/Shell-%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/06/11/Shell-%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Shell 函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-06-11 10:31:09" itemprop="dateCreated datePublished" datetime="2016-06-11T10:31:09+08:00">2016-06-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:32:06" itemprop="dateModified" datetime="2022-05-01T10:32:06+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>linux shell</code> 可以用户定义函数，然后在<code>shell</code>脚本中可以随便调用。</p>
<!---more--->

<p><code>shell</code>中函数的定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\[ function \] funname \[()\]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    \[return int;\]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>1、可以带<code>function fun()</code> 定义，也可以直接<code>fun()</code> 定义,不带任何参数。</li>
<li>2、参数返回，可以显示加：<code>return</code> 返回，如果不加，将以最后一条命令运行结果，作为返回值。 <code>return</code>后跟数值<code>n(0-255)</code></li>
</ul>
<hr>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在<code>Shell</code>中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…</p>
<p>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>$&#123;10&#125;</code>。当<code>n&gt;=10</code>时，需要使用<code>$&#123;n&#125;</code>来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2016/06/05/Shell-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/06/05/Shell-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/" class="post-title-link" itemprop="url">Shell 输入/输出重定向</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-06-05 10:29:58" itemprop="dateCreated datePublished" datetime="2016-06-05T10:29:58+08:00">2016-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:32:06" itemprop="dateModified" datetime="2022-05-01T10:32:06+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>大多数 <code>UNIX </code>系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<!---more--->

<p>重定向命令列表如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command &gt; file</td>
<td>将输出重定向到 file。</td>
</tr>
<tr>
<td>command &lt; file</td>
<td>将输入重定向到 file。</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td>将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td>n &gt; file</td>
<td>将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td>n &gt;&gt; file</td>
<td>将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td>将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td>将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td>&lt;&lt; tag</td>
<td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
</blockquote>
<hr>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p>
<p><code>command1 &gt; file1</code></p>
<p>上面这个命令执行<code>command1</code>然后将输出的内容存入<code>file1</code>。</p>
<p>注意任何<code>file1</code>内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用<code>&gt;&gt;</code>操作符。</p>
<hr>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p>
<p><code>command1 &lt; file1</code></p>
<p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>
<p>注意：输出重定向是大于号<code>&gt;</code>，输入重定向是小于号<code>&lt;</code>。</p>
<h3 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h3><p>一般情况下，每个 Unix&#x2F;Linux 命令运行时都会打开三个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</span><br><span class="line">- 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</span><br><span class="line">- 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>command &gt; file</code> 将 <code>stdout</code> 重定向到 <code>file</code>，<code>command &lt; file</code> 将<code>stdin</code> 重定向到 <code>file</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2016/05/21/TCP-IP-%E9%82%AE%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/05/21/TCP-IP-%E9%82%AE%E4%BB%B6/" class="post-title-link" itemprop="url">TCP/IP 邮件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-05-21 10:26:50" itemprop="dateCreated datePublished" datetime="2016-05-21T10:26:50+08:00">2016-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:28:21" itemprop="dateModified" datetime="2022-05-01T10:28:21+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<p>电子邮件是 TCP&#x2F;IP 最重要的应用之一。</p>
<hr>
<!---more--->

<h2 id="您不会用到…"><a href="#您不会用到…" class="headerlink" title="您不会用到…"></a>您不会用到…</h2><p>当您写邮件时，您不会用到 TCP&#x2F;IP。</p>
<p>当您写邮件时，您用到的是电子邮件程序，例如莲花软件的 Notes，微软公司出品的 Outlook，或者 Netscape Communicator 等等。</p>
<hr>
<h2 id="邮件程序会用到…"><a href="#邮件程序会用到…" class="headerlink" title="邮件程序会用到…"></a>邮件程序会用到…</h2><p>您的电子邮件程序使用不同的 TCP&#x2F;IP 协议：</p>
<ul>
<li>使用 SMTP 来发送邮件</li>
<li>使用 POP 从邮件服务器下载邮件</li>
<li>使用 IMAP 连接到邮件服务器</li>
</ul>
<hr>
<h2 id="SMTP-简单邮件传输协议"><a href="#SMTP-简单邮件传输协议" class="headerlink" title="SMTP - 简单邮件传输协议"></a>SMTP - 简单邮件传输协议</h2><p>SMTP 协议用于传输电子邮件。SMTP 负责把邮件发送到另一台计算机。</p>
<p>通常情况下，邮件会被送到一台邮件服务器（SMTP 服务器），然后被送到另一台（或几台）服务器，然后最终被送到它的目的地。</p>
<p>SMTP 也可以传送纯文本，但是无法传输诸如图片、声音或者电影之类的二进制数据。</p>
<p>SMTP 使用 MIME 协议通过 TCP&#x2F;IP 网络来发送二进制数据。MIME 协议会将二进制数据转换为纯文本。</p>
<hr>
<h2 id="POP-邮局协议"><a href="#POP-邮局协议" class="headerlink" title="POP - 邮局协议"></a>POP - 邮局协议</h2><p>POP 协议被邮件程序用来取回邮件服务器上面的邮件。</p>
<p>假如您的邮件程序使用 POP，那么一旦它连接上邮件服务器，您的所有的邮件都会被下载到邮件程序中（或者称之为邮件客户端）。</p>
<hr>
<h2 id="IMAP-因特网消息访问协议"><a href="#IMAP-因特网消息访问协议" class="headerlink" title="IMAP - 因特网消息访问协议"></a>IMAP - 因特网消息访问协议</h2><p>与 POP 类似，IMAP 协议同样被邮件程序使用。</p>
<p>IMAP 协议与 POP 协议之间的主要差异是：如果 IMAP 连上了邮件服务器，它不会自动地将邮件下载到邮件程序之中。</p>
<p>IMAP 使您有能力在下载邮件之前先通过邮件服务器端查看他们。通过 IMAP，您可以选择下载这些邮件或者仅仅是删除它们。比方说您需要从不同的位置访问邮件服务器，但是仅仅希望回到办公室的时候再下载邮件，IMAP 在这种情况下会很有用。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Auska</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
