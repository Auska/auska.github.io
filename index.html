<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"auska.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="随便写点啥">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://auska.github.io/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="随便写点啥">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Auska">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://auska.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Auska"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Auska</p>
  <div class="site-description" itemprop="description">随便写点啥</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Auska" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Auska" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:luodan0709@live.cn" title="E-Mail → mailto:luodan0709@live.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/05/19/%E7%A6%BB%E7%BA%BF%E6%9F%A5%E8%AF%A2IP%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E5%92%8CCDN%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E5%95%86%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/19/%E7%A6%BB%E7%BA%BF%E6%9F%A5%E8%AF%A2IP%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E5%92%8CCDN%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E5%95%86%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">【转载】离线查询IP地理信息和CDN服务提供商的终端工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-19 19:20:09 / 修改时间：20:09:03" itemprop="dateCreated datePublished" datetime="2022-05-19T19:20:09+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a><a target="_blank" rel="noopener" href="https://github.com/zu1k/nali">来源</a></h2><p>该工具受 Nali C版本 和 nali-cli js版本的启发.</p>
<p>我想要在终端对IP地理信息和CDN服务提供商进行查询，发现了Nali这个工具，Nali与哪里谐音，非常适合这类工具</p>
<p>经过简单的使用，我发现最初的C语言版本功能缺失，而js版本包实在大的恐怖、而支持的平台非常有限，所以我用golang重写了这个工具，在原有功能的基础上增加了对IPv6的支持，并且增加了Geoip2数据库</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>支持多种数据库<ul>
<li>纯真 IPv4 离线数据库</li>
<li>ZX IPv6 离线数据库</li>
<li>Geoip2 城市数据库 (可选)</li>
<li>IPIP 数据库 (可选)</li>
<li>ip2region 数据库 (可选)</li>
<li>DB-IP 数据库 (可选)</li>
<li>IP2Location DB3 LITE 数据库 (可选)</li>
</ul>
</li>
<li>CDN 服务提供商查询</li>
<li>支持管道处理</li>
<li>支持交互式查询</li>
<li>同时支持IPv4和IPv6</li>
<li>支持多语言</li>
<li>查询完全离线</li>
<li>全平台支持</li>
<li>支持彩色输出</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="从源码安装"><a href="#从源码安装" class="headerlink" title="从源码安装"></a>从源码安装</h3><p>Nali 需要预先安装 Go &gt;&#x3D; 1.18. 安装后可以从源码安装软件:</p>
<p>$ go install github.com&#x2F;zu1k&#x2F;nali@latest</p>
<h3 id="下载预编译的可执行程序"><a href="#下载预编译的可执行程序" class="headerlink" title="下载预编译的可执行程序"></a>下载预编译的可执行程序</h3><p>可以从Release页面下载预编译好的可执行程序: <a target="_blank" rel="noopener" href="https://github.com/zu1k/nali/releases">Release</a></p>
<p>你需要选择适合你系统和硬件架构的版本下载，解压后可直接运行</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="查询一个IP的地理信息"><a href="#查询一个IP的地理信息" class="headerlink" title="查询一个IP的地理信息"></a>查询一个IP的地理信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nali 1.2.3.4</span><br><span class="line">1.2.3.4 [澳大利亚 APNIC Debogon-prefix网络] </span><br></pre></td></tr></table></figure>

<h4 id="或者-使用-管道"><a href="#或者-使用-管道" class="headerlink" title="或者 使用 管道"></a>或者 使用 <code>管道</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo IP 6.6.6.6 | nali</span><br><span class="line">IP 6.6.6.6 [美国 亚利桑那州华楚卡堡市美国国防部网络中心] </span><br></pre></td></tr></table></figure>

<h3 id="同时查询多个IP的地理信息"><a href="#同时查询多个IP的地理信息" class="headerlink" title="同时查询多个IP的地理信息"></a>同时查询多个IP的地理信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nali 1.2.3.4 4.3.2.1 123.23.3.0</span><br><span class="line">1.2.3.4 [澳大利亚 APNIC Debogon-prefix网络]</span><br><span class="line">4.3.2.1 [美国 新泽西州纽瓦克市Level3Communications]</span><br><span class="line">123.23.3.0 [越南 越南邮电集团公司] </span><br></pre></td></tr></table></figure>

<h3 id="交互式查询"><a href="#交互式查询" class="headerlink" title="交互式查询"></a>交互式查询</h3><p>使用 <code>exit</code> 或 <code>quit</code> 退出查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ nali</span><br><span class="line">123.23.23.23</span><br><span class="line">123.23.23.23 [越南 越南邮电集团公司]</span><br><span class="line">1.0.0.1</span><br><span class="line">1.0.0.1 [美国 APNIC&amp;CloudFlare公共DNS服务器]</span><br><span class="line">8.8.8.8</span><br><span class="line">8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器]</span><br><span class="line">quit </span><br></pre></td></tr></table></figure>

<h3 id="与-dig-命令配合使用"><a href="#与-dig-命令配合使用" class="headerlink" title="与 dig 命令配合使用"></a>与 <code>dig</code> 命令配合使用</h3><p>需要你系统中已经安装好 dig 程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dig nali.zu1k.com +short | nali</span><br><span class="line">104.28.2.115 [美国 CloudFlare公司CDN节点]</span><br><span class="line">104.28.3.115 [美国 CloudFlare公司CDN节点]</span><br><span class="line">172.67.135.48 [美国 CloudFlare节点] </span><br></pre></td></tr></table></figure>

<h3 id="与-nslookup-命令配合使用"><a href="#与-nslookup-命令配合使用" class="headerlink" title="与 nslookup 命令配合使用"></a>与 <code>nslookup</code> 命令配合使用</h3><p>需要你系统中已经安装好 nslookup 程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup nali.zu1k.com 8.8.8.8 | nali</span><br><span class="line">Server:         8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器]</span><br><span class="line">Address:        8.8.8.8 [美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器]#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:   nali.zu1k.com</span><br><span class="line">Address: 104.28.3.115 [美国 CloudFlare公司CDN节点]</span><br><span class="line">Name:   nali.zu1k.com</span><br><span class="line">Address: 104.28.2.115 [美国 CloudFlare公司CDN节点]</span><br><span class="line">Name:   nali.zu1k.com</span><br><span class="line">Address: 172.67.135.48 [美国 CloudFlare节点] </span><br></pre></td></tr></table></figure>

<h3 id="与任意程序配合使用"><a href="#与任意程序配合使用" class="headerlink" title="与任意程序配合使用"></a>与任意程序配合使用</h3><p>因为 nali 支持管道处理，所以可以和任意程序配合使用</p>
<p>Nali 将在 IP后面插入IP地理信息，CDN域名后面插入CDN服务提供商信息</p>
<h3 id="支持IPv6"><a href="#支持IPv6" class="headerlink" title="支持IPv6"></a>支持IPv6</h3><p>和 IPv4 用法完全相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup google.com | nali</span><br><span class="line">Server:         127.0.0.53 [局域网 IP]</span><br><span class="line">Address:        127.0.0.53 [局域网 IP]#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:   google.com</span><br><span class="line">Address: 216.58.211.110 [美国 Google全球边缘网络]</span><br><span class="line">Name:   google.com</span><br><span class="line">Address: 2a00:1450:400e:809::200e [荷兰Amsterdam Google Inc. 服务器网段] </span><br></pre></td></tr></table></figure>

<h3 id="查询-CDN-服务提供商"><a href="#查询-CDN-服务提供商" class="headerlink" title="查询 CDN 服务提供商"></a>查询 CDN 服务提供商</h3><p>因为 CDN 服务通常使用 CNAME 的域名解析方式，所以推荐与 <code>nslookup</code> 或者 <code>dig</code> 配合使用，在已经知道 CNAME 后可单独使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www.gov.cn | nali</span><br><span class="line">Server:         127.0.0.53 [局域网 IP]</span><br><span class="line">Address:        127.0.0.53 [局域网 IP]#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">www.gov.cn      canonical name = www.gov.cn.bsgslb.cn [白山云 CDN].</span><br><span class="line">www.gov.cn.bsgslb.cn [白山云 CDN]       canonical name = zgovweb.v.bsgslb.cn [白山云 CDN].</span><br><span class="line">Name:   zgovweb.v.bsgslb.cn [白山云 CDN]</span><br><span class="line">Address: 103.104.170.25 [新加坡 ]</span><br><span class="line">Name:   zgovweb.v.bsgslb.cn [白山云 CDN]</span><br><span class="line">Address: 2001:428:6402:21b::5 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)]</span><br><span class="line">Name:   zgovweb.v.bsgslb.cn [白山云 CDN]</span><br><span class="line">Address: 2001:428:6402:21b::6 [美国Louisiana州Monroe Qwest Communications Company, LLC (CenturyLink)] </span><br></pre></td></tr></table></figure>

<h2 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h2><p>程序第一次运行后，会在工作目录生成配置文件 <code>config.yaml</code> (默认<code>~/.nali/config.yaml</code>)，配置文件定义了数据库信息，默认用户无需进行修改</p>
<p>数据库格式默认如下：</p>
<p>- name: geoip<br>  name-alias:<br>  - geolite<br>  - geolite2<br>  format: mmdb<br>  file: GeoLite2-City.mmdb<br>  languages:<br>  - ALL<br>  types:<br>  - IPv4<br>  - IPv6</p>
<p>其中，<code>languages</code> 和 <code>types</code> 表示该数据库支持的语言和查询类型。 如果你需要增加数据库，需小心修改配置文件，如果有任何问题，欢迎提 issue 询问。</p>
<h3 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ nali --help</span><br><span class="line">Usage:</span><br><span class="line">  nali [flags]</span><br><span class="line">  nali [command]</span><br><span class="line"></span><br><span class="line">Available Commands:</span><br><span class="line">  help        Help about any command</span><br><span class="line">  update      update qqwry, zxipv6wry, ip2region ip database and cdn</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -h, --help     help for nali</span><br><span class="line">  -t, --toggle   Help message for toggle</span><br><span class="line"></span><br><span class="line">Use &quot;nali [command] --help&quot; for more information about a command. </span><br></pre></td></tr></table></figure>

<h3 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h3><p>更新所有可以自动更新的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nali update</span><br><span class="line">2020/07/17 12:53:46 正在下载最新纯真 IP 库...</span><br><span class="line">2020/07/17 12:54:05 已将最新的纯真 IP 库保存到本地 /root/.nali/qqwry.dat </span><br></pre></td></tr></table></figure>

<p>或者指定数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nali update --db qqwry,cdn</span><br><span class="line">2020/07/17 12:53:46 正在下载最新纯真 IP 库...</span><br><span class="line">2020/07/17 12:54:05 已将最新的纯真 IP 库保存到本地 /root/.nali/qqwry.dat </span><br></pre></td></tr></table></figure>

<h3 id="自选数据库"><a href="#自选数据库" class="headerlink" title="自选数据库"></a>自选数据库</h3><p>用户可以指定使用哪个数据库，需要设置环境变量： <code>NALI_DB_IP4</code>、<code>NALI_DB_IP6</code> 或者两个同时设置</p>
<p>支持的变量内容:</p>
<ul>
<li>Geoip2 <code>[&#39;geoip&#39;, &#39;geoip2&#39;]</code></li>
<li>Chunzhen <code>[&#39;chunzhen&#39;, &#39;qqwry&#39;]</code></li>
<li>IPIP <code>[&#39;ipip&#39;]</code></li>
<li>Ip2Resion <code>[&#39;ip2region&#39;, &#39;i2r&#39;]</code></li>
<li>DBIP <code>[&#39;dbip&#39;, &#39;db-ip&#39;]</code></li>
<li>IP2Location <code>[&#39;ip2location&#39;]</code></li>
</ul>
<h4 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h4><h5 id="使用geoip数据库"><a href="#使用geoip数据库" class="headerlink" title="使用geoip数据库"></a>使用geoip数据库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set NALI_DB_IP4=geoip</span><br><span class="line"></span><br><span class="line">或者使用 powershell</span><br><span class="line"></span><br><span class="line">$env:NALI_DB_IP4=&quot;geoip&quot; </span><br></pre></td></tr></table></figure>

<h5 id="使用ipip数据库"><a href="#使用ipip数据库" class="headerlink" title="使用ipip数据库"></a>使用ipip数据库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set NALI_DB_IP6=ipip</span><br><span class="line"></span><br><span class="line">或者使用 powershell</span><br><span class="line"></span><br><span class="line">$env:NALI_DB_IP6=&quot;ipip&quot; </span><br></pre></td></tr></table></figure>

<h4 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h4><h5 id="使用geoip数据库-1"><a href="#使用geoip数据库-1" class="headerlink" title="使用geoip数据库"></a>使用geoip数据库</h5><h5 id="使用ipip数据库-1"><a href="#使用ipip数据库-1" class="headerlink" title="使用ipip数据库"></a>使用ipip数据库</h5><h3 id="多语言支持"><a href="#多语言支持" class="headerlink" title="多语言支持"></a>多语言支持</h3><p>通过修改环境变量 <code>NALI_LANG</code> 来指定使用的语言，当使用非中文语言时仅支持GeoIP2这个数据库</p>
<p>该参数可设置的值见 GeoIP2 这个数据库的支持列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># NALI_LANG=en nali 1.1.1.1</span><br><span class="line">1.1.1.1 [Australia] </span><br></pre></td></tr></table></figure>

<h3 id="更换工作目录"><a href="#更换工作目录" class="headerlink" title="更换工作目录"></a>更换工作目录</h3><p>如果未指定数据库存放目录，数据库默认将存放在 <code>~/.nali</code></p>
<p>设置环境变量 <code>NALI_HOME</code> 来指定工作目录，数据库存放在工作目录下。也可在配置文件中使用绝对路径指定其他数据库路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set NALI_HOME=D:\nali</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">export NALI_HOME=/var/nali </span><br></pre></td></tr></table></figure>

<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p><strong>Nali</strong> © <a target="_blank" rel="noopener" href="https://github.com/zu1k">zu1k</a>, 遵循 <a target="_blank" rel="noopener" href="https://github.com/zu1k/nali/blob/master/LICENSE">MIT</a> 证书.</p>
<blockquote>
<p>Blog <a target="_blank" rel="noopener" href="https://zu1k.com/">zu1k.com</a> · GitHub <a target="_blank" rel="noopener" href="https://github.com/zu1k">@zu1k</a> · Twitter <a target="_blank" rel="noopener" href="https://twitter.com/zu1k_lv">@zu1k_lv</a> · Telegram Channel <a target="_blank" rel="noopener" href="https://t.me/peekfun">@peekfun</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/05/19/%E5%AE%89%E8%A3%85rTorrent%E5%BF%83%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/19/%E5%AE%89%E8%A3%85rTorrent%E5%BF%83%E5%BE%97/" class="post-title-link" itemprop="url">安装rTorrent心得</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-19 15:25:02 / 修改时间：15:29:40" itemprop="dateCreated datePublished" datetime="2022-05-19T15:25:02+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是rTorrent"><a href="#什么是rTorrent" class="headerlink" title="什么是rTorrent"></a>什么是rTorrent</h1><p>rTorrent是一个非常简洁、优秀、非常轻量的命令行BT下载客户端，和Aria2一样，既可以使用命令行下载，也可以配合自己的Web前端进行控制操作。很多都喜欢用rTorrent配合前端ruTorrent一起使用，毕竟有个图形界面方便些，不过配置起来挺麻烦的，博主觉得单独使用rtorrent下载BT文件速度还可以，操作也不难，关键安装很简单，很适合临时下载BT文件的人。</p>
<h1 id="rTorrent的优缺点"><a href="#rTorrent的优缺点" class="headerlink" title="rTorrent的优缺点"></a>rTorrent的优缺点</h1><p>优点：</p>
<ul>
<li>性能极高，资源占用少（相当于transmission资源消耗，却拥有不不弱于qbittorrent的速度）</li>
<li>包含丰富的命令，对于保种、做种有极大的自由度</li>
</ul>
<p>缺点：</p>
<ul>
<li>安装配置极其复杂</li>
</ul>
<h1 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h1><p>有两版本分别是<a target="_blank" rel="noopener" href="https://github.com/rakshasa/rtorrent">官方版</a>与<a target="_blank" rel="noopener" href="https://github.com/jesec/rtorrent">jesec</a>，后者提供了更加友好的面向用户的其他功能、优化以及与 RPC 接口的现代用户的更好集成；这里主要讨论<strong>jesec</strong>的版本。</p>
<h1 id="安装rTorrent"><a href="#安装rTorrent" class="headerlink" title="安装rTorrent"></a>安装rTorrent</h1><p>安装完全静态的二进制文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Install rTorrent to /usr/local/bin/rtorrent</span><br><span class="line"># rtorrent-linux-amd64 and rtorrent-linux-arm64 are available</span><br><span class="line">sudo wget https://github.com/jesec/rtorrent/releases/latest/download/rtorrent-linux-amd64 -O /usr/local/bin/rtorrent</span><br><span class="line"></span><br><span class="line"># Make it executable</span><br><span class="line">sudo chmod +x /usr/local/bin/rtorrent</span><br><span class="line"></span><br><span class="line"># Default configuration</span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/rtorrent</span><br><span class="line">sudo wget https://github.com/jesec/rtorrent/releases/latest/download/rtorrent.rc -O /etc/rtorrent/rtorrent.rc</span><br><span class="line"></span><br><span class="line"># Install as a systemd service (optional)</span><br><span class="line"># This example uses &quot;download&quot; user. Replace it with the an existing user that rTorrent should run with.</span><br><span class="line">sudo wget https://github.com/jesec/rtorrent/releases/latest/download/rtorrent@.service -O /etc/systemd/system/rtorrent@.service</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable rtorrent@download</span><br><span class="line">sudo systemctl start rtorrent@download</span><br></pre></td></tr></table></figure>
<p>其它安装方式，请自行搜索。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>rTorrent 尝试从多个位置加载配置文件：</p>
<ul>
<li><code>$XDG_CONFIG_HOME/rtorrent/rtorrent.rc</code> （最高优先级）</li>
<li><code>$HOME/.config/rtorrent/rtorrent.rc</code></li>
<li><code>$HOME/.rtorrent.rc</code></li>
<li><code>/etc/rtorrent/rtorrent.rc</code> （最低优先级）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/jesec/rtorrent/blob/master/doc/rtorrent.rc">配置模板</a></p>
<h2 id="内核调整"><a href="#内核调整" class="headerlink" title="内核调整"></a>内核调整</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># /etc/security/limits.conf</span><br><span class="line">* - nofile 51200</span><br><span class="line"></span><br><span class="line"># /etc/sysctl.conf (XanMod Kernel)</span><br><span class="line">vm.swappiness=10</span><br><span class="line"></span><br><span class="line">net.core.default_qdisc=fq_pie</span><br><span class="line">net.ipv4.tcp_congestion_control=bbr2</span><br><span class="line"></span><br><span class="line"># Maximum Socket Receive Buffer. 16MB per socket - which sounds like a lot, but will virtually never consume that much. Default: 212992</span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line"># Maximum Socket Send Buffer. 16MB per socket - which sounds like a lot, but will virtually never consume that much. Default: 212992</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line"># Increase the write-buffer-space allocatable: min 4KB, def 12MB, max 16MB. Default: 4096 16384 4194304</span><br><span class="line">net.ipv4.tcp_wmem = 4096 12582912 16777216</span><br><span class="line"># Increase the read-buffer-space allocatable: min 4KB, def 12MB, max 16MB. Default: 4096 16384 4194304</span><br><span class="line">net.ipv4.tcp_rmem = 4096 12582912 16777216</span><br><span class="line"></span><br><span class="line"># Tells the system whether it should start at the default window size only for new TCP connections or also for existing TCP connections that have been idle for too long. Default: 1</span><br><span class="line">net.ipv4.tcp_slow_start_after_idle = 0</span><br><span class="line"># Allow reuse of sockets in TIME_WAIT state for new connections only when it is safe from the network stack’s perspective. Default: 0</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"># Do not last the complete time_wait cycle. Default: 0</span><br><span class="line"># only works from Linux 2.4 to 4.11</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"># Minimum time a socket will stay in TIME_WAIT state (unusable after being used once). Default: 60</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure>

<h2 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#############################################################################</span><br><span class="line"># A minimal rTorrent configuration that provides the basic features</span><br><span class="line">#############################################################################</span><br><span class="line"></span><br><span class="line"># Some default configs are commented out by #, you can override them to fit your needs</span><br><span class="line"># Lines commented out by ## are merely examples (NOT default)</span><br><span class="line"></span><br><span class="line"># It is recommended to extend upon this default config file. For example:</span><br><span class="line"># override only some configs via command line: -o network.port_range.set=6881-6881</span><br><span class="line"># or, on top of custom config: import = /etc/rtorrent/rtorrent.rc</span><br><span class="line"></span><br><span class="line"># Some additional values and commands</span><br><span class="line">method.insert = system.startup_time, value|const, (system.time)</span><br><span class="line"></span><br><span class="line"># rTorrent runtime directory (cfg.basedir) [default: &quot;$HOME/.local/share/rtorrent&quot;]</span><br><span class="line">method.insert = cfg.basedir,  private|const|string, (cat,(fs.homedir),&quot;/rtorrent/&quot;)</span><br><span class="line"></span><br><span class="line"># Default download directory (cfg.download) [default: &quot;$(cfg.basedir)/download&quot;]</span><br><span class="line">#method.insert = cfg.download, private|const|string, (cat,(cfg.basedir),&quot;download/&quot;)</span><br><span class="line">method.insert = cfg.download, private|const|string, (cat,&quot;/home/data/下载/&quot;)</span><br><span class="line"></span><br><span class="line"># Log directory (cfg.logs) [default: &quot;$(cfg.basedir)/log&quot;]</span><br><span class="line">method.insert = cfg.logs,     private|const|string, (cat,(cfg.basedir),&quot;log/&quot;)</span><br><span class="line">method.insert = cfg.logfile,  private|const|string, (cat,(cfg.logs),&quot;rtorrent-&quot;,(system.time),&quot;.log&quot;)</span><br><span class="line"></span><br><span class="line"># Torrent session directory (cfg.session) [default: &quot;$(cfg.basedir)/.session&quot;]</span><br><span class="line">method.insert = cfg.session,  private|const|string, (cat,(cfg.basedir),&quot;.session/&quot;)</span><br><span class="line"></span><br><span class="line"># Watch (drop to add) directories (cfg.watch) [default: &quot;$(cfg.basedir)/watch&quot;]</span><br><span class="line">method.insert = cfg.watch,    private|const|string, (cat,(cfg.basedir),&quot;watch/&quot;)</span><br><span class="line"></span><br><span class="line"># Create directories</span><br><span class="line">fs.mkdir.recursive = (cat,(cfg.basedir))</span><br><span class="line"></span><br><span class="line">fs.mkdir = (cat,(cfg.download))</span><br><span class="line">fs.mkdir = (cat,(cfg.logs))</span><br><span class="line">fs.mkdir = (cat,(cfg.session))</span><br><span class="line"></span><br><span class="line">fs.mkdir = (cat,(cfg.watch))</span><br><span class="line">fs.mkdir = (cat,(cfg.watch),&quot;/load&quot;)</span><br><span class="line">fs.mkdir = (cat,(cfg.watch),&quot;/start&quot;)</span><br><span class="line"></span><br><span class="line"># Drop to &quot;$(cfg.watch)/load&quot; to add torrent</span><br><span class="line">schedule2 = watch_load, 11, 10, ((load.verbose, (cat, (cfg.watch), &quot;load/*.torrent&quot;)))</span><br><span class="line"></span><br><span class="line"># Drop to &quot;$(cfg.watch)/start&quot; to add torrent and start downloading</span><br><span class="line">schedule2 = watch_start, 10, 10, ((load.start_verbose, (cat, (cfg.watch), &quot;start/*.torrent&quot;)))</span><br><span class="line"></span><br><span class="line"># Listening port for incoming peer traffic</span><br><span class="line">network.port_range.set = 51418-51418</span><br><span class="line">network.port_random.set = no</span><br><span class="line"></span><br><span class="line"># Distributed Hash Table and Peer EXchange</span><br><span class="line"># Enable tracker-less torrents but vulnerable to passive sniffing</span><br><span class="line"># DHT and PEX are always disabled for private torrents</span><br><span class="line">#dht.mode.set = auto</span><br><span class="line">#dht.port.set = 51418</span><br><span class="line">#protocol.pex.set = yes</span><br><span class="line">dht.mode.set = disable</span><br><span class="line">protocol.pex.set = no</span><br><span class="line"></span><br><span class="line"># DHT nodes for bootstrapping</span><br><span class="line">dht.add_bootstrap = dht.transmissionbt.com:6881</span><br><span class="line">dht.add_bootstrap = dht.libtorrent.org:25401</span><br><span class="line"></span><br><span class="line"># UDP tracker support</span><br><span class="line">#trackers.use_udp.set = yes</span><br><span class="line">trackers.use_udp.set = no</span><br><span class="line"></span><br><span class="line"># Peer settings</span><br><span class="line">throttle.max_downloads.set = 100</span><br><span class="line">throttle.max_uploads.set = 100</span><br><span class="line">throttle.max_downloads.global.set = 300</span><br><span class="line">throttle.max_uploads.global.set = 300</span><br><span class="line">throttle.min_peers.normal.set = 100</span><br><span class="line">throttle.max_peers.normal.set = 200</span><br><span class="line">throttle.min_peers.seed.set = 100</span><br><span class="line">throttle.max_peers.seed.set = 0</span><br><span class="line">trackers.numwant.set = 100</span><br><span class="line"></span><br><span class="line">#protocol.encryption.set = allow_incoming,try_outgoing,enable_retry</span><br><span class="line"></span><br><span class="line"># Limits for file handle resources, this is optimized for</span><br><span class="line"># an `ulimit` of 1024 (a common default). You MUST leave</span><br><span class="line"># a ceiling of handles reserved for rTorrent&#x27;s internal needs!</span><br><span class="line">network.max_open_files.set = 10240</span><br><span class="line">network.max_open_sockets.set = 500</span><br><span class="line"></span><br><span class="line"># Send and receive buffer size for socket. Disabled by default (`0`), this means the default is used by OS </span><br><span class="line">#  (you have to modify the system wide settings!) (`send_buffer_size`, `receive_buffer_size`)</span><br><span class="line"># Increasing buffer sizes may help reduce disk seeking, connection polling as more data is buffered each time</span><br><span class="line">#  the socket is written to. It will result higher memory usage (not visible in rtorrent process!).</span><br><span class="line">network.receive_buffer.size.set =  4M</span><br><span class="line">network.send_buffer.size.set    = 12M</span><br><span class="line"></span><br><span class="line"># Memory resource usage (increase if you have a large number of items loaded,</span><br><span class="line"># and/or the available resources to spend)</span><br><span class="line">pieces.memory.max.set = 1800M</span><br><span class="line">#network.xmlrpc.size_limit.set = 16M</span><br><span class="line"></span><br><span class="line"># Preallocate disk space for contents of a torrent</span><br><span class="line">#</span><br><span class="line"># Useful for reducing fragmentation, improving the performance</span><br><span class="line"># and I/O patterns of future read operations. However, with this</span><br><span class="line"># enabled, preallocated files will occupy the full size even if</span><br><span class="line"># they are not completed.</span><br><span class="line">#</span><br><span class="line"># If you choose to allocate space for the whole torrent at once,</span><br><span class="line"># rTorrent will create all files and allocate the space when the</span><br><span class="line"># torrent is started. rTorrent will NOT delete the file and free</span><br><span class="line"># the allocated space, if you later mark a file as DO NOT DOWNLOAD.</span><br><span class="line">#</span><br><span class="line">#   0 = disabled</span><br><span class="line">#   1 = enabled, allocate when a file is opened for write</span><br><span class="line">#   2 = enabled, allocate the space for the whole torrent at once</span><br><span class="line">system.file.allocate.set = 2</span><br><span class="line"></span><br><span class="line"># Basic operational settings</span><br><span class="line">session.path.set = (cat, (cfg.session))</span><br><span class="line">directory.default.set = (cat, (cfg.download))</span><br><span class="line">log.execute = (cat, (cfg.logs), &quot;execute.log&quot;)</span><br><span class="line">##log.xmlrpc = (cat, (cfg.logs), &quot;xmlrpc.log&quot;)</span><br><span class="line"></span><br><span class="line"># Other operational settings</span><br><span class="line">encoding.add = utf8</span><br><span class="line">system.umask.set = 0027</span><br><span class="line">system.cwd.set = (directory.default)</span><br><span class="line">#schedule2 = low_diskspace, 5, 60, ((close_low_diskspace, 500M))</span><br><span class="line">#pieces.hash.on_completion.set = no</span><br><span class="line">pieces.hash.on_completion.set = no</span><br><span class="line">##view.sort_current = seeding, greater=d.ratio=</span><br><span class="line">##keys.layout.set = qwerty</span><br><span class="line"></span><br><span class="line"># HTTP and SSL</span><br><span class="line">network.http.max_open.set = 50</span><br><span class="line">network.http.dns_cache_timeout.set = 25</span><br><span class="line"></span><br><span class="line"># Path to the CA bundle. By default, rTorrent tries to detect from:</span><br><span class="line">#   $RTORRENT_CA_BUNDLE (highest priority)</span><br><span class="line">#   $CURL_CA_BUNDLE</span><br><span class="line">#   $SSL_CERT_FILE</span><br><span class="line">#   /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">#   /etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">#   /usr/share/ssl/certs/ca-bundle.crt</span><br><span class="line">#   /usr/local/share/certs/ca-root-nss.crt</span><br><span class="line">#   /etc/ssl/cert.pem (lowest priority)</span><br><span class="line">##network.http.cacert.set = /etc/ssl/certs/ca-certificates.crt</span><br><span class="line"></span><br><span class="line"># Path to the certificate directory to verify the peer. The certificates</span><br><span class="line"># must be in PEM format, and the directory must have been processed using</span><br><span class="line"># the c_rehash utility supplied with openssl.</span><br><span class="line">#</span><br><span class="line"># For advanced users only, generally you should use network.http.cacert.set</span><br><span class="line"># to specify path to the bundle of certificates.</span><br><span class="line">##network.http.capath.set = &quot;/etc/ssl/certs&quot;</span><br><span class="line"></span><br><span class="line">#network.http.ssl_verify_peer.set = 1</span><br><span class="line">#network.http.ssl_verify_host.set = 1</span><br><span class="line"></span><br><span class="line"># Run the rTorrent process as a daemon in the background</span><br><span class="line">#system.daemon.set = false</span><br><span class="line"></span><br><span class="line"># XML-RPC interface</span><br><span class="line">network.scgi.open_local = (cat,(cfg.basedir),rtorrent.sock)</span><br><span class="line"></span><br><span class="line"># Logging:</span><br><span class="line">#   Levels = critical error warn notice info debug</span><br><span class="line">#   Groups = connection_* dht_* peer_* rpc_* storage_* thread_* tracker_* torrent_*</span><br><span class="line">print = (cat, &quot;Logging to &quot;, (cfg.logfile))</span><br><span class="line">log.open_file = &quot;log&quot;, (cfg.logfile)</span><br><span class="line">log.add_output = &quot;info&quot;, &quot;log&quot;</span><br><span class="line">##log.add_output = &quot;tracker_debug&quot;, &quot;log&quot;</span><br><span class="line"></span><br><span class="line">### END of rtorrent.rc ###</span><br></pre></td></tr></table></figure>

<h1 id="批量迁移种子文件"><a href="#批量迁移种子文件" class="headerlink" title="批量迁移种子文件"></a>批量迁移种子文件</h1><h2 id="rtorrent-fast-resume-pl"><a href="#rtorrent-fast-resume-pl" class="headerlink" title="rtorrent_fast_resume.pl"></a>rtorrent_fast_resume.pl</h2><p><strong>rtorrent_fast_resume.pl</strong> 是一个<strong>Perl</strong>脚本，可以将快速恢复数据添加到种子文件，从而跳过<strong>rTorrent</strong>必须对所有文件进行哈希检查。</p>
<h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rtorrent_fast_resume.pl [文件所在目录] [种子路径.torrent] [生成种子路径.torrent]</span><br></pre></td></tr></table></figure>
<h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 安装Bencode_XS</span><br><span class="line">wget http://search.cpan.org/CPAN/authors/id/I/IW/IWADE/Convert-Bencode_XS-0.06.tar.gz</span><br><span class="line">wget https://rt.cpan.org/Ticket/Attachment/1433449/761974/patch-t_001_tests_t</span><br><span class="line">tar zxf Convert-Bencode_XS-0.06.tar.gz</span><br><span class="line">cd Convert-Bencode_XS-0.06</span><br><span class="line">patch -uNp0 -i ../patch-t_001_tests_t</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make</span><br><span class="line">make test</span><br><span class="line">sudo make install</span><br><span class="line">## The patch-t_001_tests_t patch itself:</span><br><span class="line">--- t/001_tests.t.orig&lt;&gt;Sat Nov 15 14:41:13 2014</span><br><span class="line">+++ t/001_tests.t&lt;-----&gt;Sat Nov 15 14:41:27 2014</span><br><span class="line">@@ -109,6 +109,7 @@ SKIP: &#123;</span><br><span class="line">     #we use Storable so we do not rely on bencode</span><br><span class="line">     eval q&#123;use Storable qw(freeze)&#125;;.</span><br><span class="line">     skip &quot;Storable not available&quot;, 12 if $@;</span><br><span class="line">+    local $Storable::canonical = 1;</span><br><span class="line">     local $Convert::Bencode_XS::COERCE = 0;</span><br><span class="line">     is( freeze(bdecode(&#x27;le&#x27;)), freeze([]) );</span><br><span class="line">     is( freeze(bdecode(&#x27;l0:0:0:e&#x27;)), freeze([&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;]) );</span><br><span class="line"># 安装rtorrent_fast_resume.pl脚本</span><br><span class="line">sudo wget https://github.com/jesec/rtorrent/raw/master/doc/rtorrent_fast_resume.pl -O /usr/local/bin/rtorrent_fast_resume.pl</span><br></pre></td></tr></table></figure>
<h2 id="迁移脚本"><a href="#迁移脚本" class="headerlink" title="迁移脚本"></a>迁移脚本</h2><p><code>move_torrent.sh </code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for i in `cat $1`; do</span><br><span class="line">	echo $&#123;i&#125;</span><br><span class="line">	rtorrent_fast_resume.pl $3 &quot;$&#123;2&#125;/$&#123;i&#125;.torrent&quot; &quot;$&#123;4&#125;/$&#123;i&#125;.torrent&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash move_torrent.sh [需要迁移种子列表] [需要迁移种子所在目录] [文件所在目录] [生成种子目录]</span><br></pre></td></tr></table></figure>
<ul>
<li>需要迁移种子列表：不含后缀名</li>
<li>需要迁移种子所在目录：略</li>
<li>文件所在目录：略</li>
<li>生成种子目录：略</li>
</ul>
<h1 id="BUG与处理方式"><a href="#BUG与处理方式" class="headerlink" title="BUG与处理方式"></a>BUG与处理方式</h1><h2 id="random-device"><a href="#random-device" class="headerlink" title="random_device"></a>random_device</h2><p><strong>rTorrent</strong> 无法启动&#x2F;循环启动。</p>
<h3 id="systemd日志"><a href="#systemd日志" class="headerlink" title="systemd日志"></a>systemd日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl status rtorrent.service</span><br><span class="line">● rtorrent.service - rTorrent service for Docker</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/rtorrent.service; disabled; vendor preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Wed 2022-05-18 06:17:52 CST; 10s ago</span><br><span class="line">    Process: 140420 ExecStart=/usr/local/bin/rtorrent -o system.daemon.set=true (code=exited, status=255/EXCEPTION)</span><br><span class="line">   Main PID: 140420 (code=exited, status=255/EXCEPTION)</span><br><span class="line">        CPU: 912ms</span><br><span class="line"></span><br><span class="line">May 18 06:17:51 nas systemd[1]: Started rTorrent service for Docker.</span><br><span class="line">May 18 06:17:51 nas rtorrent[140420]: rTorrent: loading 939 entries from session directory</span><br><span class="line">May 18 06:17:52 nas rtorrent[140420]: rTorrent: started, 939 torrents loaded</span><br><span class="line">May 18 06:17:52 nas rtorrent[140420]: rtorrent: random_device::random_device(const std::string&amp;): device not available</span><br><span class="line">May 18 06:17:52 nas systemd[1]: rtorrent.service: Main process exited, code=exited, status=255/EXCEPTION</span><br><span class="line">May 18 06:17:52 nas systemd[1]: rtorrent.service: Failed with result &#x27;exit-code&#x27;.</span><br></pre></td></tr></table></figure>
<h3 id="处理方式一"><a href="#处理方式一" class="headerlink" title="处理方式一"></a>处理方式一</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">screen -S rt</span><br><span class="line">export XDG_CONFIG_HOME=/usr/local/etc</span><br><span class="line">/usr/local/bin/rtorrent -o system.daemon.set=true</span><br></pre></td></tr></table></figure>
<h3 id="处理方式二"><a href="#处理方式二" class="headerlink" title="处理方式二"></a>处理方式二</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"># 增加一行</span><br><span class="line">*/5 * * * * /usr/bin/bash -c &quot;export XDG_CONFIG_HOME=/usr/local/etc &amp;&amp; test `pidof rtorrent` || /usr/local/bin/rtorrent -o system.daemon.set=true &amp;&quot;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/05/17/%E5%AE%89%E8%A3%85Torrust%E7%A7%8D%E5%AD%90%E7%BD%91%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/17/%E5%AE%89%E8%A3%85Torrust%E7%A7%8D%E5%AD%90%E7%BD%91%E7%AB%99/" class="post-title-link" itemprop="url">安装Torrust种子网站</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-17 20:05:21" itemprop="dateCreated datePublished" datetime="2022-05-17T20:05:21+08:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 20:07:19" itemprop="dateModified" datetime="2022-05-19T20:07:19+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Torrust是一个开源项目，它为您提供了托管自己的（私人）BitTorrent跟踪器和在线洪流索引所需的所有工具。</p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>Torrust 分为两个独立的应用程序</p>
<ul>
<li><code>Torrust Tracker</code>：一款高性能且功能丰富的（私有）BitTorrent跟踪器。</li>
<li><code>Torrust Index</code>：一个依赖于Torrust跟踪器的种子索引网站。<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2></li>
<li><input checked="" disabled="" type="checkbox"> 列表项自托管高性能 BitTorrent 跟踪器。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项支持公共，私人和白名单跟踪器模式。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项用于将种子列入白名单和发布跟踪器密钥的 API。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项电子邮件&#x2F;密码身份验证（可选电子邮件验证）。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项种子上传&#x2F;下载（包括磁力链接）。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项洪流审核。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项可定制的洪流类别。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项无需外部服务。</li>
<li><input checked="" disabled="" type="checkbox"> 列表项完全用 Rust 编写！</li>
</ul>
<hr>
<h1 id="安装Torrust-Tracker"><a href="#安装Torrust-Tracker" class="headerlink" title="安装Torrust Tracker"></a>安装Torrust Tracker</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><ul>
<li>OpenSSL:<ul>
<li>Arch Linux: <code>sudo pacman -S pkg-config openssl</code></li>
<li>Debian&#x2F;Ubuntu: <code>sudo apt-get install pkg-config libssl-dev</code></li>
</ul>
</li>
<li>SQLite3:<ul>
<li>Debian&#x2F;Ubuntu: <code>sudo apt-get install libsqlite3-dev</code></li>
</ul>
</li>
</ul>
<ol>
<li>克隆源码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/torrust</span><br><span class="line">cd /opt/torrust</span><br><span class="line">git clone https://github.com/torrust/torrust-tracker.git </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编译源码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd torrust-tracker</span><br><span class="line">cargo build --release </span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有错，请运行 <code>rustup update stable</code> 再编译</p>
</blockquote>
<ol start="3">
<li>运行一次生成 <code>config.toml</code> 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./target/release/torrust-tracker </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编辑配置文件<code>config.toml</code>  (查看: <a target="_blank" rel="noopener" href="https://torrust.com/torrust-tracker/config/">配置文档</a>)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano config.toml </span><br></pre></td></tr></table></figure>

<p>模板 <code>config.toml</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">log_level = &quot;info&quot;</span><br><span class="line">mode = &quot;private&quot;</span><br><span class="line">db_driver = &quot;Sqlite3&quot;</span><br><span class="line">db_path = &quot;data.db&quot;</span><br><span class="line">announce_interval = 120</span><br><span class="line">min_announce_interval = 120</span><br><span class="line">max_peer_timeout = 900</span><br><span class="line">on_reverse_proxy = false</span><br><span class="line">external_ip = &quot;0.0.0.0&quot;</span><br><span class="line">tracker_usage_statistics = true</span><br><span class="line">persistent_torrent_completed_stat = false</span><br><span class="line">inactive_peer_cleanup_interval = 600</span><br><span class="line">remove_peerless_torrents = true</span><br><span class="line"></span><br><span class="line">[[udp_trackers]]</span><br><span class="line">enabled = false</span><br><span class="line">bind_address = &quot;0.0.0.0:6969&quot;</span><br><span class="line"></span><br><span class="line">[[http_trackers]]</span><br><span class="line">enabled = true</span><br><span class="line">bind_address = &quot;0.0.0.0:6969&quot;</span><br><span class="line">ssl_enabled = false</span><br><span class="line">ssl_cert_path = &quot;&quot;</span><br><span class="line">ssl_key_path = &quot;&quot;</span><br><span class="line"></span><br><span class="line">[http_api]</span><br><span class="line">enabled = true</span><br><span class="line">bind_address = &quot;127.0.0.1:1212&quot;</span><br><span class="line"></span><br><span class="line">[http_api.access_tokens]</span><br><span class="line">admin = &quot;MyAccessToken&quot; </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>打开 <code>bind_address</code>端口 (default: 6969):</li>
</ol>
<blockquote>
<p>如果要配置<strong>NGINX</strong>请跳过此步骤。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 6969 </span><br></pre></td></tr></table></figure>

<h3 id="可选-你的-SSL-证书"><a href="#可选-你的-SSL-证书" class="headerlink" title="(可选) 你的 SSL 证书"></a>(可选) 你的 SSL 证书</h3><blockquote>
<p>如果要配置<strong>NGINX</strong>请跳过此步骤。</p>
</blockquote>
<ol>
<li>编辑 <code>nano.config</code> 文件并更改以下设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[[http_trackers]]</span><br><span class="line">...</span><br><span class="line">ssl_enabled = true</span><br><span class="line">ssl_cert_path = &quot;YOUR_CERT_PATH&quot;</span><br><span class="line">ssl_key_path = &quot;YOUR_CERT_KEY_PATH&quot;</span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<h2 id="安装-NGINX"><a href="#安装-NGINX" class="headerlink" title="安装 NGINX"></a>安装 NGINX</h2><p>按照上述安装步骤 1-4 进行操作。</p>
<ol start="5">
<li>更改以下设置<code>config.toml</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">on_reverse_proxy = true</span><br><span class="line">...</span><br><span class="line">[[http_trackers]]</span><br><span class="line">bind_address = &quot;127.0.0.1:6969&quot;</span><br><span class="line">ssl_enabled = false</span><br><span class="line">... </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>为跟踪器创建一个 NGINX 配置（例如：tracker.torrust.com）</li>
</ol>
<blockquote>
<p>请务必改用您自己的域名。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/nginx/sites-available/tracker.torrust.com </span><br></pre></td></tr></table></figure>

<ul>
<li>插入示例配置</li>
</ul>
<blockquote>
<p>请勿复制 SSL 注释，并确保将域名更改为您的域名。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># without SSL</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name tracker.torrust.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_pass http://127.0.0.1:6969;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>确保更改<code>ssl_certificate</code>路径。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># with SSL</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name tracker.torrust.com;</span><br><span class="line"></span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name tracker.torrust.com;</span><br><span class="line"></span><br><span class="line">    ssl_certificate CERT_PATH</span><br><span class="line">    ssl_certificate_key CERT_KEY_PATH; </span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_pass http://127.0.0.1:6969;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="7">
<li>通过创建指向<code>sites-enabled</code> 目录中配置的符号链接来启用配置</li>
</ol>
<blockquote>
<p>将 tracker.torrust.com 替换为您的域&#x2F;NGINX 配置。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/tracker.torrust.com /etc/nginx/sites-enabled/ </span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在此之后，您可以通过<code>nginx -t</code>执行来测试配置的有效性，如果配置有效，您可以安全地重新加载Nginx以使新配置处于活动状态：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload nginx </span><br></pre></td></tr></table></figure>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol>
<li>在文件夹中，您可以像这样运行torrust跟踪器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./target/release/torrust-tracker </span><br></pre></td></tr></table></figure>

<h2 id="与-Tmux-的用法"><a href="#与-Tmux-的用法" class="headerlink" title="与 Tmux 的用法"></a>与 Tmux 的用法</h2><ol>
<li>打开新的 <code>Tmux</code> 会话</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s torrust-tracker </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>Tmux</code> 会话中，运行 <code>torrust</code> 跟踪器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/torrust/torrust-tracker</span><br><span class="line">./target/release/torrust-tracker </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从 <code>Tmux</code> 会话中分离</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CTRL+B</span><br><span class="line">D </span><br></pre></td></tr></table></figure>
<hr>
<h1 id="安装Torrust"><a href="#安装Torrust" class="headerlink" title="安装Torrust"></a>安装Torrust</h1><h2 id="安装必备组件"><a href="#安装必备组件" class="headerlink" title="安装必备组件"></a>安装必备组件</h2><p>前端不能单独运行，需要外部<strong>Web</strong>服务器，如<strong>Apache</strong>或<strong>NGINX</strong>。在本指南中，我们将使用<strong>Nginx</strong>。</p>
<ul>
<li>Node (version &gt;&#x3D; 12.0.0)<ul>
<li>Debian&#x2F;Ubuntu:</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_12.x | bash -</span><br><span class="line">apt-get install -y nodejs </span><br></pre></td></tr></table></figure>

<ul>
<li>NPM<ul>
<li>Debian&#x2F;Ubuntu: <code>sudo apt-get install npm</code></li>
</ul>
</li>
<li>NGINX:<ul>
<li>Debian&#x2F;Ubuntu: <code>sudo apt install nginx</code></li>
<li>有关其他发行版：请参阅 <a target="_blank" rel="noopener" href="https://www.nginx.com/resources/wiki/start/topics/tutorials/install/">Nginx 安装教程</a></li>
</ul>
</li>
</ul>
<h2 id="安装后端"><a href="#安装后端" class="headerlink" title="安装后端"></a>安装后端</h2><ol>
<li>创建 torrust 安装目录（如果尚未创建）并克隆存储库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/torrust</span><br><span class="line">cd /opt/torrust</span><br><span class="line">git clone https://github.com/torrust/torrust.git </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>切换到后端目录并创建一个名<code>.env</code>为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd torrust/backend</span><br><span class="line">echo &quot;DATABASE_URL=sqlite://data.db?mode=rwc&quot; &gt; .env </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后，我们必须创建 SQLite 数据库并运行迁移。安装<code>sqlx-cli</code>并创建数据库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo install sqlx-cli</span><br><span class="line">sqlx db setup </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>现在构建后端</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>运行后端一次以生成 <code>config.toml</code> 文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/torrust/torrust/backend</span><br><span class="line">./target/release/torrust </span><br></pre></td></tr></table></figure>

<ol start="6">
<li>然后编辑<code>config.toml</code>并更改至少以下键：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano config.toml </span><br></pre></td></tr></table></figure>

<p><code>[tracker]</code></p>
<ul>
<li><code>url</code>: 设置为跟踪器的连接字符串。例如： <code>udp://TRACKER_IP:6969</code>.</li>
<li><code>api_url</code>: 设置为跟踪器 <code>API URL</code>。默认：<code>http://localhost:1212</code>.</li>
<li><code>token</code>: 将其设置为 <code>Torrust Tracker</code> <code>config.toml</code> 中的访问令牌。</li>
</ul>
<p><code>[net]</code></p>
<ul>
<li><code>port</code>: 默认设置为 <code>3000</code> 。如果您选择其他端口，请确保也更改Nginx配置。</li>
</ul>
<p><code>[auth]</code></p>
<ul>
<li><code>secret_key</code>: 设置为安全随机生成的字符串。</li>
</ul>
<h2 id="运行后端"><a href="#运行后端" class="headerlink" title="运行后端"></a>运行后端</h2><ol>
<li>使用以下命令运行后端</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/torrust/torrust/backend</span><br><span class="line">./target/release/torrust </span><br></pre></td></tr></table></figure>

<h2 id="使用-Tmux-运行后端"><a href="#使用-Tmux-运行后端" class="headerlink" title="使用 Tmux 运行后端"></a>使用 <code>Tmux</code> 运行后端</h2><ol>
<li>使用 <code>Tmux</code> 运行后端</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s torrust-index</span><br><span class="line">cd /opt/torrust/torrust/backend</span><br><span class="line">./target/release/torrust </span><br></pre></td></tr></table></figure>

<blockquote>
<p>按下<code>CTRL+B D</code>以退出 tmux 会话而不终止它。</p>
</blockquote>
<h2 id="安装前端"><a href="#安装前端" class="headerlink" title="安装前端"></a>安装前端</h2><ol>
<li>首先创建一个名为<code>.env</code>的文件</li>
</ol>
<blockquote>
<p>请务必更改域名。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/torrust/torrust/frontend</span><br><span class="line">echo &quot;VITE_API_BASE_URL=https://YOUR_DOMAIN/api&quot; &gt; .env </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>构建前端</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run build </span><br></pre></td></tr></table></figure>

<p>成功完成此命令后， <code>dist</code> 该文件夹中将包含前端的构建版本。这些文件将由<code>Nginx</code>在后续步骤中提供。</p>
<h3 id="NGINX-配置"><a href="#NGINX-配置" class="headerlink" title="NGINX 配置"></a>NGINX 配置</h3><ol>
<li>创建一个包含以下内容<code>/etc/nginx/sites-available/torrust.conf</code>文件</li>
</ol>
<blockquote>
<p>需要更改 YOUR_DOMAIN x2, CERT_PATH 和 CERT_KEY_PATH.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name YOUR_DOMAIN;</span><br><span class="line"></span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name YOUR_DOMAIN;</span><br><span class="line"></span><br><span class="line">    ssl_certificate CERT_PATH;</span><br><span class="line">    ssl_certificate_key CERT_KEY_PATH;</span><br><span class="line"></span><br><span class="line">    root /opt/torrust/torrust/frontend/dist/;</span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /api/ &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:3000/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过在<code>sites-enabled</code>目录中创建指向配置的符号链接来启用配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/torrust.conf /etc/nginx/sites-enabled/ </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在此之后，您可以通过<code>nginx -t</code>执行来测试配置的有效性，如果配置有效，您可以安全地重新加载<code>Nginx</code>以使新配置处于活动状态</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload nginx </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/04/30/ZFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%88%E9%80%82%E5%90%88%E6%8C%82PT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/30/ZFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%BE%88%E9%80%82%E5%90%88%E6%8C%82PT/" class="post-title-link" itemprop="url">ZFS文件系统很适合挂PT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-30 17:34:17" itemprop="dateCreated datePublished" datetime="2022-04-30T17:34:17+08:00">2022-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:22:48" itemprop="dateModified" datetime="2022-05-01T10:22:48+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是ZFS文件系统"><a href="#什么是ZFS文件系统" class="headerlink" title="什么是ZFS文件系统"></a>什么是ZFS文件系统</h1><p>ZFS文件系统的英文名称为Zettabyte File System,也叫动态文件系统（Dynamic File System）,是第一个128位文件系统。最初是由Sun公司为Solaris 10操作系统开发的文件系统。作为OpenSolaris开源计划的一部分，ZFS于2005年11月发布，被Sun称为是终极文件系统，经历了 10 年的活跃开发。而最新的开发将全面开放，并重新命名为 OpenZFS</p>
<hr>
<!---more--->

<h1 id="ZFS文件系统特点"><a href="#ZFS文件系统特点" class="headerlink" title="ZFS文件系统特点"></a>ZFS文件系统特点</h1><h2 id="强大的实时数据缩减技术"><a href="#强大的实时数据缩减技术" class="headerlink" title="强大的实时数据缩减技术"></a>强大的实时数据缩减技术</h2><p>在线实时处理的区块层级 (Block-based) 数据重复删除机制 (Inline Data Deduplication)，让数据在写入磁盘前就已经过删减演算，大幅节省存储空间占用；加上让大档变小档的数据压缩 (Inline Compression)，以及先进的实时数据压实 (Inline Compaction) 技术，对于存储空间的节省程度带来重大的突破。在数据重复性质高或大量小型数据存取的情境下，提升 SSD 空间使用率的效益尤其明显，不仅显著提升全快闪配置的写入效能，对 SSD 的耐用性与使用寿命也有帮助，让全快闪存储架构成本效益更高。</p>
<h2 id="突破想象的-PB-级巨量存储"><a href="#突破想象的-PB-级巨量存储" class="headerlink" title="突破想象的 PB 级巨量存储"></a>突破想象的 PB 级巨量存储</h2><p>128 位的 ZFS 文件系统拥有巨大的存储潜力，且 ZFS 原生就有强大的 RAID 逻辑磁盘管理功能。基于 ZFS 文件系统的存储方案，单一共享文件夹空间高达 1 PB 容量，更能协助企业克服当前大数据分析、边缘预算、AI 应用等巨量数据存储的挑战。面对 PB 等级的存储容量配置时，RAID Z 磁盘阵列架构亦也有传统磁盘阵列所无法实现的高速建置效率，提供弹性更大、存取效率更高的磁盘空间运用。</p>
<h2 id="零秒瞬间，实时的-SnapSync-快照同步"><a href="#零秒瞬间，实时的-SnapSync-快照同步" class="headerlink" title="零秒瞬间，实时的 SnapSync 快照同步"></a>零秒瞬间，实时的 SnapSync 快照同步</h2><p>ZFS 支持 iSCSI LUN 与共享文件夹的快照，快照数量高达 65,535 份 (假设每小时拍 1 张快照，1 天 24 张，可维持 7 年不用删除！)，实现缜密的多版本快照保护。运用 Copy-on-Write 技术，拍摄快照近乎实时，且不影响当下的系统运作性能。利用快照文件还原数据也无需中断系统正在进行的服务，短时间内即刻启动灾难复原计划。更进阶的区块层级 Real-time SnapSync 实时快照同步功能，让本地 NAS 与备份 NAS 随时随地保持数据同步，关键数据得以获得更新、更完整而实时的备份。</p>
<h2 id="至今最快的-LZ4-数据压缩算法"><a href="#至今最快的-LZ4-数据压缩算法" class="headerlink" title="至今最快的 LZ4 数据压缩算法"></a>至今最快的 LZ4 数据压缩算法</h2><p>LZ4 是一种无损数据压缩算法，可提供极快的压缩和解压缩速度，是商用领域中所需 100 MB&#x2F;s 以上的高速传输存储里，能够提供低延迟、高 IO 量的压缩选择。数据存储进采用 ZFS 文件系统的都会经过在线压缩处理 (Inline Compression)，对于需要频繁压缩、时时快速解压的大量数据处理 (例如：虚拟机) 更具存储效率的优势。尤其再搭配数据重复删除机制，数据减量的效果更为显著。</p>
<hr>
<h1 id="为什么适合挂PT"><a href="#为什么适合挂PT" class="headerlink" title="为什么适合挂PT"></a>为什么适合挂PT</h1><h2 id="什么是PT"><a href="#什么是PT" class="headerlink" title="什么是PT"></a>什么是PT</h2><p>PT全名是Private Tracker。很简单的说，就是基于Bittorrent协议的“点”对“点”的文件传输服务。由于是基于Bittorrent协议，在传输过程中要不断与其他节点交流，彼此分享对方所需要的文件块。因此，会对磁盘进行频繁的读写操作；尤其是在早期出种的时候，更为明显。</p>
<h2 id="ZFS文件系统的缓存机制ARC"><a href="#ZFS文件系统的缓存机制ARC" class="headerlink" title="ZFS文件系统的缓存机制ARC"></a>ZFS文件系统的缓存机制ARC</h2><p>ZFS的可调缓存机制ARC是一种同时缓存数据块请求以及频繁的数据块请求的缓存机制。这是IBM专利自适应替换缓存的基础上的一些修改和扩展。它依赖内存作为高频的Cache缓存；所以，内存稳定对于ZFS文件系统至关重要。</p>
<p>由于ARC缓存机制的存在可以大大降低硬盘的读写；提高机械硬盘的使用寿命与读写速度。</p>
<h1 id="一个月长时间测试"><a href="#一个月长时间测试" class="headerlink" title="一个月长时间测试"></a>一个月长时间测试</h1><p>系统：Gentoo<br>硬件：HP Gen8 （G2020T 低配版本）<br>内存：8G（ECC）<br>硬盘：1T（机械硬盘）</p>
<h2 id="ZFS文件系统配置"><a href="#ZFS文件系统配置" class="headerlink" title="ZFS文件系统配置"></a>ZFS文件系统配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">NAME   PROPERTY              VALUE                  SOURCE</span><br><span class="line">data1  type                  filesystem             -</span><br><span class="line">data1  creation              Sat 01 Apr  8:35 2021  -</span><br><span class="line">data1  used                  614G                   -</span><br><span class="line">data1  available             285G                   -</span><br><span class="line">data1  referenced            614G                   -</span><br><span class="line">data1  compressratio         1.00x                  -</span><br><span class="line">data1  mounted               yes                    -</span><br><span class="line">data1  quota                 none                   default</span><br><span class="line">data1  reservation           none                   default</span><br><span class="line">data1  recordsize            128K                   default</span><br><span class="line">data1  mountpoint            /media/data1           local</span><br><span class="line">data1  sharenfs              off                    default</span><br><span class="line">data1  checksum              on                     default</span><br><span class="line">data1  compression           off                    default</span><br><span class="line">data1  atime                 off                    local</span><br><span class="line">data1  devices               on                     default</span><br><span class="line">data1  exec                  on                     default</span><br><span class="line">data1  setuid                on                     default</span><br><span class="line">data1  readonly              off                    default</span><br><span class="line">data1  zoned                 off                    default</span><br><span class="line">data1  snapdir               hidden                 default</span><br><span class="line">data1  aclmode               discard                default</span><br><span class="line">data1  aclinherit            restricted             default</span><br><span class="line">data1  createtxg             1                      -</span><br><span class="line">data1  canmount              on                     default</span><br><span class="line">data1  xattr                 on                     default</span><br><span class="line">data1  copies                1                      default</span><br><span class="line">data1  version               5                      -</span><br><span class="line">data1  utf8only              off                    -</span><br><span class="line">data1  normalization         none                   -</span><br><span class="line">data1  casesensitivity       sensitive              -</span><br><span class="line">data1  vscan                 off                    default</span><br><span class="line">data1  nbmand                off                    default</span><br><span class="line">data1  sharesmb              off                    default</span><br><span class="line">data1  refquota              none                   default</span><br><span class="line">data1  refreservation        none                   default</span><br><span class="line">data1  guid                  6389372042506996733    -</span><br><span class="line">data1  primarycache          all                    default</span><br><span class="line">data1  secondarycache        all                    default</span><br><span class="line">data1  usedbysnapshots       0B                     -</span><br><span class="line">data1  usedbydataset         614G                   -</span><br><span class="line">data1  usedbychildren        55.8M                  -</span><br><span class="line">data1  usedbyrefreservation  0B                     -</span><br><span class="line">data1  logbias               latency                default</span><br><span class="line">data1  objsetid              54                     -</span><br><span class="line">data1  dedup                 off                    default</span><br><span class="line">data1  mlslabel              none                   default</span><br><span class="line">data1  sync                  standard               default</span><br><span class="line">data1  dnodesize             legacy                 default</span><br><span class="line">data1  refcompressratio      1.00x                  -</span><br><span class="line">data1  written               614G                   -</span><br><span class="line">data1  logicalused           614G                   -</span><br><span class="line">data1  logicalreferenced     614G                   -</span><br><span class="line">data1  volmode               default                default</span><br><span class="line">data1  filesystem_limit      none                   default</span><br><span class="line">data1  snapshot_limit        none                   default</span><br><span class="line">data1  filesystem_count      none                   default</span><br><span class="line">data1  snapshot_count        none                   default</span><br><span class="line">data1  snapdev               hidden                 default</span><br><span class="line">data1  acltype               off                    default</span><br><span class="line">data1  context               none                   default</span><br><span class="line">data1  fscontext             none                   default</span><br><span class="line">data1  defcontext            none                   default</span><br><span class="line">data1  rootcontext           none                   default</span><br><span class="line">data1  relatime              off                    default</span><br><span class="line">data1  redundant_metadata    all                    default</span><br><span class="line">data1  overlay               on                     default</span><br><span class="line">data1  encryption            off                    default</span><br><span class="line">data1  keylocation           none                   default</span><br><span class="line">data1  keyformat             none                   default</span><br><span class="line">data1  pbkdf2iters           0                      default</span><br><span class="line">data1  special_small_blocks  0                      default</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>使用的是<code>transmission</code>作为PT客户<br><img src="/images/port2iz.1month.png" alt="port2iz.1month.png"></p>
<p>下图显示的是内存中块的命中情况</p>
<p><img src="/images/zfs2z.1month.png" alt="zfs2z.1month.png"><br>本月实际上传量: 1.633 TB<br>本月实际下载量: 639.5 GB</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/03/20/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E3%80%90%E8%AF%91%E3%80%91BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E3%80%90%E8%AF%91%E3%80%91BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">【转载】【译】BT下载的工作原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 20:06:02" itemprop="dateCreated datePublished" datetime="2022-03-20T20:06:02+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-04 10:35:54" itemprop="dateModified" datetime="2022-05-04T10:35:54+08:00">2022-05-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>之前有写过几篇关于如何下载、部署Aria2并且进行离线BT下载的文章；但是对于BT的基本原理，如何实现的还是不太明白；</p>
<p>今天RSS上看到一篇非常好的文章，讲的很清楚，但是是英文的，就翻译了一下，分享给大家；</p>
<p>原文链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://skerritt.blog/bit-torrent/">How Does BitTorrent Work? a Plain English Guide</a></li>
</ul>
<p>对于搭建Aria2离线下载服务器感兴趣的可以看我的这几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/01/Aria2%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">Aria2安装与配置</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E4%BD%BF%E7%94%A8Aria2%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/">使用Aria2搭建你自己的离线下载服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E8%A7%A3%E5%86%B3Aria2%E7%9A%84BT%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E6%88%96%E6%B2%A1%E9%80%9F%E5%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98/">解决Aria2的BT下载速度慢或没速度的问题</a></li>
</ul>
<p><a id="more"></a></p>
<h2 id="【译】BT下载的工作原理"><a href="#【译】BT下载的工作原理" class="headerlink" title="【译】BT下载的工作原理"></a><a href="#%E3%80%90%E8%AF%91%E3%80%91BT%E4%B8%8B%E8%BD%BD%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" title="【译】BT下载的工作原理"></a>【译】BT下载的工作原理</h2><blockquote>
<p>BitTorrent是用于传输大文件的最常见协议之一。2013年2月，BitTorrent占全球所有带宽的3.35％，占文件共享专用总带宽6％的一半以上。– <a target="_blank" rel="noopener" href="https://blog.paloaltonetworks.com/app-usage-risk-report-visualization/">3.35% of all worldwide bandwidth</a></p>
</blockquote>
<p>本文不会讲解如何通过BT下载文件(这是一个好的客户端需要做的)；</p>
<p>我们之间进入正题，来看一看BT使用到了哪些技术；</p>
<p>任何人都可以阅读这篇文章，即使是那些对于网络或BitTorrent的知识一无所知的读者；</p>
<h3 id="谁创造了BitTorrent？"><a href="#谁创造了BitTorrent？" class="headerlink" title="谁创造了BitTorrent？"></a><a href="#%E8%B0%81%E5%88%9B%E9%80%A0%E4%BA%86BitTorrent%EF%BC%9F" title="谁创造了BitTorrent？"></a>谁创造了BitTorrent？</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bram_Cohen">Bram Cohen</a>于2001年发明了BitTorrent协议，并且Cohen用Python编写了第一个客户端实现。</p>
<p>科恩收集了一些免费的不可描述内容，来吸引Beta测试人员在2002年夏天使用BitTorrent。</p>
<h3 id="BT-vs-传统CS下载模式"><a href="#BT-vs-传统CS下载模式" class="headerlink" title="BT vs 传统CS下载模式"></a><a href="#BT-vs-%E4%BC%A0%E7%BB%9FCS%E4%B8%8B%E8%BD%BD%E6%A8%A1%E5%BC%8F" title="BT vs 传统CS下载模式"></a>BT vs 传统CS下载模式</h3><p>在传统下载中，服务器上传文件，而客户端下载文件。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt1.png"><img src="/:/528230d770eb45ed915c7ce317de53cc" alt="bt1.png"></a></p>
<p>而由于服务器的带宽限制，导致一些热门的文件下载效率变得十分低下，例如：500个人下载同一个文件将使服务器承受巨大压力。这种压力会限制服务器的上传速度，因此客户端无法快速下载文件。</p>
<p>其次，CS模式的成本很高。我们支付的带宽会随着文件的热门程度而增加。</p>
<p>最后，CS模式是中心化的。如果服务器挂了，则这个文件就无法被任何人下载了！</p>
<p>而BT下载致力于解决这些问题：</p>
<table>
<thead>
<tr>
<th><strong>Client-Server</strong></th>
<th><strong>BitTorrent</strong></th>
</tr>
</thead>
<tbody><tr>
<td>中心化</td>
<td>去中心化</td>
</tr>
<tr>
<td>热门资源限制服务器性能</td>
<td>热门资源无性能限制</td>
</tr>
<tr>
<td>设备费用昂贵；资源热门程度决定了设备开销</td>
<td>设备开销不会随着资源热门而变化</td>
</tr>
</tbody></table>
<p>我们知道，BT下载是通过对等网实现的(peer-to-peer，P2P)；而在对等网络中，每个对等点都连接到网络中的每个其他对等点。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt2.svg"><img src="/:/125e950f83004defa52f5eb4fddd4424" alt="bt2.svg"></a></p>
<p>而半中心化的对等网络是：拥有一个或多个权限比其他大多数对等点更高的对等网络。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt3.svg"><img src="/:/e2c6db0497f14929bcf95f6a10dd6893" alt="bt3.svg"></a></p>
<h3 id="BitTorrent概述"><a href="#BitTorrent概述" class="headerlink" title="BitTorrent概述"></a><a href="#BitTorrent%E6%A6%82%E8%BF%B0" title="BitTorrent概述"></a>BitTorrent概述</h3><p>BitTorrent是一种共享文件的方式，通常用于大型文件。 BitTorrent是单个下载源共享文件（例如服务器）的一种替代方法。并且，BitTorrent可以有效地在较低带宽上工作。</p>
<p>BitTorrent客户端的第一版没有搜索引擎，也没有对等交换，想要上传文件的用户必须创建一个小的torrent描述符文件(<em>torrent descriptor file</em>)，然后将其上传到torrent索引站点。</p>
<p>当用户想要共享文件时，他们会将文件做成种子文件(seed their file)。该用户称为做种人(<em>seeder</em>)。他们将种子文件上传到交换站点(exchange)（我们稍后再讨论）。想要下载该文件的任何人都将首先下载此种子描述符。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt4.png"><img src="/:/9230cafd9fec4d6d9063fc1b579b2bd8" alt="bt4.png"></a></p>
<p>我们称呼那些下载用户为对等点(peers)。他们的BT客户端将连接到BT tracker服务器（稍后讨论），并且tracker将向对等点发送种子集群中其他种子和对等点的IP地址列表。此处的集群指的是与某种子相关的所有PC。</p>
<p>种子文件描述符中包含了我们正在下载的文件的tracker服务器和元数据的列表。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt5.png"><img src="/:/d1355d5abeef4867938112ae753cd7e2" alt="bt5.png"></a></p>
<p>对等点将会连接到种子对应的IP并下载文件的<strong>一个部分</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt6.png"><img src="/:/1f161e5222014aa99ddc742d04292adf" alt="bt6.png"></a></p>
<p>当对等点完成下载(一个文件分片)后，它们可以充当种子提供者。虽然，可以在下载种子的同时充当种子提供者（这是很常见的）。</p>
<p>种子被文件共享给对等点后，该对等点也将充当种子提供者。在BitTorrent中，多个人可以上传相同的文件，而对于CS来说，只有一个服务器可以上传文件。</p>
<p>BitTorrent会将文件切分成称为pieces的块，每个块都有固定的大小(最后一个文件除外)。但是切分的块大小是不固定的，有时是256KB，有时是1MB。当每个对等点收到一个块时，它们就成为这个文件块的其他对等点的种子(become a seed of that piece for other peers)。</p>
<p>在使用BitTorrent时，我们没有使用单一的下载源。因此，我们可能会从国内下载一些文件块，然后从国外下载一些国内没有的文件块。</p>
<p>协议会对文件块进行哈希(<a target="_blank" rel="noopener" href="https://skerritt.blog/hash-functions/">hashes</a>)处理，以确保种子对应的原始文件没有被篡改。然后将哈希值存储在torrent描述符中，并上传至tracker服务器。</p>
<p>这就是BT下载的基本概述了。接下来我会深入讲解BT下载的底层原理。并回答下列问题：</p>
<ul>
<li>如果对等点仅下载文件但从不上传，会发生什么？</li>
<li>我们从哪里下载，又在给谁上传？</li>
<li>什么是磁力链接( magnet link )？</li>
<li>什么是种子描述符( torrent descriptor )？</li>
<li>哈希使用到的是什么算法？</li>
<li>BT是如何选择下载的文件块的？</li>
<li>……</li>
</ul>
<h3 id="种子描述文件中有什么？"><a href="#种子描述文件中有什么？" class="headerlink" title="种子描述文件中有什么？"></a><a href="#%E7%A7%8D%E5%AD%90%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F" title="种子描述文件中有什么？"></a>种子描述文件中有什么？</h3><p>种子描述文件是一个字典(dictionary)（或被称为哈希表，HashMap）文件。</p>
<p>文件被定义为：</p>
<h4 id="①-声明-Announce"><a href="#①-声明-Announce" class="headerlink" title="① 声明(Announce)"></a><a href="#%E2%91%A0-%E5%A3%B0%E6%98%8E-Announce" title="① 声明(Announce)"></a><strong>① 声明(Announce)</strong></h4><p>这个字段中包括了tracker服务器的URL。还记得我们之前需要连接tracker服务器来查找使用同一文件的其他对等点吗？我们通过使用torrent描述文件中的announce key来找到tracker服务器。</p>
<hr>
<h4 id="②-信息-Info"><a href="#②-信息-Info" class="headerlink" title="② 信息(Info)"></a><a href="#%E2%91%A1-%E4%BF%A1%E6%81%AF-Info" title="② 信息(Info)"></a><strong>② 信息(Info)</strong></h4><p>这个字段映射到了另一个词典列表，而字典列表中的元素个数取决于该种子共享的文件个数。字典列表中的key包括：</p>
<ul>
<li>**Files(Info中的子字典，是一个列表)**：Files仅在共享多个文件时存在，Files中的每个字典对应一个文件。这些列表中的每一个字典都有2个key：<ul>
<li><strong>Length：</strong>文件大小（以字节为单位）。</li>
<li><strong>Path：</strong>对应于子目录名称的字符串列表，最后一个是实际文件名。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="③-共享文件大小-Length"><a href="#③-共享文件大小-Length" class="headerlink" title="③ 共享文件大小(Length)"></a><a href="#%E2%91%A2-%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F-Length" title="③ 共享文件大小(Length)"></a><strong>③ 共享文件大小(Length)</strong></h4><p>文件大小（以字节为单位）（仅在共享一个文件时）</p>
<hr>
<h4 id="④-文件名-Name"><a href="#④-文件名-Name" class="headerlink" title="④ 文件名(Name)"></a><a href="#%E2%91%A3-%E6%96%87%E4%BB%B6%E5%90%8D-Name" title="④ 文件名(Name)"></a><strong>④ 文件名(Name)</strong></h4><p>建议的文件名。或建议的目录名称。</p>
<hr>
<h4 id="⑤-文件块大小-Pieces-Length"><a href="#⑤-文件块大小-Pieces-Length" class="headerlink" title="⑤ 文件块大小(Pieces Length)"></a><a href="#%E2%91%A4-%E6%96%87%E4%BB%B6%E5%9D%97%E5%A4%A7%E5%B0%8F-Pieces-Length" title="⑤ 文件块大小(Pieces Length)"></a><strong>⑤ 文件块大小(Pieces Length)</strong></h4><p>单个文件块字节数。</p>
<p>文件块大小必须是2的幂，并且至少为16Kb；</p>
<blockquote>
<p>注： 2^8Kb &#x3D; 256Kb &#x3D; 262144b</p>
</blockquote>
<hr>
<h4 id="⑥-文件块-Pieces"><a href="#⑥-文件块-Pieces" class="headerlink" title="⑥ 文件块(Pieces)"></a><a href="#%E2%91%A5-%E6%96%87%E4%BB%B6%E5%9D%97-Pieces" title="⑥ 文件块(Pieces)"></a><strong>⑥ 文件块(Pieces)</strong></h4><p>一个存放文件块哈希值的列表：我们将文件数据分成几块。分别计算这些块的哈希值，并将其存储在列表中。</p>
<p>BitTorrent使用SHA-1算法，而SHA-1返回160位的哈希值，所以所有文件块的哈希值都将是一个长度为20个字节的倍数的字符串。</p>
<p>如果单个种子文件中包含了多个文件，则将会按照文件在文件目录中出现的顺序串联起来，形成文件块。</p>
<p>种子中的所有文件块均为完整块长度，只有单个文件中的最后一个块可能较短。</p>
<p>现在，我能猜到你在想什么。</p>
<blockquote>
<p>这都0202年了，还在用SHA-1？</p>
</blockquote>
<p>我也同意，并且现在BT下载的哈希算法已经慢慢迁移到了SHA265：<a target="_blank" rel="noopener" href="http://bittorrent.org/beps/bep_0052.html">BitTorrent is moving from SHA-1 to SHA256.</a></p>
<p>如果你对于种子描述文件的结构还是很困惑也不用担心！我设计了下面这个JSON文件，描述了种子文件的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Announce&quot;: &quot;url of tracker&quot;,</span><br><span class="line">    &quot;Info&quot;: &#123;</span><br><span class="line">        &quot;Files&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Length&quot;: 16,</span><br><span class="line">                &quot;path&quot;: &quot;/folder/to/path&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;length&quot;: 193,</span><br><span class="line">                &quot;path&quot;: &quot;/another/folder&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;length&quot;: 192,</span><br><span class="line">    &quot;name&quot;:&quot; Ubuntu.iso&quot;,</span><br><span class="line">    &quot;Pieces length&quot;: 262144,</span><br><span class="line">    &quot;Pieces&quot;: [AAF4C61DDCC5E8A2DABEDE0F3B482CD9AEA9434D, CFEA2496442C091FDDD1BA215D62A69EC34E94D0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BT下载中的块选择算法-Piece-Selection-Algorithm"><a href="#BT下载中的块选择算法-Piece-Selection-Algorithm" class="headerlink" title="BT下载中的块选择算法(Piece Selection Algorithm)"></a><a href="#BT%E4%B8%8B%E8%BD%BD%E4%B8%AD%E7%9A%84%E5%9D%97%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95-Piece-Selection-Algorithm" title="BT下载中的块选择算法(Piece Selection Algorithm)"></a>BT下载中的块选择算法(Piece Selection Algorithm)</h3><p>BitTorrent下载中最大的问题之一是“我应该选择下载哪些文件？”</p>
<p>对于传统的CS模型，我们将下载整个文件；但是现在，我们需要选择要下载的部分。</p>
<p>选择一个好的顺序来下载片断，对提高性能非常重要。一个差的文件块选择算法可能导致所有的文件块都处于下载中，或者另一种情况，没有任何一个片段会被上载给其它对等点。</p>
<p>在BT中块选择的算法思想就是：下载其他人没有的文件块，即稀有文件块。通过下载稀有的文件块，我们可以通过上传该块来减少稀有文件块的稀有度。</p>
<h3 id="什么是子块-Sub-Pieces-和块选择算法-Piece-Selection-Algorithm"><a href="#什么是子块-Sub-Pieces-和块选择算法-Piece-Selection-Algorithm" class="headerlink" title="什么是子块(Sub-Pieces)和块选择算法(Piece Selection Algorithm)"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%90%E5%9D%97-Sub-Pieces-%E5%92%8C%E5%9D%97%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95-Piece-Selection-Algorithm" title="什么是子块(Sub-Pieces)和块选择算法(Piece Selection Algorithm)"></a>什么是子块(Sub-Pieces)和块选择算法(Piece Selection Algorithm)</h3><p>BitTorrent使用TCP，一种用于数据包的传输协议。TCP具有一种被称为慢启动(<a target="_blank" rel="noopener" href="https://www.isi.edu/nsnam/DIRECTED_RESEARCH/DR_HYUNAH/D-Research/slow-start-tcp.html">slow start</a>)的机制。</p>
<p>慢启动是一种平衡TCP网络连接速度的机制。它会逐步增加传输的数据量，直到找到网络的最大承载能力，如下图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt7.svg"><img width="899" height="509" src=":/ef98235883f34b1d91099850e56e12ad"/></a></p>
<p>其中，cwdn代表拥塞窗口。</p>
<p>TCP之所以这样做，是因为：如果我们一次发送16个连接请求，可能会导致服务器无法使用该流量，最终网络发生拥塞。所有，如果我们不定期发送数据，则TCP可能会以比正常速度慢的速度限制网络连接。</p>
<p>BitTorrent协议会保证将数据细分为更多的子数据块来发送数据，每个子块的大小约为16KB。一个块的大小不是固定的，但大约为1MB。</p>
<p>同时BitTorrent协议始终有一定数量的请求连接（五个），用于子块管道(sub-piece pipe-lined)。当下载一个新的子块时，客户端将发送一个新请求，从而有助于加快速度。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt8.svg"><img width="899" height="364" src=":/6db5ad85d5854d2187601d3d3730aaae"/></a></p>
<p>同时子块可以被其他的对等点下载；</p>
<p>对于块选择算法来说，有两大原则：</p>
<ul>
<li>严格规则(Strict Policy)；</li>
<li>稀有度优先(Rarest First)；</li>
</ul>
<h4 id="①-严格优先级-Strict-Policy"><a href="#①-严格优先级-Strict-Policy" class="headerlink" title="① 严格优先级(Strict Policy)"></a><a href="#%E2%91%A0-%E4%B8%A5%E6%A0%BC%E4%BC%98%E5%85%88%E7%BA%A7-Strict-Policy" title="① 严格优先级(Strict Policy)"></a><strong>① 严格优先级(Strict Policy)</strong></h4><p>一旦BitTorrent客户端发起了一个文件块的子块的请求，则该文件块的任何剩余子块都将先于其他文件块的任何子块被请求。 这样，可以尽可能快的获得一个完整的片断。</p>
<blockquote>
<p>Once the BitTorrent client requests a sub-piece of a piece, any remaining sub-pieces of that piece are requested before any sub-pieces from other pieces.</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt9.svg"><img width="899" height="539" src=":/1358c4ac10aa48468d80af1578e9b704"/></a></p>
<p>在此图中，就是需要先下载该文件块的其他的所有子块，而不是开始下载另一个文件块。</p>
<hr>
<h4 id="②-稀有度优先-Rarest-First"><a href="#②-稀有度优先-Rarest-First" class="headerlink" title="② 稀有度优先(Rarest First)"></a><a href="#%E2%91%A1-%E7%A8%80%E6%9C%89%E5%BA%A6%E4%BC%98%E5%85%88-Rarest-First" title="② 稀有度优先(Rarest First)"></a><strong>② 稀有度优先(Rarest First)</strong></h4><p>BitTorrent下载的核心策略就是选择最稀有的文件块(pick the rarest first)，所以我们要下载其他对等点拥有的最少的文件块。</p>
<p>这样我们就可以将那些稀有的文件块变得不再稀有(‘un-rare’)。因为，如果只有一个对等点有这个文件块并且他下线了，则将没有人能够获得完整文件。</p>
<p>这个原则带来了很多好处：</p>
<p><strong>Ⅰ。提高种子可靠性(Growing the seed)</strong></p>
<p>首先，选择最稀有的文件块确保了我们仅从种子中下载新的文件块。</p>
<p>例如：稀有种子在一开始会成为下载瓶颈，仅有单个对等点含有该文件快。</p>
<p>而一个下载者可以看到他的对等点拥有哪些文件块，从而最稀有优先原则将使我们从种子中获取那些尚未由其他对等点上传的文件块。</p>
<p>让我们将其可视化：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt10.svg"><img width="899" height="436" src=":/6f32d361bf9f40279f664453e0e3ed35"/></a></p>
<p>虽然图中没有画出，但是各个对等点之间也是是相互连接的。</p>
<p>每个指向子文件块的箭头代表该对等点已下载对应内容。所以可以看到，我们已经下载了除了种子没有其他人拥有的子块，这意味着此子块很稀有。</p>
<p>同时可以看到，我们的上传速度高于种子的上传速度，因此所有其他的对等点都希望从我们这里下载。此外，他们也希望首先下载到最稀有的子块，因为我们是最稀有子块的2位持有者之一。</p>
<p>当每个对等点都从我们这里下载时，我们也可以从他们那里更快地下载。这就是针锋相对算法(“tit-for-tat algorithm”)（稍后讨论）。</p>
<p><strong>Ⅱ。提高下载速度(Increased download speed)</strong></p>
<p>持有文件块的对等点越多，下载速度就越快。这是因为我们可以从其他对等点那里下载子块。</p>
<p><strong>Ⅲ。上传支持(Enable uploading)</strong></p>
<p>稀有文件块是其他对等点最想要的，而获得稀有文件块也意味着对等点会对从我们的上传感兴趣。稍后我们将看到，我们上传的越多，我们可以下载的也越多。</p>
<p><strong>Ⅳ。最常见的块在最后(Most common last)</strong></p>
<p>将最常见的文件块留在下载末尾是明智的。由于许多对等点都拥有此文件块，因此能够下载它们的可能性比稀有文件块大得多。</p>
<p><strong>Ⅴ。避免稀有块丢失(Prevent rarest piece missing)</strong></p>
<p>当种子提供者断开连接时，稀有度优先原则保证了文件的所有部分都会分配到其余对等点。</p>
<hr>
<h4 id="③-随机开始下载的第一个文件块-Random-First-Piece"><a href="#③-随机开始下载的第一个文件块-Random-First-Piece" class="headerlink" title="③ 随机开始下载的第一个文件块(Random First Piece)"></a><a href="#%E2%91%A2-%E9%9A%8F%E6%9C%BA%E5%BC%80%E5%A7%8B%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%9D%97-Random-First-Piece" title="③ 随机开始下载的第一个文件块(Random First Piece)"></a><strong>③ 随机开始下载的第一个文件块(Random First Piece)</strong></h4><p>当我们刚下载时，我们还没有任何可以上传的内容，所以我们需要很快的获取到第一块。而此时，稀有度优先原则是很慢的，所以BT协议会随机选择一块开始下载；直到第一块下载并检查完成。此后，“稀有优先”策略才会开始。</p>
<hr>
<h4 id="④-残局模式-Endgame-Mode"><a href="#④-残局模式-Endgame-Mode" class="headerlink" title="④ 残局模式(Endgame Mode)"></a><a href="#%E2%91%A3-%E6%AE%8B%E5%B1%80%E6%A8%A1%E5%BC%8F-Endgame-Mode" title="④ 残局模式(Endgame Mode)"></a><strong>④ 残局模式(Endgame Mode)</strong></h4><p>当(某个块)下载接近完成，但是还需要等待传输速率较慢的对等点上传时，可能会造成下载延迟，从而降低了传输效率。为了防止这种情况，其余的子块是从当前集群中的所有对等点中请求的。</p>
<p>还记得严格原则(Strict-Policy)吗？BT下载时，总是有数个待处理的子块请求：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt11.svg"><img width="899" height="342" src=":/e32ebebaf91d4d58bb50e7c60a57c311"/></a></p>
<p>假设我们正在从2个对等点下载，而还有另外1个我们未从中下载的对等点。</p>
<p>当请求的对等点缺少相应的子块时，BT协议会将请求广播给集群中所有对等点，而这有助于我们获取文件的最后一块。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt12.svg"><img width="899" height="219" src=":/b4e8dd5b9fc149d8ae15d2a98332bc9a"/></a></p>
<p>如果对等点缺少子块，他们会将消息发送回我们。</p>
<p>一旦一个子块到达，我们将发送一条取消消息，告诉其他对等方忽略我们的请求。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt13.svg"><img width="899" height="255" src=":/096a3b94a1ad45f88e042cc4828b71de"/></a></p>
<h3 id="使用“以牙还牙”算法分配资源"><a href="#使用“以牙还牙”算法分配资源" class="headerlink" title="使用“以牙还牙”算法分配资源"></a><a href="#%E4%BD%BF%E7%94%A8%E2%80%9C%E4%BB%A5%E7%89%99%E8%BF%98%E7%89%99%E2%80%9D%E7%AE%97%E6%B3%95%E5%88%86%E9%85%8D%E8%B5%84%E6%BA%90" title="使用“以牙还牙”算法分配资源"></a>使用“以牙还牙”算法分配资源</h3><p><strong>以牙还牙</strong>（英语：tit-for-tat）是一个用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%9A%E5%BC%88%E8%AB%96">博弈论</a>的重复<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83">囚徒困境</a>（reiterated prisoner’s dilemma）非常有效的策略。这策略最先由数学家<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E9%98%BF%E7%B4%8D%E6%89%98%C2%B7%E6%8B%89%E6%99%AE%E4%BC%AF%E7%89%B9&action=edit&redlink=1">阿纳托·拉普伯特</a>（Anatol Rapoport）提出，并在密歇根大学社会学家<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BE%85%E4%BC%AF%E7%89%B9%C2%B7%E9%98%BF%E5%85%8B%E5%A1%9E%E7%88%BE%E7%BE%85">罗伯特·阿克塞尔罗</a>（Robert Axelrod）有关囚徒困境的研究中击败其他方法，脱颖而出，成为解决囚徒困境的最佳策略。</p>
<p>这一策略有两个步骤：</p>
<ol>
<li>第一个回合选择合作；</li>
<li>下一回合是否选合作要看上一回对方是否合作，若对方上一回背叛，此回合我亦背叛；若对方上一回合作，此回合继续合作；</li>
</ol>
<p>“以牙还牙”策略有四个特点：</p>
<ol>
<li>友善：“以牙还牙”者开始一定采取合作态度，不会背叛对方；</li>
<li>报复性：遭到对方背叛，“以牙还牙”者一定会还击报复；</li>
<li>宽恕：当对方停止背叛，“以牙还牙”者会原谅对方，继续合作；</li>
<li>不羡慕对手：“以牙还牙”者个人永远不会得到最大利益，整个策略以全体的最大利益为依归；</li>
</ol>
<h3 id="阻塞算法-The-choking-Algorithm"><a href="#阻塞算法-The-choking-Algorithm" class="headerlink" title="阻塞算法(The choking Algorithm)"></a><a href="#%E9%98%BB%E5%A1%9E%E7%AE%97%E6%B3%95-The-choking-Algorithm" title="阻塞算法(The choking Algorithm)"></a>阻塞算法(The choking Algorithm)</h3><p>当一个对等点收到另一个对等点的请求时，它可以选择拒绝向该请求发送文件块(但我们仍然可以从他们那里下载)。如果发生这种情况，则称对方被“choked”了。</p>
<p>当对等点合作时，他们上传文件；而当对等点不合作时，他们“阻塞”了与其他对等点的连接；而原则就是上传文件块给那些已上传给过我们的对等点；</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt14.svg"><img width="899" height="244" src=":/ab299c35f70544dd8eca70fbd423314a"/></a></p>
<p>而阻塞算法最终理想的结果就是：同时进行多个双向连接并最终达到帕累托最优(Pareto Efficiency)</p>
<blockquote>
<p>如果没有其他分配方式能够使某个人的状况更好也没有一个人的状况更差，那么我们认为分配是帕累托最优的。</p>
</blockquote>
<p>因此，最大的问题是，如何确定哪些对等点会被阻塞而哪些不会被阻塞呢？</p>
<p>在默认情况下，客户端将仅保留默认的同时上传数量(max_uploads，max_uploads的默认值为4)，而所有对该客户端的其他请求都将标记为“choked”。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt15.png"><img src="/:/976a7793e07746edb3d0e263a85340a5" alt="bt15.png"></a></p>
<p>如上图中，种子阻塞了与对等点的连接，因为它已达到其最大上传数量。此后，对等点将保持阻塞状态，直到发送了取消阻塞消息为止。</p>
<p>而当前的下载速率决定了要取消阻塞对等点。这里以每10秒计算一次最近20秒的下载速率平均值来决定。因为BT下载使用的是TCP协议（慢启动），因此快速阻塞和取消阻塞的效率并不高( 频繁的阻塞和疏通peers造成资源浪费)。</p>
<p>所以，根据这个原则：如果我们的上传速率很高，则会有更多的对等点允许我们从他们那里下载。即，**如果我们是优秀的上传者，我们可以获得更高的下载率(This means that we can get a higher download rate if we are a good uploader)**。这是BitTorrent协议的最重要功能。</p>
<blockquote>
<p>文件下载片断选择是为了提高系统的总效率，而阻塞算法是为了提高个人用户的公平性和效率：作为取自于用户并用之于用户的分布式系统，整个系统的效率和个人用户的公平性至关重要！</p>
<p>BitTorrent的片断下载策略保证了最大的下载效率和稳健的完整性，而阻塞算法鼓励个人用户上传。BitTorrent的阻塞算法并不记录历史，也就是对用户以前的上传、下载行为没有记录。</p>
<p>而有些最近版本的BitTorrent已经能对帐户的上传、下载信息做出统计，然后转化为积分，但积分还没有和用户的下载优先级绑定，而且积分也只是简单的统计上传流量，上传的内容和上传的目标用户也没有分析，简单的积分策略并不能应对五花八门Spamming技术，积分算法应该是上传和下载流量的比数，且积分增加速度随着上传的不同目标用户和不同上传内容数量的增加而增加！</p>
</blockquote>
<p>这个协议禁止了许多“搭便车的人(free riders)”，即：只下载但不上传的对等点。这是为了使整个对等网络高效，所以所有对等都需要为网络做出贡献；</p>
<blockquote>
<p>除此之外：</p>
<p>对方被阻塞的另一个常见例子是，对等点不需要下载文件块。</p>
</blockquote>
<p>同时，为了确保对等点之间的公平，有一个适当的机制确保了各对等点可以轮流下载其他对等点的文件块，这个机制被称为：“开放检测”(optimistic unchoking)。</p>
<h3 id="开放检测-optimistic-unchoking"><a href="#开放检测-optimistic-unchoking" class="headerlink" title="开放检测(optimistic unchoking)"></a><a href="#%E5%BC%80%E6%94%BE%E6%A3%80%E6%B5%8B-optimistic-unchoking" title="开放检测(optimistic unchoking)"></a>开放检测(optimistic unchoking)</h3><p>如果只是简单的为提供最好的下载速率的对等点们提供上传速度，那么就没有办法来发现那些空闲的连接是否比当前正使用的连接更好。</p>
<p>为了解决这个问题，在任何时候，每个对等点都拥有一个被称为“optimistic unchoking”的连接，这个连接总是保持畅通状态，而不论它的下载速率是怎样的。</p>
<p>每隔30秒，会重新计算一次哪个连接应该是“optimistic unchoking”。如果此“optimistic unchoking”连接比当前连接的某个非阻塞的连接下载速率要快，那么这个“optimistic unchoking”将会取代那个连接；</p>
<blockquote>
<p>因为即使是TPC协议，30秒足以让上传能力达到最大，下载能力也相应的达到最大。</p>
</blockquote>
<p>“optimistic unchoking”连接是随机选择的。同时，这也允许了那些不上传并仅下载文件的对等设备下载文件，即使他们拒绝合作（尽管它们将以慢得多的速度下载）</p>
<h3 id="反对歧视-Anti-snubbing"><a href="#反对歧视-Anti-snubbing" class="headerlink" title="反对歧视(Anti-snubbing)"></a><a href="#%E5%8F%8D%E5%AF%B9%E6%AD%A7%E8%A7%86-Anti-snubbing" title="反对歧视(Anti-snubbing)"></a>反对歧视(Anti-snubbing)</h3><p>某些情况下，一个对等点可能会被它所有的对等点都阻塞了，这种情况下，它将会保持较低的下载速率直到通过“optimistic unchoking”找到了更好peers。</p>
<p>为了减轻这种问题，如果某个对等点在60秒钟内没有收到来自特定对等点的任何文件，则将认为它已被对方对等点 “怠慢”了，于是不再为对方提供上传，除非对方是“optimistic unchoking”。如果这种情况频繁发生，会导致多于一个的并发的“optimistic unchoking”。</p>
<h3 id="仅上传对等点-Upload-Only"><a href="#仅上传对等点-Upload-Only" class="headerlink" title="仅上传对等点(Upload Only)"></a><a href="#%E4%BB%85%E4%B8%8A%E4%BC%A0%E5%AF%B9%E7%AD%89%E7%82%B9-Upload-Only" title="仅上传对等点(Upload Only)"></a>仅上传对等点(Upload Only)</h3><p>我们看到，使用在BitTorrent中实现的阻塞算法，我们更喜欢对我们友好的对等点。如果我可以从他们那里快速下载，我们也允许他们从我那里快速上传。</p>
<p>但是如果某个对等点完成了下载，它就无法使用此阻塞算法判断要取消阻塞哪些对等点；</p>
<p>此时，将使用新的阻塞算法：不再通过下载速率（因为下载速率已经为0了）来决定为哪些对等点提供上载，而是优先选择那些从它这里得到更好的上载速率的对等点。这样做的理由是可以尽可能的利用上载带宽，从而确保文件块上传速度更快，并且复制速度更快。</p>
<h3 id="什么是跟踪器-Tracker-？"><a href="#什么是跟踪器-Tracker-？" class="headerlink" title="什么是跟踪器(Tracker)？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%9F%E8%B8%AA%E5%99%A8-Tracker-%EF%BC%9F" title="什么是跟踪器(Tracker)？"></a>什么是跟踪器(Tracker)？</h3><p>Tracker是一种特殊类型的服务器，可帮助对等点之间进行通信。</p>
<p>BitTorrent中的通信很重要。想一下，我们是如何了解其他对等点的存在的？</p>
<p>Tracker知道文件的拥有者以及拥有量。</p>
<p>但是，当对等下载开始后，就无需Tracker即可继续通信。</p>
<p>实际上，自从为无追踪程序的种子创建分布式哈希表(distributed hash table，DHT)方法以来，BitTorrent Tracker在很大程度上是多余的。</p>
<h4 id="公共Tracker"><a href="#公共Tracker" class="headerlink" title="公共Tracker"></a><a href="#%E5%85%AC%E5%85%B1Tracker" title="公共Tracker"></a>公共Tracker</h4><p>公共Tracker是任何人都可以使用的Tracker。</p>
<p>海盗湾（Pirate Bay）是最受欢迎的公共Tracker之一，直到2009年其禁用了Tracker，而选择了磁链（即将讨论）。</p>
<blockquote>
<p>引自： <a target="_blank" rel="noopener" href="https://arstechnica.com/tech-policy/2009/11/pirate-bay-kills-its-own-bittorrent-tracker/">The Pirate Bay operated one of the most popular public trackers until disabling it in 2009</a></p>
</blockquote>
<hr>
<h4 id="私有Tracker"><a href="#私有Tracker" class="headerlink" title="私有Tracker"></a><a href="#%E7%A7%81%E6%9C%89Tracker" title="私有Tracker"></a>私有Tracker</h4><p>私人Tracker是私人的，它们通过要求用户在网站上注册来限制使用。</p>
<p>控制注册的方法通常是邀请系统。要使用此类Tracker，我们需要被邀请。</p>
<hr>
<h4 id="多Tracker种子"><a href="#多Tracker种子" class="headerlink" title="多Tracker种子"></a><a href="#%E5%A4%9ATracker%E7%A7%8D%E5%AD%90" title="多Tracker种子"></a>多Tracker种子</h4><p>多Tracker种子是在一个种子文件中包含多个Tracker。如果一个Tracker发生故障，这将提供冗余，其他Tracker可以继续维护种子文件创建的集群。</p>
<p>但是，使用此配置，单个种子可能有多个未互相连接的集群：一些用户可以连接到一个特定的Tracker，而无法连接到另一个，这很糟糕！因为，这会创建很多不相交的集群，这会阻碍torrent传输其描述的文件的效率。</p>
<h3 id="磁力链接-无Tracker种子-Magnet-Links-Trackerless-Torrents"><a href="#磁力链接-无Tracker种子-Magnet-Links-Trackerless-Torrents" class="headerlink" title="磁力链接 - 无Tracker种子(Magnet Links - Trackerless Torrents)"></a><a href="#%E7%A3%81%E5%8A%9B%E9%93%BE%E6%8E%A5-%E6%97%A0Tracker%E7%A7%8D%E5%AD%90-Magnet-Links-Trackerless-Torrents" title="磁力链接 - 无Tracker种子(Magnet Links - Trackerless Torrents)"></a>磁力链接 - 无Tracker种子(Magnet Links - Trackerless Torrents)</h3><p>之前，我谈到了Pirate Bay停用了Tracker并开始使用无tracker的种子。</p>
<p>当我们下载种子时，我们会得到该种子的哈希值。要在没有tracker的情况下下载种子，我们需要找到其他也在下载种子的对等点。为此，我们需要使用分布式哈希表(distributed hash table，DHT)。</p>
<p>下面让我们探索分布式哈希表。</p>
<h3 id="分布式哈希表-Distributed-Hash-Tables-和Kademlia协议"><a href="#分布式哈希表-Distributed-Hash-Tables-和Kademlia协议" class="headerlink" title="分布式哈希表(Distributed Hash Tables)和Kademlia协议"></a><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8-Distributed-Hash-Tables-%E5%92%8CKademlia%E5%8D%8F%E8%AE%AE" title="分布式哈希表(Distributed Hash Tables)和Kademlia协议"></a>分布式哈希表(Distributed Hash Tables)和Kademlia协议</h3><p>分布式哈希表是一种分布式存储方法。这种网络不需要中心节点服务器，而是每个客户端负责一个小范围的路由，并负责存储一小部分资料，从而实现整个DHT网络的定位和存储。和中心节点服务器不同，DHT网络中的各节点并不需要维护整个网络的信息，而是只在节点中存储其临近的后继节点信息，大幅减少了带宽的占用和资源的消耗。DHT网络还在与关键字最接近的节点上复制备份冗余信息，避免了单一节点失效问题。</p>
<p>BitTorrent的DHT网络是使用Kademlia协议（以下简称Kad），一个点对点（P2P）的&lt; 键, 值&gt;元组存储和查询系统。</p>
<blockquote>
<p>Kad是美国纽约大学的PetarP. Maymounkov和David Mazieres.在2002年发布的一项研究结果：《Kademlia: A peerto -peer information system based on the XOR metric》。</p>
<p>Kademlia拥有许多的令人惊喜的特点，这些特点是任何以前的P2P系统所无法同时提供的。它减少了节点必须发送的用来相互认识的配置消息的数量。在做键查询的同时, 配置消息将会被自动传播。节点拥有足够的知识和灵活性来通过低时延路径发送查询请求。</p>
<p>Kademlia使用平行的、异步的查询请求来避免节点失效所带来的超时时延。通过节点记录相互的存在的算法可以抵抗某些基本的拒绝服务（DoS）攻击。</p>
</blockquote>
<p>分布式哈希表为我们提供了类似于字典的接口，但是节点分布在整个网络中。DHT的核心在于：通过散列特定的key可以找到存储对应的特定key的节点。</p>
<p>实际上，这意味着，每个对等点都将成为一个微型tracker(mini-tracker)。</p>
<p>每个节点（实现DHT协议的客户端&#x2F;服务器）都有一个唯一的标识符，称为“节点ID”(Node Id)。我们从与BitTorrent信息哈希相同的160位空间中随机选择节点ID。</p>
<p>信息哈希(Infohashes)是以下内容的SHA-1哈希：</p>
<ul>
<li>ITEM：文件大小和路径（带文件名的路径）；</li>
<li>Name：被索引时的名称；</li>
<li>Piece length：单块文件大小；</li>
<li>Pieces：该种子文件的每一块的SHA-1哈希值；</li>
<li>Private：限制访问标记；</li>
</ul>
<blockquote>
<p>关于Infohashes：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28348678/what-exactly-is-the-info-hash-in-a-torrent-file">What exactly is the info_Hash in a torrent file</a></p>
</blockquote>
<p>我们使用距离度量(distance metric)来比较两个节点ID或 一个节点ID和一个infohash的“接近度”(closeness)；</p>
<p>节点必须具有包含其他几个节点的联系信息的路由表。从而，节点在DHT中知道彼此。他们知道许多节点的id与他们自己的很接近，但也有很少节点的id与他们很远。</p>
<p>距离度量是XOR(异或)，被解释为一个整数：</p>
<p>distance(A,B)&#x3D;|A⊕B|</p>
<p>数值越小越接近。</p>
<p>当一个节点想要为一个种子找到对等节点时，他们使用distance metric来比较种子的infohash和路由表中节点的ID，或者一个节点的ID和另一个节点的ID。</p>
<p>然后，他们联系路由表中最靠近infohash的节点，并向他们请求下载种子的对等点的联系信息。</p>
<p>如果这个被联系的节点知道种子的对等点，他们返回对等点的联系信息响应。否则，被联系的节点必须用他的路由表中最靠近infohash的节点来响应请求种子的信息。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt16.svg"><img width="899" height="317" src=":/953a2035c2404f41b92b546b1ebd5fdd"/></a></p>
<p>原始节点查询更接近infohash的节点，直到找不到更接近的节点为止。在节点完成搜索后，客户端将自己的对等联系信息(peer contact information)插入到与种子信息最接近的id响应节点上。在未来，其他节点可以很容易地找到我们（原始节点）。</p>
<p>对等点查询的返回值包括一个被称为“token”的不透明值(opaque value)。一个节点要宣布它的控制对等点正在下载一个种子，它必须在最近的一次对等查询中展示从同一被查询的对等点接收到的令牌。</p>
<p>当一个节点试图“发布(announce)”一个种子时，被查询的节点会根据查询节点的IP地址检查令牌。这是为了防止恶意主机为种子注册其他主机。(This is to prevent malicious hosts from signing up other hosts for torrents)</p>
<p>查询节点也会将一个令牌返回到他接收令牌的同一个节点。在令牌被分发后，我们必须在一个合理的时间内接受令牌(We must accept tokens for a reasonable amount of time after they have been distributed.)。</p>
<p>BitTorrent对于这个令牌的实现是：使用IP地址和每5分钟更改一次的密码的SHA-1哈希，并且接受最多10分钟以前的令牌。</p>
<h3 id="路由表-Routing-Table"><a href="#路由表-Routing-Table" class="headerlink" title="路由表(Routing Table)"></a><a href="#%E8%B7%AF%E7%94%B1%E8%A1%A8-Routing-Table" title="路由表(Routing Table)"></a>路由表(Routing Table)</h3><p>每个节点都会维护一个已知的好节点(known good nodes)的路由表。我们在DHT中使用路由表起始点(starting points)进行查询，同时我们从路由表返回节点以响应来自其他节点的查询。</p>
<p>并非我们了解的所有节点都是平等的。有些是“好”的，有些则不是。许多使用DHT的节点可以发送查询和接收响应，但是不能响应来自其他节点的查询。并且每个节点的路由表必须只包含已知的好节点(good node)：</p>
<p>一个好的节点是一个节点在过去15分钟内响应了我们的一个查询。如果一个节点在过去15分钟内响应了我们的查询并向我们发送了一个查询，那么它也是一个好节点。</p>
<p>一个节点在15分钟不活动之后，节点就会变得可疑(questionable)。</p>
<p>而当节点无法响应一个或者多个连续的查询时(fail to respond to multiple queries in a row)，它们就会变得糟糕(bad)。</p>
<p>并且我们在查询时良好的节点会优先于状态未知的节点。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/jasonkayzk/blog_static@master/images/bt17.svg"><img width="899" height="772" src=":/d3304c4403404c30ae41a445e9666085"/></a></p>
<p>一个路由表覆盖了从0到2^160的整个节点ID空间。我们将路由表细分为“桶(buckets)”，每个桶覆盖部分空间。</p>
<p>一个空表有一个bucket，其ID空间范围为min&#x3D;0, max&#x3D;2^160。</p>
<p>空表只有一个bucket，因此任何节点都必须包含在其中。在一个桶变“满(full)*”之前，每个桶只能容纳K个节点，目前是8个。</p>
<p>当一个bucket中已经填满已知的好节点(full of known good nodes)时，我们可以不再添加节点，除非我们自己的节点ID在bucket的范围内。此时，这个桶会被两个桶替换，每个桶都是旧桶的一半。旧桶中的节点被分布在新桶中。</p>
<p>对于只有一个bucket的新表，我们总是将完整的bucket分割为覆盖范围为0 - 2^159 和 2^159 - 2^160。</p>
<p>当桶中满是好的节点时，我们只需丢弃新节点。当桶中的节点变坏(被确认变坏)时，我们才用一个新节点替换它们。</p>
<blockquote>
<p>当节点被认为是有问题(questionable)的，并且在过去15分钟内没有任何响应，那么最近最少无响应的节点将被ping。节点响应或不响应。响应意味着我们移动到下一个节点。我们重复这样做，直到找到一个没有响应的节点。</p>
<p>如果我们没有找到，那么这个桶就被认为是好的。</p>
<p>当我们确实找到一个节点无响应时，我们会在丢弃该节点并用新的好节点替换它们之前，再尝试ping一次。</p>
</blockquote>
<p>同时，每个桶都维护了一个“最后更改(last changed)”属性，以显示其存储内容的“新鲜程度(fresh)”。</p>
<p>当桶中的一个节点被ping并响应，或一个新节点被添加到桶中，或一个节点被另一个节点替换时，将会更新桶的last changed属性。</p>
<p>如果last changed属性在最近15分钟内没有更新，则会刷新bucket。</p>
<h3 id="攻击BitTorrent"><a href="#攻击BitTorrent" class="headerlink" title="攻击BitTorrent"></a><a href="#%E6%94%BB%E5%87%BBBitTorrent" title="攻击BitTorrent"></a>攻击BitTorrent</h3><p>对BitTorrent网络的攻击很少，因为一切都是公开的，比如：我们的IP地址，我们下载的东西等；</p>
<p>有人可能会问，为什么要攻击开放网络？为什么要攻击一个完全开放的网络？</p>
<p>在<a target="_blank" rel="noopener" href="https://www.exploit-db.com/">Exploit-DB</a>上只列出了7个条目，并且大多数都是针对特定的客户��</p>
<p>对BitTorrent网络的主要攻击目的是阻止盗版。我们谈到这里还没有谈到盗版，但它通常是BitTorrent的同义词。</p>
<p>bt的主要攻击手段是bt中毒(Torrent Poisoning)。</p>
<h4 id="Torrent-Poisoning"><a href="#Torrent-Poisoning" class="headerlink" title="Torrent Poisoning"></a><a href="#Torrent-Poisoning" title="Torrent Poisoning"></a>Torrent Poisoning</h4><p>这种攻击的目的是获取盗版内容的对等点的IP地址或以某种方式修改文件内容。</p>
<p>麦当娜(Madonna)发行的《Madonna’s American Life》专辑就是内容中毒的一个例子。在发行之前，曲目发行的长度和文件大小类似。歌曲中有一段麦当娜说：</p>
<blockquote>
<p>“What the fuck do you think you’re doing?”</p>
</blockquote>
<p>随后是几分钟的沉默。</p>
<p>下面是一些使种子中毒的方法。</p>
<p><strong>① Index Poisoning</strong></p>
<p>索引允许用户定位具有所需内容的对等节点的IP地址。这种攻击方法可以让对等点的搜索变得困难。</p>
<p>攻击者会在索引中插入大量无效信息，以阻止用户找到正确的信息。</p>
<p>其思想是通过让对等点尝试从无效对等点下载片段来减慢下载速度。</p>
<p><strong>② Decoy Insertion</strong></p>
<p>他们将文件的损坏版本插入网络。</p>
<p>想象一下，一个文件有500份拷贝，其中只有2份是真正的文件，这会阻止盗版者找到真正的文件。</p>
<p>但是，大多数有种子列表的网站都有投票系统。这阻止了这种攻击，因为搜索的顶部充满了未损坏的文件。</p>
<p>在GameDevTycoon中，损坏的文件是在正版文件上传到盗版网站之前发布的。盗版者不知道的是，文件已经损坏。在盗版游戏中除了无法获得胜利，其他一切都是正常的！</p>
<h3 id="防御BitTorrent攻击"><a href="#防御BitTorrent攻击" class="headerlink" title="防御BitTorrent攻击"></a><a href="#%E9%98%B2%E5%BE%A1BitTorrent%E6%94%BB%E5%87%BB" title="防御BitTorrent攻击"></a>防御BitTorrent攻击</h3><p>最受欢迎的种子是由多年来建立融洽关系的个人或团体发布的。而在私人tracker上，种子的资源可以指向个人。所有，有毒的种子可以很快被贴上标签，从而传播也可以被禁止。</p>
<p>换而言之，在公共tracker上，下载由受信任团体制作的种子更可取。毕竟，你是喜欢从Ubuntu团队下载Ubuntu，还是从用户xxx- hackers - elite - ghost - protocol- xxx下载？</p>
<p>在公共tracker中，如果一个种子是有毒的，该种子会被报告和删除。</p>
<p>防御bt攻击最简单的方法是使用一个与你无关的IP地址，无论这是通过VPN还是其他服务(The simplest way to defend against a BitTorrent attack is to use an IP address not associated with you. Whether this is through a VPN or some other service)。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="#%E6%80%BB%E7%BB%93" title="总结"></a>总结</h3><p>通过阅读本文，我想你学到了：</p>
<ul>
<li>什么是BitTorrent；</li>
<li>什么是Torrent描述符文件；</li>
<li>BitTorrent如何选择对等点；</li>
<li>BitTorrent如何选择文件块；</li>
<li>严格的优先级（Strict Priority）；</li>
<li>最少的优先（Rarest First）</li>
<li>残局模式（Endgame Mode）</li>
<li>阻塞算法（Choking Algorithms）</li>
<li>以牙还牙算法（tit-for-tat）；</li>
<li>帕累托效率（Pareto Efficiency）</li>
<li>开放检测（Optimistic Unchoking）</li>
<li>反对歧视（Anti-snubbing）</li>
<li>仅仅上传（Upload Only）</li>
<li>什么是tracker；</li>
<li>对BitTorrent网络的攻击；</li>
<li>……</li>
</ul>
<p>如果你想继续深入了解BitTorrent：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://allenkim67.github.io/programming/2016/05/04/how-to-make-your-own-bittorrent-client.html">Build your own BitTorrent client</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bittorrent.org/beps/bep_0000.html">Explore BitTorrent’s proposals (BEPs) to learn more about how it works, and what’s next for the algorithm</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bittorrent.org/beps/bep_0003.html">Read the official BitTorrent specification</a></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><a href="#%E9%99%84%E5%BD%95" title="附录"></a>附录</h2><p>原文链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://skerritt.blog/bit-torrent/">How Does BitTorrent Work? a Plain English Guide</a></li>
</ul>
<p>对于搭建Aria2离线下载服务器感兴趣的可以看我的这几篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/01/Aria2%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/">Aria2安装与配置</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E4%BD%BF%E7%94%A8Aria2%E6%90%AD%E5%BB%BA%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/">使用Aria2搭建你自己的离线下载服务器</a></li>
<li><a target="_blank" rel="noopener" href="https://jasonkayzk.github.io/2020/05/02/%E8%A7%A3%E5%86%B3Aria2%E7%9A%84BT%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E6%85%A2%E6%88%96%E6%B2%A1%E9%80%9F%E5%BA%A6%E7%9A%84%E9%97%AE%E9%A2%98/">解决Aria2的BT下载速度慢或没速度的问题</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/03/20/Aria2%E5%B1%8F%E8%94%BD%E8%BF%85%E9%9B%B7%E7%AD%89%E5%90%B8%E8%A1%80%E5%AE%A2%E6%88%B7%E7%AB%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/Aria2%E5%B1%8F%E8%94%BD%E8%BF%85%E9%9B%B7%E7%AD%89%E5%90%B8%E8%A1%80%E5%AE%A2%E6%88%B7%E7%AB%AF/" class="post-title-link" itemprop="url">Aria2屏蔽迅雷等吸血客户端</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 12:01:50" itemprop="dateCreated datePublished" datetime="2022-03-20T12:01:50+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:52:06" itemprop="dateModified" datetime="2022-05-01T10:52:06+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Aria2屏蔽迅雷等吸血客户端，自动更新tracker，移除wantDigest头的Docker镜像。</p>
<!---more--->
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker create --name=aria2 \</span><br><span class="line">-v &lt;path to downloads&gt;:/mnt \</span><br><span class="line">-v &lt;path to config&gt;:/config \</span><br><span class="line">-e PGID=&lt;gid&gt; -e PUID=&lt;uid&gt; \</span><br><span class="line">-e TZ=&lt;timezone&gt; -e SECRET=&lt;admin&gt; \</span><br><span class="line">-e RPC=&lt;6800&gt; PORT=&lt;16881&gt; WEB=&lt;80&gt; \</span><br><span class="line">-p 6800:6800 -p 16881:16881 -p80:80 \</span><br><span class="line">auska/docker-aria2</span><br></pre></td></tr></table></figure>

<h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><ul>
<li><code>-p 80</code> 网页管理端口</li>
<li><code>-p 6800</code> PRC端口</li>
<li><code>-p 16881</code> - BT软件通讯端口</li>
<li><code>-v /config</code> - 配置文件目录</li>
<li><code>-v /mnt</code> - 下载文件目录</li>
<li><code>-e PGID</code> 用户的GroupID，留空为root</li>
<li><code>-e PUID</code> 用户的UserID，留空为root</li>
<li><code>-e SECRET</code> 登录密钥，默认admin</li>
<li><code>-e TZ</code> 时区 默认 Asia&#x2F;Shanghai</li>
</ul>
<h2 id="版本介绍"><a href="#版本介绍" class="headerlink" title="版本介绍"></a>版本介绍</h2><p>latest ： 自带WEB。</p>
<p>no-web ： 不包括WEB_UI。</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><p>2022-03-17 增加屏蔽迅雷等吸血客户端，webui更新到1.2.3。</p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>Docker：<a target="_blank" rel="noopener" href="https://hub.docker.com/repository/docker/auska/docker-aria2">https://hub.docker.com/repository/docker/auska/docker-aria2</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2022/03/19/qbitttorrent%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/19/qbitttorrent%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB/" class="post-title-link" itemprop="url">qbitttorrent静态编译文件分享</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-19 17:54:12" itemprop="dateCreated datePublished" datetime="2022-03-19T17:54:12+08:00">2022-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:52:20" itemprop="dateModified" datetime="2022-05-01T10:52:20+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>qbitttorrent 静态编译文件分享。</p>
<!---more--->

<h1 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h1><p>原版：<a target="_blank" rel="noopener" href="https://github.com/qbittorrent/qBittorrent">https://github.com/qbittorrent/qBittorrent</a><br>增强版：<a target="_blank" rel="noopener" href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">https://github.com/c0re100/qBittorrent-Enhanced-Edition</a><br>快校版：<a target="_blank" rel="noopener" href="https://github.com/ChisBread/libtorrent">https://github.com/ChisBread/libtorrent</a><br>增强+快校版：综合和两个版本的功能。</p>
<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p>Github：<a target="_blank" rel="noopener" href="https://github.com/Auska/qbittorrent-static/releases">https://github.com/Auska/qbittorrent-static/releases</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2020/06/02/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85-qBittorrent-%E5%A5%97%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/02/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85-qBittorrent-%E5%A5%97%E4%BB%B6/" class="post-title-link" itemprop="url">群晖安装 qBittorrent 套件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 09:11:38" itemprop="dateCreated datePublished" datetime="2020-06-02T09:11:38+08:00">2020-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:51:55" itemprop="dateModified" datetime="2022-05-01T10:51:55+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>自从疫情期间，圈养在家无事可做，只能没事玩玩PT。那么即使然是玩PT就不然少不了qBittorrent。但是当时软件版本只有4.19.1，像我这样追新的人肯定不满意，故编译了4.2.5版本。</p>
<!---more--->
<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装方法网上有很多，这里简单说一下注意点：</p>
<ol>
<li>首先启动家目录服务。</li>
<li>确认启用了admin账户（需要以自定用户启动的请往下看）。</li>
</ol>
<p>推荐几个链接不再赘述。</p>
<blockquote>
<p>参考1——<a target="_blank" rel="noopener" href="https://blog.zuiyu1818.cn/posts/NAS_qBittorrent.html">点击前往</a><br>参考2——<a target="_blank" rel="noopener" href="https://www.pjs.ink/qbittorrent.html">点击前往</a></p>
</blockquote>
<hr>
<h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><p>本段需要一定的Linux知识。<br>目录说明：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>路径</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>存放配置</td>
<td>&#x2F;var&#x2F;services&#x2F;homes&#x2F;${USER}&#x2F;.config</td>
<td>USER默认为admin</td>
</tr>
<tr>
<td>安装位置</td>
<td>&#x2F;var&#x2F;packages&#x2F;${NAME}&#x2F;target</td>
<td>NAME默认为qBittorrent</td>
</tr>
<tr>
<td>启动脚本</td>
<td>&#x2F;var&#x2F;packages&#x2F;${NAME}&#x2F;scripts</td>
<td>NAME默认为qBittorrent</td>
</tr>
</tbody></table>
<h3 id="调整启动用户"><a href="#调整启动用户" class="headerlink" title="调整启动用户"></a>调整启动用户</h3><p>修改<code>/var/packages/qBittorrent/scripts/start-stop-status</code>文件，将第三行<code>USER=admin</code>的<code>admin</code>改成自己用户的，重启插件。</p>
<h3 id="备份种子信息及设置"><a href="#备份种子信息及设置" class="headerlink" title="备份种子信息及设置"></a>备份种子信息及设置</h3><p>停止插件，复制<code>/var/services/homes/admin/.config</code>文件夹。</p>
<h3 id="直接更换qBittorrent版本"><a href="#直接更换qBittorrent版本" class="headerlink" title="直接更换qBittorrent版本"></a>直接更换qBittorrent版本</h3><p>将<code>qBittorrent</code>的二进制文件替换到<code>/var/packages/qBittorrent/target/qbittorrent-nox</code>，重启插件即可。</p>
<blockquote>
<p>请使用全静态编译的二进制文件，否则无法启动。</p>
</blockquote>
<hr>
<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>后面带<code>+</code>为增强版,否则为原版。</p>
<h3 id="增强版"><a href="#增强版" class="headerlink" title="增强版"></a>增强版</h3><p>即为使用<a target="_blank" rel="noopener" href="https://github.com/c0re100/qBittorrent-Enhanced-Edition">qBittorrent-Enhanced-Edition</a>源码编译的版本，适合BT任务。</p>
<blockquote>
<p>特色功能：会默认断开吸血客户端，根据网址自动添加tracker。</p>
</blockquote>
<hr>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1sKfRwlwEufq9S1AbgtKKog">下载链接</a> 提取码<code>urwi</code></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2019/02/01/mergerfs-%E5%90%88%E5%B9%B6%E5%A4%9A%E5%9D%97%E7%A1%AC%E7%9B%98%E7%9A%84%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/01/mergerfs-%E5%90%88%E5%B9%B6%E5%A4%9A%E5%9D%97%E7%A1%AC%E7%9B%98%E7%9A%84%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4/" class="post-title-link" itemprop="url">（转载）mergerfs 合并多块硬盘的剩余空间</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-01 17:54:12" itemprop="dateCreated datePublished" datetime="2019-02-01T17:54:12+08:00">2019-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 18:54:01" itemprop="dateModified" datetime="2022-05-19T18:54:01+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>两年前，我买了一台 HP Gen8 微型服务器，其功能之一是作为网络存储。当时它只接了一块 SSD 作为系统盘和一块 2 TB HDD 作为存储盘。随着存储文件的增多，我又先后增加了两块 4 TB HDD，现在它已经接了共计 10 TB 的存储空间。我觉得有必要分享一下我用来将这些硬盘的空间合并在一起的工具——mergerfs。</p>
<hr>
<h1 id="一、网络存储之硬盘困境"><a href="#一、网络存储之硬盘困境" class="headerlink" title="一、网络存储之硬盘困境"></a>一、网络存储之硬盘困境</h1><p>在讲工具之前，我有必要先说明一下我目前的存储方案。</p>
<p>我的 Gen8 没有直接装通用操作系统，而是先通过 ESXi 实现了虚拟化，再将存储盘通过 RDM 的方式完整地映射给其中的一台虚拟机（Arch Linux）。在 Arch Linux 里运行了 Samba, NFS, aria2 RPC, Transmission daemon, BorgBackup 等服务，供局域网电脑存取文件、远程下载，以及备份。</p>
<p>我在存储盘里的东西分为两类：一类是多份备份中的一份（BorgBackup）；另一类是从互联网上下载的可再生资源。前者本身有冗余，后者丢了不心疼。出于以上考虑，为了硬盘空间利用率的最大化，我并没有采用 RAID 1 或 RAID 5 之类的冗余存储的方案，而是采用了 JBOD 方案——Just Bunch of Disks。</p>
<p>不使用 RAID 做冗余还有一个原因：我希望这些硬盘从 Gen8 上拔下来之后接到别的电脑上我能直接读取它们。</p>
<p>当我的第一块存储盘快要装满的时候，我买了第二块盘，这时候就面临了一个问题：如何把两块硬盘的空间合并？考虑到我已经在运行的那些服务，我自然不想再增加一个额外的挂载点。我曾考虑过三个硬盘空间合并方案：</p>
<ul>
<li>RAID 0。与 RAID 1 或 RAID 5 不同，RAID 0 是对多块相同容量的硬盘进行平行读写，从而提升性能，其额外效果就是硬盘空间也被合并了。但这种方案非常危险：多块硬盘中的任意一块挂了，所有的数据都将无法读取。这个方案不行。</li>
<li>LVM。相比 RAID 0 的原理，LVM 只是将空间连接起来了，而没有平行读写，所以多块硬盘中的一块挂了，也只是丢了那一块的数据。但创建过 LVM PV 的硬盘，在别的机器上读取起来比较麻烦，所以这个方案我也不喜欢。</li>
<li>MooseFS。相对前两种方案，由于它在 FUSE 层面实现，所以更灵活一些，甚至可以通过网络，把没有挂在 Gen8 上的硬盘也纳入存储空间。但这个方案和 LVM 一样，协作性不强，硬盘在别的机器上只能看到一堆数据碎块文件，因此也被我否决了。<br>以上三种方案还有一个问题：我需要把硬盘里现有的数据全部倒出来再倒进去……我需要的是能将文件分散存储到多块硬盘，同时又不改变文件形态的方案。</li>
</ul>
<h1 id="二、mhddfs-与-mergerfs"><a href="#二、mhddfs-与-mergerfs" class="headerlink" title="二、mhddfs 与 mergerfs"></a>二、mhddfs 与 mergerfs</h1><p>早有人遇到过像我一样的困境，于是他开发了 mhddfs。在用了它一段时间之后，我又发现了一个更好的实现 mergerfs。两者的思路类似，但后者比前者功能更丰富、更安全、更稳定。本文以后者为例说明。</p>
<p>mergerfs 的思路是用 FUSE 实现一个新的文件系统，它的下层存储并不是直接的块设备，而是别的已经挂载的文件系统。mergerfs 接收到读写请求时，它会根据约定好的策略，从下层文件系统中读取文件，或是将数据写入下层文件系统。mergerfs 所呈现的文件系统，容量是所有下层文件系统之和，而内容则是所有下层文件系统的合并。</p>
<p>引用 mergerfs README 里的 ASCII art：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A         +      B        =       C</span><br><span class="line">/disk1           /disk2           /merged</span><br><span class="line">|                |                |</span><br><span class="line">+-- /dir1        +-- /dir1        +-- /dir1</span><br><span class="line">|   |            |   |            |   |</span><br><span class="line">|   +-- file1    |   +-- file2    |   +-- file1</span><br><span class="line">|                |   +-- file3    |   +-- file2</span><br><span class="line">+-- /dir2        |                |   +-- file3</span><br><span class="line">|   |            +-- /dir3        |</span><br><span class="line">|   +-- file4        |            +-- /dir2</span><br><span class="line">|                     +-- file5   |   |</span><br><span class="line">+-- file6                         |   +-- file4</span><br><span class="line">                                  |</span><br><span class="line">                                  +-- /dir3</span><br><span class="line">                                  |   |</span><br><span class="line">                                  |   +-- file5</span><br><span class="line">                                  |</span><br><span class="line">                                  +-- file6</span><br></pre></td></tr></table></figure>
<p>如图所示，&#x2F;merged 是 mergerfs 的挂载点，其下层两个文件系统的挂载点是 &#x2F;disk1 和 &#x2F;disk2。</p>
<p>这样一个文件系统完全符合我的需求：读写文件时能获得合并空间的优势，而当硬盘损坏或是想要直接读取硬盘里的数据的时候又可以单独把硬盘拆出来读取。而且我不用把现有的数据倒腾来倒腾去了，无痛迁移！</p>
<h1 id="三、mergerfs-的安装与配置"><a href="#三、mergerfs-的安装与配置" class="headerlink" title="三、mergerfs 的安装与配置"></a>三、mergerfs 的安装与配置</h1><p>mergerfs 的作者非常勤奋，每个版本都会为 RHEL &#x2F; CentOS, Fedora, Debian, Ubuntu 不同发行版的不同版本、不同架构组合打包 30 多个 rpm 和 deb 安装包，其中包括了 ARM 甚至 PowerPC 架构，方便使用 Raspberry Pi 或是老 Mac 作为网络存储设备的用户。Arch Linux 用户则可以通过 AUR 安装。</p>
<p>安装之后通过编辑 &#x2F;etc&#x2F;fstab 来挂载 mergerfs。我使用的 fstab 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/dev/sdb1               /media/disk1    ext4            defaults,noauto                 0 0</span><br><span class="line">/dev/sdc1               /media/disk2    ext4            defaults,noauto                 0 0</span><br><span class="line">/dev/sdd1               /media/disk3    ext4            defaults,noauto                 0 0</span><br><span class="line">/media/disk1:/media/disk2:/media/disk3  /media/vdisk    fuse.mergerfs   defaults,noauto,allow_other,use_ino,minfreespace=100G,ignorepponrename=true 0 0</span><br></pre></td></tr></table></figure>
<p>前三行是三块存储盘的普通挂载，第四行是 mergerfs 的条目，它的挂载源是前三块盘的的挂载点，用冒号分隔。最后一列的参数说明：</p>
<ul>
<li>defaults: 开启以下 FUSE 参数以提升性能：atomic_o_trunc, auto_cache, big_writes, default_permissions, splice_move, splice_read, splice_write；</li>
<li>noauto: 禁止开机自动挂载。意外关机重启之后我可能需要手动检查文件系统后再挂载，所以我不希望它自动挂载；</li>
<li>allow_other: 允许挂载者以外的用户访问 FUSE。你可能需要编辑 &#x2F;etc&#x2F;fuse.conf 来允许这一选项；</li>
<li>use_ino: 使用 mergerfs 而不是 libfuse 提供的 inode，使硬链接的文件 inode 一致；</li>
<li>minfreespace&#x3D;100G: 选择往哪个下层文件系统写文件时，跳过剩余空间低于 100G 的文件系统；</li>
<li>ignorepponrename&#x3D;true: 重命名文件时，不再遵守路径保留原则，见下一节详解。<br>写完 fstab 之后就可以让 mergerfs 跑起来了：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /media/disk1 &amp;&amp; mount /media/disk2 &amp;&amp; mount /media/disk3 &amp;&amp; mount /media/vdisk</span><br></pre></td></tr></table></figure>
效果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sdb1       1.8T  1.7T  179G  91% /media/disk1</span><br><span class="line">/dev/sdc1       3.6T  3.4T  215G  95% /media/disk2</span><br><span class="line">/dev/sdd1       3.6T   89M  3.4T   1% /media/disk3</span><br><span class="line">1:2:3           9.0T  5.0T  3.8T  57% /media/vdisk</span><br></pre></td></tr></table></figure>
disk3 是我今天刚装上的，所以它还是空的。</li>
</ul>
<h1 id="四、mergerfs-的读写策略"><a href="#四、mergerfs-的读写策略" class="headerlink" title="四、mergerfs 的读写策略"></a>四、mergerfs 的读写策略</h1><p>如果多块硬盘里同名的目录或文件，从哪儿读？往哪儿写？如果多块硬盘都有足够的剩余空间，在哪块硬盘创建新文件？mergerfs 对 FUSE 的不同操作有着不同的读写策略。默认的策略是：</p>
<ul>
<li><p>action 类别：对于 chmod, chown 等改变文件或目录属性的操作，mergerfs 检索所有下层文件系统，确保所有文件或目录都得到更改；</p>
</li>
<li><p>search 类别：对于 open, getattr 等读取文件或目录的操作，mergerfs 按挂载源列表的顺序检索下层文件系统，返回第一个找到结果；</p>
</li>
<li><p>create 类别：对于 create, mkdir 等创建文件或目录的操作，mergerfs 优先选择相对路径已经存在的下层文件系统中剩余空间最大的那个作为写入目标。<br>前两条很好理解，最后一条比较拗口。举例来说是这样：</p>
</li>
<li><p>disk1 剩余 100 GiB 空间，有 &#x2F;dir1 目录；</p>
</li>
<li><p>disk2 剩余 200 GiB 空间，有 &#x2F;dir2 目录；</p>
</li>
<li><p>disk3 剩余 300 GiB 空间，有 &#x2F;dir3 目录；</p>
</li>
<li><p>mergerfs 将这三块硬盘的文件系统合并成一个，可以同时看到 &#x2F;dir1, &#x2F;dir2, &#x2F;dir3 三个目录。<br>这时在 mergerfs 对于上层文件系统写入一个 150 GiB 的文件到 &#x2F;dir2&#x2F;foo.bin 位置，按照默认的策略，mergerfs 会选择 disk2 写入。因为：disk1 剩余空间不足（小于 minfreespace 或是只读文件系统也会被跳过选择），而虽然 disk3 比 disk2 剩余空间更多，但因为 disk2 已经有 &#x2F;dir2 目录了，所以 mergerfs 会优先选择写入 disk2 而不是 disk3。</p>
</li>
</ul>
<p>这个策略的意义在于，当下层文件系统的剩余空间差不多时，你的文件不会被分散开。比如你正在将你的相机图片文件夹复制到 mergerfs 里，一个文件夹里有 999 张图片，第一张图片的落点也将决定接下来 998 张文件的落点，而不会因为下层文件系统剩余空间的交替变化而一会儿落到这个文件系统，一会儿落到那个文件系统。最终下层文件系统会被平衡地使用，但相同目录的文件会尽可能地在同一个文件系统里，这非常棒。</p>
<p>但这个策略一直有一个痛点让我难受了很久：移动文件。比如 2016 年份的文件位于 disk1，而 2017 年份的文件因为 disk1 已经满了写到 disk2 来了，在 2018 年的时候我想把三年的文件都归到一个新目录里。此时 2016 年的文件可以瞬间完成，2017 年的文件则由于上述策略会优先选择 disk1，于是就从瞬间完成变成了缓慢的跨盘移动，当这些文件数量巨大的时候，已经开始的传输我又不敢贸然中止……这样的坑我在整理文件时掉过很多次。终于，mergerfs 2.23.0 版本新增了 ignorepponrename 选项，使得在重命名文件的时候，忽略路径保留规则，避免了简单的文件整理操作变成痛苦的跨盘移动的悲剧。</p>
<p>如果 mergerfs 的默认读写策略不适用于你的应用场景，可以通过挂载参数选用别的策略。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2019/02/01/%E7%9B%AE%E5%BD%95%E7%BA%A7%E5%88%AB%E7%9A%84%E5%86%97%E4%BD%99%E5%AD%98%E5%82%A8SnapRAID/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/02/01/%E7%9B%AE%E5%BD%95%E7%BA%A7%E5%88%AB%E7%9A%84%E5%86%97%E4%BD%99%E5%AD%98%E5%82%A8SnapRAID/" class="post-title-link" itemprop="url">（转载）目录级别的冗余存储：SnapRAID</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-01 17:54:12" itemprop="dateCreated datePublished" datetime="2019-02-01T17:54:12+08:00">2019-02-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 19:03:26" itemprop="dateModified" datetime="2022-05-19T19:03:26+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在数据存储领域，「备份」和「冗余」是两种常见的数据保护策略。两种策略各有不同的使用场景，对于重要数据，两者一起使用自然是最好了。本文介绍使用 SnapRAID 实现灵活的数据冗余存储。</p>
<hr>
<h1 id="一、神奇的奇偶校验"><a href="#一、神奇的奇偶校验" class="headerlink" title="一、神奇的奇偶校验"></a>一、神奇的奇偶校验</h1><p>小时候一直觉得 WinRAR 的「恢复卷」功能非常神奇。比如有一个 100 MiB 的压缩文件分成 10 个分卷，每个 10 MiB，创建者又创建了 3 个恢复卷，每个也是 10 MiB。当复制、分发这些卷的时候，如果因为数据传输、磁盘存储等各种原因，导致 10 个数据卷中有部分文件损坏或丢失，只要损坏或丢失的数据卷的数量小于等于恢复卷的数量，就可以用对应数量的恢复卷来修复压缩包。</p>
<p>小时候不理解为什么丢失一部分数据之后可以用现有的数据重新算出来，现在明白了，最简单的实现便是奇偶校验。</p>
<p>奇偶校验常见于数据传输中。比如 1 个字节（byte）由 8 个比特（bit）组成，但双方约定：只用 7 bit 来存储数据，剩下 1 bit 作为校验位（parity bit）。校验规则是：如果前面 7 bit 里 1 的数量为奇数（1, 3, 5, 7），则 parity bit 为 1；如果前面 7 bit 里 1 的数量为偶数（0, 2, 4, 6），则 parity bit 为 0。这样最终这个 byte 里 1 的数量一定是偶数，如果接收方发现 1 的数量不是偶数，那就说明出错了，一定是在传输过程中发生了比特翻转（bit flip），即本来是 0 的变成了 1，或本来是 1 的变成了 0。当然，如果这个 byte 在传输过程中发生了偶数个 bit flip，那校验倒也恰好能通过，但由于同一 byte 里有大于一个 bit flip 的概率非常低，所以奇偶校验在实际应用中还是非常简单有效的。</p>
<p>然而，上述奇偶校验只能知道「出错了」，但是无法知道「哪里出错了」，也无法修复出错的部分。但是在存储的时候，人们往往是知道哪里出错的。想像一下，如果上述 8 bit 不是存在同一 byte 里而是分散在 8 块磁盘上，这时候某一块磁盘突然挂了，你是明确地知道「哪里出错了」的（磁盘不转了），因此你根据其他 7 块磁盘里的 bit 值，来反推出坏掉的磁盘里存储的是 0 还是 1（把 1 的总数凑成偶数即可），也就是说，你可以利用 7 块健在的磁盘上的数据，修复坏掉的磁盘上的数据。</p>
<p>显然地，如果 8 块磁盘同时坏了 2 块或以上，那就有 00, 01, 10, 11 四种可能了，只有一个奇偶校验位的情况下是修复不了的。幸运的是，计算机科学家和数学家们早就研究出了其他更高级的冗余算法，可以使一组数据有两个或两个以上的校验位，用来在已知「哪里出错了」的情况下，修复出错的部分。SnapRAID 所用的冗余算法，用 N 个存储器用来存储数据，同时用 P 个存储器用来存放校验数据（P ≤ 6, P ≤ N），在总数 P + N 的存储器中，任意坏掉 X 个，只要 X ≤ P，就能用剩下存储器里的数据计算出坏掉的存储器里的数据。</p>
<p>这便是冗余存储的理论基础。</p>
<h1 id="二、备份与冗余存储"><a href="#二、备份与冗余存储" class="headerlink" title="二、备份与冗余存储"></a>二、备份与冗余存储</h1><p>虽说「备份」和「冗余」两大数据保护策略有各自的使用场景，冗余并不能取代备份，但如果要将这两者进行比较的话，冗余相比备份最大的优点，是可以相对节省存储空间。回顾上一节里提到的 7 + 1 块磁盘的场景，假设每块磁盘是 1 TB，则有效存储空间是 7 TB，剩下 1 TB 是校验数据。在磁盘使用过程中，任意一块磁盘坏掉，你都可以重新买一块新的替换磁盘，然后把坏掉磁盘的内容完整地推算出来，相当于你用 1 TB 的空间，换取了 7 TB 数据的「相对安全」（仅就对抗硬件故障而言），比完整备份 7 TB 数据省了很多空间。</p>
<p>然而，实际生产生活中，7 + 1 这样的组合风险比较高，因为同时开始使用的磁盘，很可能一起坏掉，一旦有两块磁盘同时坏掉，就会有数据无法被修复了。悲剧往往是这样发生的：一组磁盘里坏了一块，然后换了块新的上去，开始根据旧磁盘的数据推算出坏掉磁盘里原有的数据并写入新磁盘，由于这个推算过程需要将所有旧磁盘里的数据全部读一遍（视磁盘大小，这个过程可能会持续一两天），大量的读取操作成了最后一根稻草，还没等新磁盘填满，又一块旧磁盘挂了。</p>
<p>根据存储及备份提供商 BackBlaze 公开的信息，他们使用的是 13 + 2 的组合，即 15 块磁盘一组，最多能同时坏 2 块磁盘而不丢数据。</p>
<h1 id="三、RAID-与-ZFS"><a href="#三、RAID-与-ZFS" class="headerlink" title="三、RAID 与 ZFS"></a>三、RAID 与 ZFS</h1><p>在数据中心里，冗余存储最常见实现是 RAID。使用带冗余的 RAID 级别，如 RAID 5 和 RAID 6，可以在空间利用率和容错性之间达到一个平衡。存储服务器一般会安装硬件 RAID 卡，实现对操作系统透明的 RAID（操作系统看到的就是一个已经带冗余存储的磁盘，并不用关心下面是几块磁盘、怎么实现的）。在 GNU&#x2F;Linux 中也可以使用 mdadm 工具实现软件 RAID，无需专门的硬件即可实现冗余存储。</p>
<p>在《使用 mergerfs 合并多块硬盘的剩余空间》一文的「读者来信」一节，有读者推荐了 ZFS。这套来自 Sun 的存储方案也可以实现类似 RAID 的功能，包括冗余存储。</p>
<p>然而，使用 RAID 和 ZFS 进行冗余存储都存在一个问题：data lock-in。即，要在已有数据的磁盘上使用 RAID &#x2F; ZFS，需要把数据先导出，将磁盘清空，然后重新导入数据，并且你想要将某块磁盘脱离 RAID &#x2F; ZFS 单独读写里面的数据也非常麻烦（如果不是不可能）。</p>
<p>这在数据中心看来也许不是什么问题，但是我希望能有一个更加灵活、自由的冗余存储方案。</p>
<h1 id="四、似-RAID-而非-RAID-的-SnapRAID"><a href="#四、似-RAID-而非-RAID-的-SnapRAID" class="headerlink" title="四、似 RAID 而非 RAID 的 SnapRAID"></a>四、似 RAID 而非 RAID 的 SnapRAID</h1><p>SnapRAID 是一个目录级别的冗余存储方案，它与 RAID 的原理有相似的地方，但它并不是 RAID。SnapRAID 与 RAID 的主要区别有：</p>
<ul>
<li><p>SnapRAID 不会对数据进行条带化存储。RAID 通常会使用数据条带化，一个文件可能会被分散存储到多块磁盘上，这样的优点是读取的时候可以加速（多块磁盘同时读取），但条带化也是上节所说的 data lock-in 的根源——你不能拆出一块盘单独读写。</p>
</li>
<li><p>SnapRAID 是工作于文件系统之上的。RAID 工作于文件系统之下，直接对磁盘区块进行操作，用磁盘区块上的比特计算校验数据，而 SnapRAID 是通过读取文件系统里的文件之后再进行计算的。</p>
</li>
<li><p>SnapRAID 是非实时的。RAID 每时每刻都在工作，磁盘区块上的数据一旦发生变更就会重新计算校验数据，而 SnapRAID 可以在用户选择的时间进行重新计算。<br>SnapRAID 相比 RAID 的优点主要有：</p>
</li>
<li><p>数据独立。不需要对磁盘做特殊处理，可以直接将已有数据的磁盘（甚至可以是不同文件系统的）加入 SnapRAID，SnapRAID 也不会改变这些已有的数据；一个文件不会被分散到多个磁盘，随时可以拆下来一块磁盘正常读写里面的数据；当磁盘阵列收到文件读写请求时，也只需要一块磁盘响应，而不是所有的磁盘全部从待机状态启动，开始寻道。</p>
</li>
<li><p>抗灾能力。当磁盘列阵中同时损坏的磁盘数量超出预期而无法修复数据时，SnapRAID 的抗灾能力更强。例如：在 3 + 1 的 RAID 场景下，坏一块没事，如果同时坏了两块，所有的磁盘上的数据都将无法读取（因为条带化）；但如果是 3 + 1 的 SnapRAID，就算同时坏两块，剩下两块里的数据依然可以正常读取。</p>
</li>
<li><p>配置灵活。标准的 RAID 等级中，RAID 5 最多承受 1 块磁盘同时损坏，RAID 6 最多承受 2 块磁盘同时损坏；而 SnapRAID 可以配置 1 到 6 块校验盘，最多承载 6 块磁盘同时损坏，因此可以组建更大的磁盘阵列而不提升风险（维持数据盘与校验盘的比例不变）。更重要的是，无论是增加还是减少磁盘，SnapRAID 都可以无痛完成，无需清空磁盘数据。</p>
</li>
<li><p>恢复误删文件。由于 RAID 是实时计算校验数据的，当文件被删除时，这一改动立刻就会被同步到校验数据里；而 SnapRAID 在用户请求的时候才进行同步，因此用户可以用 SnapRAID 从校验数据重新构建被误删除的文件。当然了，更可靠、更持久的的误删除防护还是应该用增量备份来完成。</p>
</li>
<li><p>空间利用率高。在磁盘阵列中，校验盘的大小应大于等于数据盘中最大的那块。使用 SnapRAID 时，你可以「超售」。比如数据盘是 6 TB 的但是只装了一半（3 TB），你把 4 TB 的磁盘作为校验盘也是可以的（因为此时校验数据最多只有 3 TB），只要在校验文件膨胀到接近 4 TB 的时候将校验文件挪到更大的磁盘里即可。同样的，校验盘里未被校验文件填满的剩余空间也可以用来存储一些「丢了也无所谓」的不重要数据。此外，由于 SnapRAID 工作于文件系统之上，你可以选择性地排除掉一些不想做冗余的目录和文件，以节省空间。</p>
<h1 id="五、SnapRAID-的配置与使用"><a href="#五、SnapRAID-的配置与使用" class="headerlink" title="五、SnapRAID 的配置与使用"></a>五、SnapRAID 的配置与使用</h1><p>SnapRAID 提供了 Windows 版本的二进制文件下载；GNU&#x2F;Linux、macOS，以及各种 Unix-like 可以从源码编译或从软件仓库中安装。SnapRAID 的配置文件简洁且注释详尽，读注释就能明白怎么配了。</p>
</li>
</ul>
<p>目前我的 Gen8 里有三块 SATA 磁盘，容量分别是 2 TB, 4 TB, 4 TB。前两块服役多年，几乎满了，第三块是新买的，还是空的，我想把第三块磁盘作为校验盘。我的相关配置是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 校验文件的位置</span><br><span class="line"># 显然，校验文件不能放在数据盘上，否则就没有意义了</span><br><span class="line">parity /media/disk3/snapraid.parity</span><br><span class="line"></span><br><span class="line"># 如需添加更多的校验文件则继续添加</span><br><span class="line"># 最多是 6 份校验，承受磁盘磁盘阵列中最多同时坏掉 6 块盘的情况</span><br><span class="line">#2-parity /media/disk4/snapraid.2-parity</span><br><span class="line">#3-parity /media/disk5/snapraid.3-parity</span><br><span class="line"></span><br><span class="line"># 重要的索引文件，建议保存多份（内容是一样的）</span><br><span class="line"># 我在系统盘（SSD）上存了一份，然后在三块磁盘上都各存一份</span><br><span class="line"># 系统盘上的这份同时又会被 BorgBackup 异地备份</span><br><span class="line">content /home/snapraid/snapraid.content</span><br><span class="line">content /media/disk1/snapraid.content</span><br><span class="line">content /media/disk2/snapraid.content</span><br><span class="line">content /media/disk3/snapraid.content</span><br><span class="line"></span><br><span class="line"># 指定数据盘及其挂载点</span><br><span class="line"># 这里不一定要写确切的挂载点，可以是这块盘上的任意目录</span><br><span class="line"># 目录以外的内容会被完全忽略</span><br><span class="line">data d1 /media/disk1/</span><br><span class="line">data d2 /media/disk2/</span><br><span class="line"></span><br><span class="line"># 忽略所有隐藏文件和目录（不做冗余）</span><br><span class="line"># 在 Unix-like 里就是 . 开头的文件和目录</span><br><span class="line"># 在 Windows 里就是带隐藏属性的文件和目录</span><br><span class="line">nohidden</span><br><span class="line"></span><br><span class="line"># 排除列表与包含列表，注意顺序！下文详解</span><br><span class="line">exclude *.unrecoverable</span><br><span class="line">exclude *.nobackup</span><br><span class="line">exclude *.nobackup/</span><br><span class="line">exclude /tmp/</span><br><span class="line">exclude /lost+found/</span><br><span class="line">#include /foo</span><br><span class="line">#include /bar/</span><br><span class="line"></span><br><span class="line"># 生成校验数据时，每处理 10 GiB 数据自动保存一次，方便断点继续</span><br><span class="line">autosave 10</span><br></pre></td></tr></table></figure>

<p>写好配置文件之后，使用 snapraid sync 进行首次同步，也就是根据数据盘的内容生成校验盘的内容。我的第一次同步花了 24 小时：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Scanning disk d1...</span><br><span class="line">Scanning disk d2...</span><br><span class="line">Using 221 MiB of memory for the FileSystem.</span><br><span class="line">Initializing...</span><br><span class="line">Resizing...</span><br><span class="line">Saving state to /home/snapraid/snapraid.content...</span><br><span class="line">Saving state to /media/disk1/snapraid.content...</span><br><span class="line">Saving state to /media/disk2/snapraid.content...</span><br><span class="line">Saving state to /media/disk3/snapraid.content...</span><br><span class="line">Verifying /home/snapraid/snapraid.content...</span><br><span class="line">Verifying /media/disk1/snapraid.content...</span><br><span class="line">Verifying /media/disk2/snapraid.content...</span><br><span class="line">Verifying /media/disk3/snapraid.content...</span><br><span class="line">Syncing...</span><br><span class="line">Using 24 MiB of memory for 32 blocks of IO cache.</span><br><span class="line">0%, 959 MB, 40 MB/s, CPU 1%, 24:08 ETA</span><br></pre></td></tr></table></figure>

<p>常用的 SnapRAID 命令：</p>
<ul>
<li>snapraid sync：根据数据盘生成校验盘；</li>
<li>snapraid diff：查看有哪些数据需要 sync；</li>
<li>snapraid status：查看磁盘阵列的状态；</li>
<li>snapraid scrub：进行数据擦洗，提早发现磁盘阵列中的错误。<br>SnapRAID 首次同步完成之后，可以将 snapraid sync 和 snapraid scrub 加入 cron &#x2F; systemd timer，定时运行。后者默认配置下每次运行擦洗全部数据的 8%，并且会挑选最近 10 天内没有被擦洗过的数据进行擦洗。如果每天运行一次 snapraid scrub 的话，每 12.5 天所有数据都会被擦洗一遍，形成一个健康的循环。</li>
</ul>
<p>当擦洗发现有数据损坏，或是更糟糕地，某天整块磁盘挂了（不转了），就需要修复数据了。这时候应该做的是停掉所有的定时任务，然后换上新的磁盘，然后用 snapraid fix -d name_of_disk 命令，根据健在磁盘的内容，在新磁盘里重建坏掉磁盘里的内容。只要坏掉的磁盘数量小于等于校验盘的数量，SnapRAID 都能完整地修复数据。</p>
<p>由于 snapraid sync 是定期执行的，这意味着在下次同步之前，磁盘阵列是有机会恢复到上次同步的状态的，因此 snapraid fix 除了可以重建整个磁盘，也可以重建单个文件，也就是反删除。如果你误删除了文件，可以用 snapraid fix -f path&#x2F;to&#x2F;file 来恢复文件到上次同步时的状态。</p>
<h1 id="六、SnapRAID-最佳实践"><a href="#六、SnapRAID-最佳实践" class="headerlink" title="六、SnapRAID 最佳实践"></a>六、SnapRAID 最佳实践</h1><p>事实上我也就昨天才开始用 SnapRAID，所以这所谓的「最佳实践」，其实也只是我在阅读文档和配置使用中觉得需要注意的地方。</p>
<p>排除列表与包含列表<br>因为 SnapRAID 是工作在文件系统之上、基于目录的冗余存储方案，因此可以很方便选择哪些目录和文件需要做冗余，哪些不需要。在配置文件中 include 和 exclude 的规则如下：</p>
<ul>
<li>可以使用 * ? [1-3] 这样的简单通配符；</li>
<li>以 &#x2F; 开头的路径匹配的是数据盘的根目录，而不是系统的根目录；</li>
<li>以 &#x2F; 结尾的路径只会匹配目录；</li>
<li>不以 &#x2F; 结尾的路径只会匹配文件；</li>
<li>如果最后一条规则是包含（include），则所有未匹配的路径都会被排除；</li>
<li>如果最后一条规则是排除（exclude），则所有未匹配的路径都会被包含。<br>适合使用 SnapRAID 的文件<br>因为 SnapRAID 是定期运行的，在两次 snapraid sync 之间新增的数据是有一段时间没有冗余的，这时候如果磁盘挂了，那这些数据就丢失了。因此，SnapRAID 并不适合用来对频繁变动的文件（如：系统盘）做冗余。</li>
</ul>
<p>SnapRAID 比较适用的场景是体积巨大、但是很少更改的文件。比如对摄影爱好者来说，磁盘中可能会有好几个 TiB 的 RAW 照片或是未剪辑的 4K 视频文件。这些原始文件因为体积巨大，很难通过互联网做异地备份，而它们本身几乎不会再发生变化，因此非常适合用 SnapRAID 做冗余。由于 SnapRAID 的灵活配置，用户可以方便地选择对哪些文件做冗余，也可以随时将单个磁盘从阵列中临时脱离出来，直接插到图形工作站上进行高速读写。</p>
<p>与 mergerfs 配合<br>SnapRAID 提供了类似 RAID 的冗余功能，但是 RAID 还能将磁盘阵列里的磁盘合并成一个大磁盘。SnapRAID 本身并不提供合并磁盘的功能，但是 mergerfs 可以达成这个目的</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Auska</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
