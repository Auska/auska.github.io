<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"auska.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="随便写点啥">
<meta property="og:type" content="website">
<meta property="og:title" content="博客">
<meta property="og:url" content="https://auska.github.io/page/2/index.html">
<meta property="og:site_name" content="博客">
<meta property="og:description" content="随便写点啥">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Auska">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://auska.github.io/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Auska"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Auska</p>
  <div class="site-description" itemprop="description">随便写点啥</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Auska" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Auska" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:luodan0709@live.cn" title="E-Mail → mailto:luodan0709@live.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2017/08/13/Gogs%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/08/13/Gogs%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">Gogs使用教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-13 13:54:27" itemprop="dateCreated datePublished" datetime="2017-08-13T13:54:27+08:00">2017-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 19:06:01" itemprop="dateModified" datetime="2022-05-19T19:06:01+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是-Gogs"><a href="#什么是-Gogs" class="headerlink" title="什么是 Gogs"></a>什么是 Gogs</h1><p>Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。</p>
<h1 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h1><p>Gogs 默认以 git 用户运行（你应该也不会想一个能修改 ssh 配置的程序以 root 用户运行吧？）。<br>运行 <code>sudo adduser git</code> 新建好 git 用户。<br>su git 以 git 用户登录，到 git 用户的主目录中新建好 .ssh 文件夹。</p>
<h1 id="下载解包"><a href="#下载解包" class="headerlink" title="下载解包"></a>下载解包</h1><p>我使用的是预编译的二进制包。需要从源码编译的话，请参考一般 Go 语言项目的编译。下载后解包到你喜欢的地方，例如 <code>/usr/share/gogs/</code> 或者 <code>/home/git/gogs/</code> 。文件夹的内容如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls /home/git/gogs/</span><br><span class="line">custom  data  gogs  LICENSE  log  public  README.md  README_ZH.md  scripts  templates</span><br></pre></td></tr></table></figure>

<h1 id="运行安装"><a href="#运行安装" class="headerlink" title="运行安装"></a>运行安装</h1><p>首先建立好数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在安装完mysql之后，我们还需要创建一个数据库，将之取名为gogs，</span><br><span class="line"> </span><br><span class="line">CREATE DATABASE gogs CHARACTER SET utf8 COLLATE utf8_bin;</span><br><span class="line">GRANT ALL PRIVILEGES ON gogs.* TO ‘root’@‘localhost’;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>在 Gogs 目录的 <code>scripts/mysql.sql</code> 文件是数据库初始化文件。执行 <code>mysql -u root -p &lt; scripts/mysql.sql</code> （需要输入密码）即可初始化好数据库。</p>
<p>然后登录 MySQL 创建一个新用户 gogs，并将数据库 gogs 的所有权限都赋予该用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">&gt; # （输入密码）</span><br><span class="line">&gt; create user &#x27;gogs&#x27;@&#x27;localhost&#x27; identified by &#x27;密码&#x27;;</span><br><span class="line">&gt; grant all privileges on gogs.* to &#x27;gogs&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">&gt; flush privileges;</span><br><span class="line">&gt; exit;</span><br></pre></td></tr></table></figure>
<p>运行 gogs web 把 Gogs 运行起来，然后访问 <code>http://服务器IP:3000/</code> 来进行安装，填写好表单之后提交就可以了。</p>
<p>需要注意的是， 0.6.9.0903 Beta 版本有个 bug，允许在关闭注册的情况下不添加管理员，这样安装完成之后将没有任何用户可以登录。所以请务必在安装界面指定一个管理员帐号。</p>
<h1 id="配置调整"><a href="#配置调整" class="headerlink" title="配置调整"></a>配置调整</h1><p>配置文件位于 Gogs 目录的 <code>custom/conf/app.ini</code> ，是 INI 格式的文本文件。详细的配置解释和默认值请参考 官方文档 ，其中关键的配置大概是下面这些。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RUN_USER 默认是 git ，指定 Gogs 以哪个用户运行</span><br><span class="line">ROOT 所有仓库的存储根路径</span><br><span class="line">PROTOCOL 如果你使用 nginx 反代的话请使用 http ，如果直接裸跑对外服务的话随意</span><br><span class="line">DOMAIN 域名。会影响 SSH clone 地址</span><br><span class="line">ROOT_URL 完整的根路径，会影响访问时页面上链接的指向，以及 HTTP clone 的地址</span><br><span class="line">HTTP_ADDR 监听地址，使用 nginx 的话建议 127.0.0.1 ，否则 0.0.0.0 也可以</span><br><span class="line">HTTP_PORT 监听端口，默认 3000</span><br><span class="line">INSTALL_LOCK 锁定安装页面</span><br><span class="line">Mailer 相关的选项</span><br><span class="line">其中，Mailer 可以使用 Mailgun 的免费邮件发送服务，将 Mailgun 的 SMTP 配置填入到配置中就好。</span><br></pre></td></tr></table></figure>

<h1 id="nginx-反代"><a href="#nginx-反代" class="headerlink" title="nginx 反代"></a>nginx 反代</h1><p>在 <code>/etc/nginx/sites-available</code> 中新建一个文件，把以下内容写入文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name 域名或IP;</span><br><span class="line">    listen 80; # 或者 443，如果你使用 HTTPS 的话</span><br><span class="line">    # ssl on; 是否启用加密连接</span><br><span class="line">    # 如果你使用 HTTPS，还需要填写 ssl_certificate 和 ssl_certificate_key</span><br><span class="line">    location / &#123; # 如果你希望通过子路径访问，此处修改为子路径，注意以 / 开头并以 / 结束</span><br><span class="line">        proxy_pass http://127.0.0.1:3000/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后进入 <code>/etc/nginx/sites-enabled</code> 中，执行 <code>ln -s ../sites-available/配置文件名</code> 启用这个配置文件。</p>
<p>最后重启 nginx 就好了，Ubuntu 下是 <code>sudo service nginx restart</code> 。</p>
<h1 id="服务脚本"><a href="#服务脚本" class="headerlink" title="服务脚本"></a>服务脚本</h1><p>此处的服务脚本是针对 Debian 系的 init 脚本。</p>
<p>其他地方处理办法：</p>
<p>gogs提供多重方式进行安装，比较常用的有两种。一个是二进制安装，另一个是通过源代码安装。</p>
<p>然后切换到解压得到的目录之后，直接运行 .&#x2F;gogs web 即可在服务器上运行gogs服务了。</p>
<p><code>./gogs -h</code> 得到更多的命令行参数说明。</p>
<p><code>nohup ~/gogs/gogs web &gt; /dev/null 2&gt;&amp;1 &amp;</code><br>启动gogs服务之后，首次运行会让你进行相关的配置。</p>
<p>主要分为3个配置项，</p>
<p>一是数据库的配置，包括数据库地址及密码；</p>
<p>二是服务的应用配置，包括域名，路径等等；</p>
<p>三是可选邮件服务和管理员配置。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p><a target="_blank" rel="noopener" href="https://gogs.io/docs/advanced/configuration_cheat_sheet">配置文件手册</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2017/08/12/h5ai%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/08/12/h5ai%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">h5ai使用教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-08-12 13:54:27" itemprop="dateCreated datePublished" datetime="2017-08-12T13:54:27+08:00">2017-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 18:59:39" itemprop="dateModified" datetime="2022-05-19T18:59:39+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是-h5ai"><a href="#什么是-h5ai" class="headerlink" title="什么是 h5ai"></a>什么是 h5ai</h1><p>H5ai是一款功能强大 php 文件目录列表程序，由德国开发者 Lars Jung 主导开发，它提供多种文件目录列表呈现方式，支持多种主流 Web 服务器，例如 Nginx、Apache、Cherokee、Lighttpd 等，支持多国语言，可以使用本程序在线预览文本、图片、音频、视频等。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="搭建Web服务"><a href="#搭建Web服务" class="headerlink" title="搭建Web服务"></a>搭建Web服务</h2><p>本文使用LNMP环境，使用教程到<a target="_blank" rel="noopener" href="https://lnmp.org/">LNMP</a>查看。<br>并创建一个新虚拟机。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>编辑Nginx主机文件和PHP配置文件，分别在<code>/usr/local/nginx/conf/vhost/</code>下和<code>/usr/local/php/etc/php.ini</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/vhost/your_domain.conf</span><br><span class="line"></span><br><span class="line">将index值修改为</span><br><span class="line">index _h5ai/public/index.php;</span><br><span class="line"></span><br><span class="line">vim /usr/local/php/etc/php.ini</span><br><span class="line">搜索 scandir、exec、passthru，将其从被禁用的函数中删除。</span><br></pre></td></tr></table></figure>

<h2 id="配置虚拟机空间"><a href="#配置虚拟机空间" class="headerlink" title="配置虚拟机空间"></a>配置虚拟机空间</h2><p>去到<a target="_blank" rel="noopener" href="https://larsjung.de/h5ai/">官网</a>下载<code>h5ai</code>，解压到虚拟机空间目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _h5ai</span><br><span class="line">│   ├── CHANGELOG.md</span><br><span class="line">│   ├── private</span><br><span class="line">│   ├── public</span><br><span class="line">│   └── README.md</span><br><span class="line">├── 您要显示的文件夹</span><br><span class="line">│   ├── 子文件夹1</span><br><span class="line">│   ├── 文件1</span><br><span class="line">│   └── 文件2</span><br><span class="line">└── 您要显示的文件夹</span><br><span class="line">├── 文件1</span><br><span class="line">└── 文件2</span><br></pre></td></tr></table></figure>

<h2 id="重启Web服务"><a href="#重启Web服务" class="headerlink" title="重启Web服务"></a>重启Web服务</h2><p>LNMP重启命令<code>lnmp restart</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------------------+</span><br><span class="line">|    Manager for LNMP, Written by Licess    |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">|              http://lnmp.org              |</span><br><span class="line">+-------------------------------------------+</span><br><span class="line">Stoping LNMP...</span><br><span class="line">Stoping nginx...  done</span><br><span class="line">[ ok ] Stopping mariadb (via systemctl): mariadb.service.</span><br><span class="line">Gracefully shutting down php-fpm . done</span><br><span class="line">Starting LNMP...</span><br><span class="line">Starting nginx...  done</span><br><span class="line">[ ok ] Starting mariadb (via systemctl): mariadb.service.</span><br><span class="line">Starting php-fpm  done</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://www.htcp.net/3643.html">云梦小站</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2017/07/20/BBR%E9%AD%94%E6%94%B9%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/07/20/BBR%E9%AD%94%E6%94%B9%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">BBR魔改版安装教程（转载）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-07-20 20:59:28" itemprop="dateCreated datePublished" datetime="2017-07-20T20:59:28+08:00">2017-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 18:57:10" itemprop="dateModified" datetime="2022-05-19T18:57:10+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近大佬 @Yankee 更新了一份 BBR魔改方案，使得BBR加速效果更明显了。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/07/20/BBR%E9%AD%94%E6%94%B9%E7%89%88%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2017/05/19/CentOS%E5%AE%89%E8%A3%85Docker-CE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/05/19/CentOS%E5%AE%89%E8%A3%85Docker-CE/" class="post-title-link" itemprop="url">CentOS安装Docker-CE</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-05-19 19:14:00" itemprop="dateCreated datePublished" datetime="2017-05-19T19:14:00+08:00">2017-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 19:15:12" itemprop="dateModified" datetime="2022-05-19T19:15:12+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>Docker 支持 64 位版本 CentOS 7&#x2F;8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine-selinux \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure>

<h1 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h1><p>执行以下命令安装依赖包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。<br>执行下面的命令添加 <code>yum</code> 软件源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">$ sudo  sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">\# 官方源</span><br><span class="line">\# $ sudo yum-config-manager \</span><br><span class="line">\# --add-repo \</span><br><span class="line">\# https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>如果需要测试版本的 Docker 请执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager --enable docker-ce-test</span><br></pre></td></tr></table></figure>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<h1 id="CentOS8-额外设置"><a href="#CentOS8-额外设置" class="headerlink" title="CentOS8 额外设置"></a>CentOS8 额外设置</h1><p>由于 CentOS8 防火墙使用了 <code>nftables</code>，但 Docker 尚未支持 <code>nftables</code>， 我们可以使用如下设置使用 <code>iptables</code>：</p>
<p>更改 <code>/etc/firewalld/firewalld.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\# FirewallBackend=nftables</span><br><span class="line">FirewallBackend=iptables</span><br></pre></td></tr></table></figure>
<p>或者执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --permanent --zone=trusted --add-interface=docker0</span><br><span class="line">$ firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h1 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h1><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p>
<blockquote>
<p>若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\# $ curl -fsSL test.docker.com -o get-docker.sh</span><br><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo  sh get-docker.sh --mirror Aliyun</span><br><span class="line">\# $ sudo sh get-docker.sh --mirror AzureChinaCloud</span><br></pre></td></tr></table></figure>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>
<h1 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h1 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h1><p>默认情况下，<code>docker</code> 命令会使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立 <code>docker</code> 组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo  groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入 <code>docker</code> 组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo  usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h1 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm hello-world</span><br><span class="line"></span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">b8dfde127a29: Pull complete</span><br><span class="line">Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>若能正常输出以上信息，则说明安装成功。</p>
<h1 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h1><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/install/mirror">国内镜像加速</a>。</p>
<h1 id="添加内核参数"><a href="#添加内核参数" class="headerlink" title="添加内核参数"></a>添加内核参数</h1><p>如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br></pre></td></tr></table></figure>
<p>请添加内核配置参数以启用这些功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo  tee -a /etc/sysctl.conf &lt;&lt;-EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>然后重新加载 <code>sysctl.conf</code> 即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo sysctl -p</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2017/04/20/%E8%BD%AC%E8%BD%BD-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/04/20/%E8%BD%AC%E8%BD%BD-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Git/" class="post-title-link" itemprop="url">[转载]深入浅出 Git</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-20 14:43:50" itemprop="dateCreated datePublished" datetime="2017-04-20T14:43:50+08:00">2017-04-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 18:58:56" itemprop="dateModified" datetime="2022-05-19T18:58:56+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文转载自<a target="_blank" rel="noopener" href="https://blog.coding.net/blog/git-from-the-inside-out">Coding</a></p>
<p>这篇文章解释了 Git 是如何工作的。（如果相关内容的谈话更吸引你，你可以观看链接中的<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fCtZWGhQBvo">视频</a>。）</p>
<p>本文假设你已经对 Git 理解到了可以对你的项目进行版本控制的程度。本文专注于支撑 Git 的图结构以及这些图的性质影响 Git 行为的方式。通过了解底层，你可以将你心中对 Git 的模型建立在事实之上，而不是基于通过积累使用经验而建立的假设上。这个更真实的模型可以让你更好的理解 Git 做了什么，正在做什么以及将要做什么。</p>
<p>本文由一系列针对单个项目的 Git 命令构成。时不时的，还将有一些对于 Git 所建立的图数据结构的观察。这些观察阐述了图的性质和相应性质所产生的影响。</p>
<p>读完本文后，如果你希望更深入的了解 Git，可以阅读我关于 Git 的 JavaScript 实现<a target="_blank" rel="noopener" href="http://gitlet.maryrosecook.com/docs/gitlet.html">gitlet.js(heavily annotated source code)</a>。</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ $ <span class="built_in">mkdir</span> alpha</span><br><span class="line">~ $ <span class="built_in">cd</span> alpha</span><br></pre></td></tr></table></figure>

<p>用户为项目建立一个名为 <code>alpha</code> 的目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">mkdir</span> data</span><br><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;a&#x27;</span> &gt; data/letter.txt</span><br></pre></td></tr></table></figure>

<p>进入目录 <code>alpha</code>，并在下面建立名为 <code>data</code> 的目录。在这个目录中建立一个名为 <code>letter.txt</code> 的文件，其中包含一个字符 <code>a</code>。此时目录结构看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha</span><br><span class="line">└── data</span><br><span class="line">    └── letter.txt</span><br></pre></td></tr></table></figure>


<h3 id="初始化版本库"><a href="#初始化版本库" class="headerlink" title="初始化版本库"></a>初始化版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git init</span><br><span class="line">          Initialized empty Git repository</span><br></pre></td></tr></table></figure>

<p><code>git init</code> 命令使得当前目录成为一个 Git 版本库。为此这条命令建立了一个名为的 <code>.git</code> 目录并且向其中写入了一些文件。这些文件定义和记录了关于Git配置和项目历史的所有相关内容。它们只是普通的文件，其中并没有什么类似魔法的神奇之处。用户可以使用文本编辑器和命令行阅读或编辑这些文件。也就是说：用户可以像获取和修改项目文件一样简单地获取和修改项目历史。</p>
<p>这时候目录 <code>alpha</code> 的结构看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alpha</span><br><span class="line">├── data</span><br><span class="line">|   └── letter.txt</span><br><span class="line">└── .git</span><br><span class="line">    ├── objects</span><br><span class="line">    etc...</span><br></pre></td></tr></table></figure>


<p><code>.git</code> 目录和其中的内容属于 Git。所有其他的文件一起被称为工作副本，属于用户。</p>
<h3 id="添加一些文件"><a href="#添加一些文件" class="headerlink" title="添加一些文件"></a>添加一些文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git add data/letter.txt</span><br></pre></td></tr></table></figure>

<p>用户对文件 <code>data/letter.txt</code> 运行命令 <code>git add</code>。这一操作产生两个效果。</p>
<p>首先，这一操作在目录 <code>.git/objects/</code> 新建一个BLOB（binary large object 二进制大对象）文件。</p>
<p>这个BLOB文件包含了文件 <code>data/letter.txt</code> 压缩过的内容。文件名由内容的散列值得到。散列一个文本片段，意味着对其内容运行一个程序将其转变为一段更短小[^1]并且唯一地[^2]代表原先文本的文本片段。例如，Git 将 <code>a</code> 散列为 <code>2e65efe2a145dda7ee51d1741299f848e5bf752e</code>。最前面的两个字符被用于对象数据库中目录的命名：<code>.git/objects/2e/</code>。散列值的其余部分被用于包含添加文件内容的BLOB文件的命名：<code>.git/objects/2e/65efe2a145dda7ee51d1741299f848e5bf752e</code>。</p>
<p>注意到将一个文件添加到 Git 中时 Git 是如何将文件的内容保存到 <code>objects</code> 目录中的。即便用户从工作副本中删除文件 <code>data/letter.txt</code> ，它的内容在 Git 库中也是安全的。</p>
<p>其次，<code>git add</code> 命令将文件添加到索引中。索引是一个包含所有 Git 所要跟踪文件的列表。它以文件 <code>.git/index</code> 保存。这个文件每一行建立起一个被跟踪文件与这个文件被添加时散列值的对应关系。这是在 <code>git add</code> 命令被执行之后的索引文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e</span><br></pre></td></tr></table></figure>

<p>用户建立一个叫做 <code>data/number.txt</code> 的文件，内容为  <code>1234</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;1234&#x27;</span> &gt; data/number.txt</span><br></pre></td></tr></table></figure>

<p>工作副本看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alpha</span><br><span class="line">└── data</span><br><span class="line">    └── letter.txt</span><br><span class="line">    └── number.txt</span><br></pre></td></tr></table></figure>

<p>用户将这个文件添加到 Git 中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git add data</span><br></pre></td></tr></table></figure>

<p>命令 <code>git add</code> 创建一个包含 <code>data/number.txt</code> 内容的BLOB文件。同时添加一条文件 <code>data/number.txt</code> 的索引项，指向对应的BLOB文件。在 <code>git add</code> 命令第二次被执行之后索引文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data/letter.txt 2e65efe2a145dda7ee51d1741299f848e5bf752e</span><br><span class="line">data/number.txt 274c0052dd5408f8ae2bc8440029ff67d79bc5c3</span><br></pre></td></tr></table></figure>

<p>注意到即便用户运行 <code>git add data</code>，也只有 <code>data</code> 目录中的文件在索引文件中被列出。文件夹 <code>data</code> 没有被单独列出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;1&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data</span><br></pre></td></tr></table></figure>

<p>当用户最初建立 <code>data/number.txt</code> 时，他想要写入 <code>1</code>，而不是 <code>1234</code>。用户做了更改并且将文件添加到索引中。这次的命令创建了一个新的包含了新内容的BLOB文件。并且更新了文件 <code>data/number.txt</code> 的索引项指向新的BLOB文件。</p>
<h3 id="进行一次提交"><a href="#进行一次提交" class="headerlink" title="进行一次提交"></a>进行一次提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git commit -m <span class="string">&#x27;a1&#x27;</span></span><br><span class="line">          [master (root-commit) 774b54a] a1</span><br></pre></td></tr></table></figure>

<p>用户做提交  <code>a1</code>。Git 显示出一些有关此次提交的数据。很快我们将看懂这些信息。</p>
<p>提交命令分三步执行。首先，命令建立了一个树图来表示被提交的项目版本的内容。其次，建立一个提交对象。最后，将当前分支指向新的提交对象。</p>
<h4 id="创建一个树图"><a href="#创建一个树图" class="headerlink" title="创建一个树图"></a>创建一个树图</h4><p>Git 通过从索引建立一张树图来记录项目的当前状态。这张树图记录了项目中每一个文件的位置和内容。</p>
<p>图由两种对象组成：BLOB 文件和树。</p>
<p>BLOB 文件由 <code>git add</code> 存储。它们表示了文件的内容。</p>
<p>树是在提交被进行时被存储的。树表示了工作副本中的目录。</p>
<p>下面就是记录新提交中 <code>data</code> 目录内容的树对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt</span><br><span class="line">100664 blob 56a6051ca2b02b04ef92d5150c9ef600403cb1de number.txt</span><br></pre></td></tr></table></figure>

<p>第一行记录了再现 <code>data/letter.txt</code> 文件所需的一切内容。第一部分表明文件权限。第二部分表明此项内容由BLOB文件表示而不是一个树对象。第三个部分表明对应BLOB的散列值。第四部分表明文件名。</p>
<p>第二行记录了关于 <code>data/number.txt</code> 文件的相同内容。</p>
<p>下面是代表 <code>alpha</code> 的树对象，即项目的根目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">040000 tree 0eed1217a2947f4930583229987d90fe5e8e0b74 data</span><br></pre></td></tr></table></figure>

<p>树中只有一行并指向 <code>data</code> 树。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/6efd8832-4718-4991-894c-ccf2b8033934.png" alt="Tree graph for the `a1` commit"><br><code>a1</code> 提交的树图</p>
<p>在上面的图中，<code>root</code> 树指向 <code>data</code> 树。<code>data</code> 树指向 <code>data/letter.txt</code> 和 <code>data/number.txt</code> 对应的BLOB文件。</p>
<h4 id="创建一个提交对象"><a href="#创建一个提交对象" class="headerlink" title="创建一个提交对象"></a>创建一个提交对象</h4><p><code>git commit</code> 在创建树图之后创建一个提交对象。提交对象是 <code>.git/objects/</code> 目录中另一个文本文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tree ffe298c3ce8bb07326f888907996eaa48d266db4</span><br><span class="line">author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500</span><br><span class="line">committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424798436 -0500</span><br><span class="line"></span><br><span class="line">a1</span><br></pre></td></tr></table></figure>

<p>第一行指向树图。散列值对应于代表工作副本根目录的树图，这里是 <code>alpha</code> 目录。最后一行是提交信息。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/7d68fb36-f3ee-4758-9fc7-4ac05acddfd6.png" alt="`a1` commit object pointing at its tree graph"><br><code>a1</code> 提交对象指向它的树图</p>
<h4 id="将当前分支指向新提交"><a href="#将当前分支指向新提交" class="headerlink" title="将当前分支指向新提交"></a>将当前分支指向新提交</h4><p>最后，提交命令将当前分支指向新的提交对象。</p>
<p>哪一个分支是当前分支？Git 在 <code>.git/HEAD</code> 目录中的 <code>HEAD</code> 文件中寻找相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>

<p>这代表 <code>HEAD</code> 指向 <code>master</code>。<code>master</code> 分支是当前分支。</p>
<p><code>HEAD</code> 和 <code>master</code> 都是引用。引用是 Git 或用户用来标识特定分支的标签。</p>
<p>代表 <code>master</code> 分支的引用并不存在，因为这是版本库的第一次提交。Git 在路径 <code>.git/refs/heads/master</code> 创建文件并且将内容写为提交对象的散列值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">74ac3ad9cde0b265d2b4f1c778b283a6e2ffbafd</span><br></pre></td></tr></table></figure>

<p>（如果你在 Git 中输入你所读到的命令，<code>a1</code> 提交的散列值将与我这里的不同。内容对象例如 BLOB 文件和树总是散列到与本文相同的值上。提交对象并不如此，因为其中包含日期和创建者的名字。）</p>
<p>让我们将 <code>HEAD</code> 和 <code>master</code> 添加到 Git 图中：</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/27f03915-321e-41a2-b92a-b635fcbd9163.png" alt="`master` pointing at the `a1` commit"><br><code>HEAD</code> 指向 <code>master</code> 并且 <code>master</code> 指向 <code>a1</code> 提交</p>
<p><code>HEAD</code> 指向 <code>master</code>，如提交之前一样。但是现在 <code>master</code> 开始存在并且指向新的提交对象。</p>
<h3 id="创建一个非首次提交"><a href="#创建一个非首次提交" class="headerlink" title="创建一个非首次提交"></a>创建一个非首次提交</h3><p>下面是 <code>a1</code> 提交之后的 Git 图。其中包括了工作拷贝和索引。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/09deae62-96aa-428e-b5af-2cf117ec2b53.png" alt="包含工作拷贝和索引的 `a1` 提交"><br>包含工作拷贝和索引的 <code>a1</code> 提交</p>
<p>注意，工作拷贝，索引以及 <code>a1</code> 提交中的 <code>data/letter.txt</code> 和 <code>data/number.txt</code> 文件内容是一样的。索引和 <code>HEAD</code> 提交的散列值都指向的都是 BLOB 对象，但是工作拷贝的内容是作文文本文件存放在不同的地方的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;2&#x27;</span> &gt; data/number.txt</span><br></pre></td></tr></table></figure>

<p>用户将 <code>data/number.txt</code> 的内容设置为 <code>2</code>。该操作更新了工作拷贝，但是没有改变 <code>HEAD</code> 提交以及索引。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/b4e3ea85-a1e8-4123-b4ed-52a4d0b10111.png" alt="工作拷贝中的 `data/number.txt` 设置为 2"><br>工作拷贝中的 <code>data/number.txt</code> 设置为 2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git add data/number.txt</span><br></pre></td></tr></table></figure>

<p>用户将文件添加到 Git。该操作在 <code>object</code> 目录中创建了一个内容为 <code>2</code> 的 BLOB 文件。在新的 BLOB 文件中添加了一条指向 <code>data/number.txt</code> 的索引项。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/6940968e-14ee-48ea-ac52-400a2daddb2e.png" alt="工作拷贝和索引中的 `data/number.txt` 设置为 2"><br>工作拷贝和索引中的 <code>data/number.txt</code> 设置为 2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git commit -m <span class="string">&#x27;a2&#x27;</span></span><br><span class="line">          [master f0af7e6] a2</span><br></pre></td></tr></table></figure>

<p>用户提交。步骤同上。</p>
<p>第一步，创建了一个代表索引内容的树图。</p>
<p><code>data/number</code> 的索引项发生了改变。旧的 <code>data</code> 树不能再反映当前的 <code>data</code> 目录的索引状态。所以必须创建一个一个新的 <code>data</code> 树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100664 blob 2e65efe2a145dda7ee51d1741299f848e5bf752e letter.txt</span><br><span class="line">100664 blob d8263ee9860594d2806b0dfd1bfd17528b0ba2a4 number.txt</span><br></pre></td></tr></table></figure>

<p>新的 <code>data</code> 树与旧的 <code>data</code> 树散列值不同。必须创建一个新的 <code>root</code> 树来记录当前散列值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">040000 tree 40b0318811470aaacc577485777d7a6780e51f0b data</span><br></pre></td></tr></table></figure>

<p>第二步，创建一个新的提交对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tree ce72afb5ff229a39f6cce47b00d1b0ed60fe3556</span><br><span class="line">parent 774b54a193d6cfdd081e581a007d2e11f784b9fe</span><br><span class="line">author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500</span><br><span class="line">committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1424813101 -0500</span><br><span class="line"></span><br><span class="line">a2</span><br></pre></td></tr></table></figure>

<p>提交对象的第一行指向了新的 <code>tree</code> 对象。第二行指向 <code>a1</code> 提交：当前提交的父提交。要找到父提交，Git 首先找到头指针 <code>HEAD</code>，然后顺着找到 <code>master</code> 然后获得 <code>a1</code> 提交的散列值。</p>
<p>第三步，将 <code>master</code> 分支文件的内容设置为新提交的散列值。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/52fe0759-8197-4241-806b-c93865dc45e2.png" alt="`a2` 提交"><br><code>a2</code> 提交</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/528d1d9e-9fd9-4ccc-8080-666cf3ddf7ce.png" alt="不包括工作拷贝和索引的 Git 图"><br>不包括工作拷贝和索引的 Git 图</p>
<p><strong>图属性</strong>： 内容被储存为一个树对象。这表明只有差异被储存在对象数据库中。从上图可以看出。<code>a2</code> 提交重复使用了在 <code>a1</code> 提交之前创建的 <code>a</code> BLOB 文件。类似的，如果整个工作目录的内容在一次次提交中没有发生改变，树对象以及所有的 BLOB 文件都能够被重复使用。通常来说，各次提交之间只有很小的改动。这也就意味着 Git 能够使用很小的空间来储存大量的提交历史。</p>
<p><strong>图属性</strong>：每个提交都有一个父提交，也就是说仓库可以储存项目的历史改动。</p>
<p><strong>图属性</strong>：引用（refrences 或者 refs，译者注）是指向一部分提交历史或者其他的条目。也就是说可以给提交取一个有意义的名字。用户将它们的工作组织成单行的固定短语，比如 <code>fix-for-bug-376</code>。Git 使用了一些像 <code>HEAD</code>，<code>MERGE_HEAD</code> 和 <code>FETCH_HEAD</code> 的符号引用来支持一些用来处理提交历史的命令。</p>
<p><strong>图属性</strong>：<code>objects/</code> 目录中的节点都是不可变的。也就是说其中的内容能编辑但是不能删除。你添加到仓库中的所有内容以及你所做的每一个提交都存放在 <code>objects</code> 目录[^3]中的某个地方.</p>
<p><strong>图属性</strong>：引用是可变的。因此，可以改变一个引用的意义。<code>master</code> 所指向的提交可能是当前项目的最好的版本，但是过段时间，它将会被一个更新的或者更好的提交所取代。</p>
<p><strong>图属性</strong>：由引用所指向的工作拷贝以及提交很容易获取，但是获取其他的引用就不那么简单了。也就是说调出最近的提交历史更加容易，但是那也会时常会改变。</p>
<p>工作拷贝是最容易在历史提交中调出的，因为它是仓库的根节点。调出它甚至不需要执行 Git 命令。同时它也是提交历史中的最早的永久节点。用户可以创建一个文件的许多版本，但是如果没有对它们执行 <code>add</code> 操作的话，Git 将不会记录它们。</p>
<p>头指针 <code>HEAD</code> 所指向的提交很容易被调出。它在检出分支的顶端。要查看其中的内容，用户只需执行 stash[^4] 然后检出工作拷贝。同时，<code>HEAD</code> 改变频率最高的引用。</p>
<p>有固定引用指向的提交很容易被调出。用户可以轻易的检出那个分支。分支的顶端通常没有 <code>HEAD</code> 的改变频率高，but often enough for the meaning of a branch name to be changeable.</p>
<p>要调出没有被任何引用所指向的提交很困难。用户在某个引用上提交得越多，操作之前的提交就越不容易。但我们通常很少操作很久之前的提交[^5]。</p>
<h3 id="检出一个提交"><a href="#检出一个提交" class="headerlink" title="检出一个提交"></a>检出一个提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout 37888c2</span><br><span class="line">          You are <span class="keyword">in</span> <span class="string">&#x27;detached HEAD&#x27;</span> state...</span><br></pre></td></tr></table></figure>

<p>用户通过对应的散列值来检出 <code>a2</code> 提交。（你过你照搬了以上的 Git 命令，在你的电脑上不会起作用。请使用 <code>git log</code> 命令来查找 <code>a2</code> 提交的散列值。）</p>
<p>检出有以下 4 个步骤。</p>
<p>第一步，Git 获得 <code>a2</code> 提交以及其指向的树图。<br>工作区的内容已经和树图保持一致了，因为我们的HEAD之前就已经通过master指向a2提交了。</p>
<p>第二步，将树图中的文件写入工作拷贝中。这不会产生什么变化。工作拷贝的内容已经和树图中的保持一致了，因为头指针 <code>HEAD</code> 早已经通过 <code>master</code> 指向了 <code>a2</code> 提交。</p>
<p>第三步，Git 将树图中的文件写入索引。同样，这也不会产生什么变化，index 早就有 <code>a2</code> 提交的内容了。</p>
<p>第四步，头指针 <code>HEAD</code> 的内容被设置为 <code>a2</code> 提交的散列值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f0af7e62679e144bb28c627ee3e8f7bdb235eee9</span><br></pre></td></tr></table></figure>

<p>对 <code>HEAD</code> 写入一个散列值会导致仓库进入头指针分离状态。注意下图中的 <code>HEAD</code> 直接指向了 <code>a2</code> 提交，而不是指向 <code>master</code>。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/dfee80a2-f92b-48e8-a457-50d7e1e910b9.png" alt="分离头指针到 `a2` 提交"><br>分离头指针到 <code>a2</code> 提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;3&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m <span class="string">&#x27;a3&#x27;</span></span><br><span class="line">          [detached HEAD 3645a0e] a3</span><br></pre></td></tr></table></figure>

<p>用户将 <code>data/number.txt</code> 的值设置为 <code>3</code> 然后提交更改。Git 找到 <code>HEAD</code> 然后找到 <code>a3</code> 提交的父提交。这回返回 <code>a2</code> 提交的散列值而不是查找一个分支引用。</p>
<p>Git 将 <code>HEAD</code> 更新，使其直接指向 <code>a3</code> 提交的哈希值。此时仓库仍然处于头指针分离状态，而没有在一个分支上，因为没有引用指向 <code>a3</code> 提交亦或是它之后的提交。这意味着它很容易丢失。</p>
<p>从现在起，图示中大多的树和 BLOB 都会省略。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/ce4fb585-537b-4a50-baf5-e4edc4fea7fc.png" alt="没有在分支上的 `a3` 提交"><br>没有在分支上的 <code>a3</code> 提交</p>
<h3 id="创建一个分支"><a href="#创建一个分支" class="headerlink" title="创建一个分支"></a>创建一个分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git branch deputy</span><br></pre></td></tr></table></figure>

<p>用户创建了一个新的叫做 <code>deputy</code> 的分支。这个操作在 <code>.git/refs/heads/deputy</code> 目录下创建了新文件，其包含了 <code>HEAD</code> 指向的散列值：<code>a3</code> 提交的散列值。</p>
<p><strong>图属性</strong>：分支其实就是引用，而引用其实就是文件。这也就是说 Git 的分支是很轻量的。</p>
<p>创建 <code>deputy</code> 分支的操作实际上将新的 <code>a3</code> 提交安全地放在了一个新的分支上。<code>HEAD</code> 指针目前仍处于分离状态，因为它现在仍是直接指向了一个提交。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/cd28055d-823d-4774-acaa-e0226c25b748.png" alt="处于 `deputy` 分支的 `a3` 提交"><br>处于 <code>deputy</code> 分支的 <code>a3</code> 提交</p>
<h3 id="检出分支"><a href="#检出分支" class="headerlink" title="检出分支"></a>检出分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">		  ---</span><br><span class="line">          检出<span class="string">&#x27;master&#x27;</span>分支</span><br></pre></td></tr></table></figure>

<p>用户检出了’master’分支</p>
<p>首先, Git 找到’master’分支所指向的<code>a2</code>提交对象并获取该提交对象所指向的树对象.</p>
<p>接下来 Git 会将树对象储存的文件写到当前工作副本中, 该操作将覆写<code>data/number.txt</code>为<code>2</code>.</p>
<p>第三步, Git 将树对象中的文件入口写入 index, <code>data/number.txt</code>的文件入口将会被更新为<code>2</code> blob 的 hash 值</p>
<p>最后 Git 通过将<code>HEAD</code>中的 hash 值替换为如下内容来使<code>HEAD</code>指向<code>master</code>分支:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-coding-net-production-pp.qbox.me/811ef648-b184-4fb2-8aca-566fc4b5d88f.png" alt="`master`分支被检出, 指向&#39;a2&#39;提交"><br><code>master</code>分支被检出, 指向’a2’提交</p>
<h3 id="检出与当前工作副本相冲突的分支"><a href="#检出与当前工作副本相冲突的分支" class="headerlink" title="检出与当前工作副本相冲突的分支"></a>检出与当前工作副本相冲突的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;789&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Your changes to these files would be overwritten</span><br><span class="line">          by checkout:</span><br><span class="line">            data/number.txt</span><br><span class="line">          Commit your changes or stash them before you</span><br><span class="line">          switch branches.</span><br><span class="line">          ---</span><br><span class="line">	      对以下文件做出的更改将在检出中被覆盖:</span><br><span class="line">		      data/number.txt</span><br><span class="line">		  请在检出前将这些更改提交或储藏.</span><br></pre></td></tr></table></figure>

<p>用户无意中将<code>data/number.txt</code>的内容更改为<code>789</code>, 此时他尝试检出<code>deputy</code>分支, Git 没有执行这次检出.</p>
<p>当前<code>HEAD</code>指向 <code>master</code>分支, 其所指向提交<code>a2</code>中<code>data/number.txt</code>的内容为<code>2</code>. <code>deputy</code>分支指向的提交<code>a3</code>中<code>data/number.txt</code>的内容为<code>3</code>. 当前工作副本中<code>data/number.txt</code>的内容为<code>789</code>. 这个文件的各个版本各不相同, 必须通过一种方法来消除这些差异.</p>
<p>如果 Git 将当前版本的<code>data/number.txt</code>替换成将要检出的分支中的版本则会造成数据遗失, Git 不允许这种情况发生.</p>
<p>如果 Git 将要检出的分支与当前工作副本合并则会导致冲突</p>
<p>因此 Git 中断了此次检出.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;2&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Switched to branch <span class="string">&#x27;deputy&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用户注意到了对<code>data/number.txt</code>的意外操作, 在把它的内容修改回<code>2</code>后成功检出了<code>deputy</code>分支.</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/8ce57f10-b904-499d-8d52-8a7c62c67665.png" alt="`deputy` 分支被检出"><br><code>deputy</code> 分支被检出</p>
<h3 id="合并一个祖先分支"><a href="#合并一个祖先分支" class="headerlink" title="合并一个祖先分支"></a>合并一个祖先分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge master</span><br><span class="line">          Already up-to-date.</span><br></pre></td></tr></table></figure>

<p>用户将<code>master</code>分支合并到<code>deputy</code>中. 合并两个分支其本质为合并两个提交对象. 其一－作为接受者(receiver)－是<code>deputy</code>所指向的提交对象, 其二－作为给予者(giver)－是<code>master</code>所指向的提交对象. 在这次合并中 Git 不会执行任何操作, 而仅仅打印出<code>Already up-to-date.</code>.</p>
<p><strong>[图属性]</strong>: 图示中的一系列提交对象可以被认为是对仓库内容进行的一些列更改. 因此在一次合并当中, 若想要并入的分支是当前分支的祖先分支, Git不会执行任何操作, 因为想要并入分支中的改动已经被包含在了当前分支中.</p>
<h3 id="合并后代提交"><a href="#合并后代提交" class="headerlink" title="合并后代提交"></a>合并后代提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用户检出了 <code>master</code> 分支.</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/ee137c5c-9d93-4728-8c97-fc97bb92b68b.png" alt="`master` checked out and pointing at the `a2` commit"><br><code>master</code> 被检出并指向了 <code>a2</code> 提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge deputy</span><br><span class="line">          Fast-forward</span><br></pre></td></tr></table></figure>

<p>他们合并 <code>deputy</code> 分支到 <code>master</code>。Git 发现赠予提交的 <code>a2</code> 是源提交 <code>a3</code> 的祖先提交。这里可以执行 fast-forward 合并。</p>
<p>Git 获取赠予提交和它指向的树图，将树图中的文件写入工作区和 index。这将 <code>master</code> 分支 <code>fast-forward</code> 到了 <code>a3</code> 提交。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/01295a6a-4605-4d2f-8e42-1fbf83b4cd86.png" alt="`a3` commit from `deputy` fast-forward merged into `master`"><br><code>deputy</code> 分支的 <code>a3</code> 提交 fast-forward 合并到了 <code>master</code> 分支</p>
<p><strong>图属性</strong>：图中的提交系列被视为对仓库内容的一系列更改。这意味着，如果赠予提交是接收提交的后代提交，提交历史不会变。已经存在一序列提交来描述赠予提交和接收提交之间的变化。但是尽管 Git 历史不变，Git 的状态图是会改变的。<code>HEAD</code> 指向的具体引用会更新以指向赠予提交。</p>
<h3 id="合并不同提交线的两个提交"><a href="#合并不同提交线的两个提交" class="headerlink" title="合并不同提交线的两个提交"></a>合并不同提交线的两个提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;4&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m <span class="string">&#x27;a4&#x27;</span></span><br><span class="line">          [master 7b7bd9a] a4</span><br></pre></td></tr></table></figure>

<p>用户将文件  <code>number.txt</code>  的内容改为 <code>4</code>  然后提交到  <code>master</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Switched to branch <span class="string">&#x27;deputy&#x27;</span></span><br><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;b&#x27;</span> &gt; data/letter.txt</span><br><span class="line">~/alpha $ git add data/letter.txt</span><br><span class="line">~/alpha $ git commit -m <span class="string">&#x27;b3&#x27;</span></span><br><span class="line">          [deputy 982dffb] b3</span><br></pre></td></tr></table></figure>

<p>用户检出  <code>deputy</code> 分支，将文件  <code>data/letter.txt</code>  内容改为  <code>b</code> 然后提交到  <code>deputy</code> 分支。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/80719b96-0028-4998-810e-cb5ab96c3f12.png" alt="`a4` committed to `master`, `b3` committed to `deputy` and `deputy` checked out"><br><code>a4</code> 提交到 <code>master</code>, <code>b3</code> 提交到 <code>deputy</code> ， <code>deputy</code> 被检出</p>
<p><strong>图属性</strong>: 多个提交可以共用一个父提交，这意味着新提交线可以在提交历史里创建出来。</p>
<p><strong>图属性</strong>: 某提交可以有多个父提交，这意味着两个不同的提交线可以被一个合并提交来合并。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge master -m <span class="string">&#x27;b4&#x27;</span></span><br><span class="line">          Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br></pre></td></tr></table></figure>

<p>用户合并 <code>master</code> 到 <code>deputy</code>.</p>
<p>Git 发现接收提交 <code>b3</code>和赠予提交 <code>a4</code>在不同的提交线上。它创建了一个合并提交。这个过程总共分八步。</p>
<p>第一步，Git 将接收提交的哈希值写入文件 <code>alpha/.git/MERGE_HEAD</code>。此文件的存在说明 Git 正在做合并操作。</p>
<p>第二步，Git 查找基提交：即接收提交和赠予提交共有的一个最近父提交。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/4eb43dad-cf0c-4281-8e4c-e9e1b7a797da.png" alt="`a3`, the base commit of `a4` and `b3`"><br><code>a3</code> 是  <code>a4</code>  和  <code>b3</code> 的基提交</p>
<p>图属性：每个提交都有一个父提交。这意味着我们可以发现两个提交线分开自哪个提交。Git 查找 <code>b3</code> 和 <code>a4</code> 的所有祖先提交，发现了最近的公共父提交 <code>a3</code>，即为他们的基提交。</p>
<p>第三步，Git 为基提交、接收提交和赠予提交创建索引。</p>
<p>第四步，Git 产生接收提交和赠予提交相对于基提交的 diff，此处的 diff 是一个文件路径列表，指向一个变化：包括添加、移除、修改或冲突。</p>
<p>Git 获取基提交、接收提交和赠予提交的文件列表，针对每一个文件，通过对比 index 来判断它的状态与写入变更。它将对应条目写入 diff。在这个例子中，diff 包含两个条目。</p>
<p>第一项记录 <code>data/letter.txt</code> 的状态。该文件内容分别是基提交中的  <code>a</code> 、接收提交中的<code>b</code>和赠予提交中的<code>a</code>。文件内容在基提交和接收提交不同，但在基提交和赠予提交相同。Git 发现文件内容被接收提交修改了，而不是在赠予提交中。<code>data/letter.txt</code> 的状态是修改，而不是冲突。</p>
<p>第二项记录 <code>data/number.txt</code> 的变更。在这个例子中，该文件内容在基提交和接收提交中是相同的，但在基提交和赠予提交是不同的。 <code>data/number.txt</code> 条目的状态也是修改。</p>
<p><strong>图属性</strong>：查找一个合并操作的基提交是可行的。这意味着，如果基提交中的一个文件只在接收提交或赠予提交做了修改，Git 可以自动除了合并文件，这样就减少了用户的工作量。</p>
<p>第五步，Git 将差异中的项被应用到工作区。<code>data/letter.txt</code> 内容被修改为<code>b</code>，<code>data/number.txt</code> 内容被修改为 <code>4</code>。</p>
<p>第六步，Git 将差异中的项应用到 index。<code>data/letter.txt</code> 会指向内容为 <code>b</code> 的 blob，<code>data/number.txt</code> 会指向内容为 <code>4</code> 的 blob。</p>
<p>第七步，更新后的 index 被提交：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree 20294508aea3fb6f05fcc49adaecc2e6d60f7e7d</span><br><span class="line">parent 982dffb20f8d6a25a8554cc8d765fb9f3ff1333b</span><br><span class="line">parent 7b7bd9a5253f47360d5787095afc5ba56591bfe7</span><br><span class="line">author Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500</span><br><span class="line">committer Mary Rose Cook &lt;mary@maryrosecook.com&gt; 1425596551 -0500</span><br><span class="line"></span><br><span class="line">b4</span><br></pre></td></tr></table></figure>

<p>注意，这个提交有两个父提交。</p>
<p>第八步，Git 将当前分支 <code>deputy</code> 指向新提交。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/d0fed804-09e8-4783-a54e-a90dfc2a0af5.png" alt="`b4`, the merge commit resulting from the recursive merge of `a4` into `b3`"><br> <code>a4</code>递归合并入 <code>b3</code> 产生 <code>b4</code></p>
<h3 id="合并不同提交线且有相同修改文件的两个提交"><a href="#合并不同提交线且有相同修改文件的两个提交" class="headerlink" title="合并不同提交线且有相同修改文件的两个提交"></a>合并不同提交线且有相同修改文件的两个提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">~/alpha $ git merge deputy</span><br><span class="line">          Fast-forward</span><br></pre></td></tr></table></figure>

<p>用户检出 <code>master</code>，他们将 <code>deputy</code> 合并到 <code>master</code>。此操作将<code>master</code> fast-forwards 指向 <code>b4</code>。<code>master</code> 和 <code>deputy</code> 现指向了相同的提交。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/5465bf93-07a3-46bf-8adb-85f562ed1cc5.png" alt="`deputy` merged into `master` to bring `master` up to the latest commit, `b4`"><br><code>deputy</code> 合并到 <code>master</code> 将 <code>master</code> 更新到新提交 <code>b4</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout deputy</span><br><span class="line">          Switched to branch <span class="string">&#x27;deputy&#x27;</span></span><br><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;5&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m <span class="string">&#x27;b5&#x27;</span></span><br><span class="line">          [deputy bd797c2] b5</span><br></pre></td></tr></table></figure>

<p>用户检出 <code>deputy</code>。将 <code>data/number.txt</code> 内容修改为 <code>5</code>并提交到 <code>deputy</code>  分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git checkout master</span><br><span class="line">          Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;6&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m <span class="string">&#x27;b6&#x27;</span></span><br><span class="line">          [master 4c3ce18] b6</span><br></pre></td></tr></table></figure>

<p>用户检出 <code>master</code>。将 <code>data/number.txt</code> 内容修改为 <code>6</code> 并提交到 <code>master</code> 分支。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/eefd5217-39cd-4847-89f0-029cdde0d2fc.png" alt="`b5` commit on `deputy` and `b6` commit on `master`"><br><code>b5</code> 提交在 <code>deputy</code>   <code>b6</code> 提交在 <code>master</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge deputy</span><br><span class="line">          CONFLICT <span class="keyword">in</span> data/number.txt</span><br><span class="line">          Automatic merge failed; fix conflicts and</span><br><span class="line">          commit the result.</span><br></pre></td></tr></table></figure>

<p>用户将 <code>deputy</code> 合并到 <code>master</code>。这里存在冲突故合并中止。对于有冲突的合并操作，执行步骤和没有冲突的合并的前六步是相同的：设置 <code>.git/MERGE_HEAD</code>，查找基提交，创建基提交、接收提交和赠予提交的索引，生成 diff，更新工作区，更新 index。由于冲突，第七步提交和第八步更新 ref 不再执行。让我们再来看看这些步骤，观察到底发生了什么。</p>
<p>第一步，Git 将赠予提交的哈希值写入 <code>.git/MERGE_HEAD</code>.</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/3d00a7b8-b5a7-4afc-8d57-e464ab4abab7.png" alt="`MERGE_HEAD` written during merge of `b5` into `b6`"><br><code>MERGE_HEAD</code> 写入在 <code>b5</code> 合并入 <code>b6</code></p>
<p>第二步，Git 查找到基提交, <code>b4</code>.</p>
<p>第三步，Git 创建基提交、接收提交和赠予提交的索引。</p>
<p>第四步，Git 生成集合了接收提交和赠予提交相对于基提交的差异列表，这个 diff 是一份指向变更的文件路径：添加、删除、修改或冲突。</p>
<p>在本例中，差异列表仅包含一项： <code>data/number.txt</code>。它的状态被标为冲突因为其内容在接收提交，赠予提交和基提交中都是变化的。</p>
<p>第五步，差异列表中的文件被写入工作区。对于冲突的部分，Git 将两个版本都写入工作区的文件中。<code>data/number.txt</code>  的内容被变更为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">6</span><br><span class="line">=======</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; deputy</span><br></pre></td></tr></table></figure>

<p>第六步，差异列表中的文件被写入 index。index 中的项被文件路径和 stage 的组合唯一标识。没有冲突的项 stage 为 <code>0</code>。在该合并前，index 看起来像下面的样子，标有 <code>0</code> 的是 stage 值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748</span><br><span class="line">0 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb</span><br></pre></td></tr></table></figure>

<p>在合并 diff 写入 index 后，index 变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748</span><br><span class="line">1 data/number.txt bf0d87ab1b2b0ec1a11a3973d2845b42413d9767</span><br><span class="line">2 data/number.txt 62f9457511f879886bb7728c986fe10b0ece6bcb</span><br><span class="line">3 data/number.txt 7813681f5b41c028345ca62a2be376bae70b7f61</span><br></pre></td></tr></table></figure>

<p>stage <code>0</code> 的 <code>data/letter.txt</code> 项和合并前是一样的。stage <code>0</code> 的 <code>data/number.txt</code> 项已经不存在，取代的是三个新项。stage <code>1</code> 的项包含该文件在基提交中内容的哈希值，stage <code>2</code> 包含接收提交的哈希值，stage <code>3</code>包含赠予提交的哈希值。这三项表明文件 <code>data/number.txt</code> 存在冲突。</p>
<p>合并中止了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;11&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br></pre></td></tr></table></figure>

<p>用户通过将 <code>data/number.txt</code> 的内容修改为 <code>11</code>将两个有冲突的文件合并，将文件添加到 index，Git 创建一个包含<code>11</code> 的 blob，创建一个冲突文件以告诉 Git 冲突已经解决了。Git 移除 index 中的 <code>1</code>, <code>2</code> 和 <code>3</code>，并添加 stage 为 <code>0</code> 的 <code>data/number.txt</code> 项，该项指向新创建 blob 的哈希值。现在 index 变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 data/letter.txt 63d8dbd40c23542e740659a7168a0ce3138ea748</span><br><span class="line">0 data/number.txt 9d607966b721abde8931ddd052181fae905db503</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git commit -m <span class="string">&#x27;b11&#x27;</span></span><br><span class="line">          [master 251a513] b11</span><br></pre></td></tr></table></figure>

<p>第七步，用户进行提交。Git 发现存在 <code>.git/MERGE_HEAD</code>，意味着合并还在进行中。通过检查 index 发现没有冲突。它创建了一个新提交 <code>b11</code>，用来记录合并后的内容。然后删除 <code>.git/MERGE_HEAD</code>。合并完成。</p>
<p>第八步，Git 将当前分支 master 指向新提交。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/143f5225-385c-4d0a-bbaa-210d1a133dd5.png" alt="`b11`, the merge commit resulting from the conflicted, recursive merge of `b5` into `b6`"><br> <code>b5</code> 和 <code>b6</code>递归合并为<code>b11</code>  </p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>这幅 Git 示意图包含对于最后一次提交的历史提交、树对象、储存对象、工作副本以及索引。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/dde3e6e1-5cc4-427a-a70f-bca0da91588b.png" alt="The working copy, index, `b11` commit and its tree graph"><br>工作副本、索引， <code>b11</code> 提交以及它的树对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git <span class="built_in">rm</span> data/letter.txt</span><br><span class="line">          <span class="built_in">rm</span> <span class="string">&#x27;data/letter.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<p>该用户告诉 Git 删除 <code>data/letter.txt</code>。 文件将从工作副本中删除，该文件的入口也将从索引中消失。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/6d9794f4-8374-4092-b1a8-a7bc88efe95b.png" alt="After `data/letter.txt` `rm`ed from working copy and index"><br>After <code>data/letter.txt</code> <code>rm</code>ed from working copy and index<br> <code>data/letter.txt</code> 从工作副本以及索引中 <code>rm</code> 过后</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git commit -m <span class="string">&#x27;11&#x27;</span></span><br><span class="line">          [master d14c7d2] 11</span><br></pre></td></tr></table></figure>

<p>该用户进行提交了。 一般说来，Git 会在提交时构建一张树图代表索引内容，<code>data/letter.txt</code> 并不会出现在树中，因为它不在索引里。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/ecc82701-37fd-4509-b300-7e9199d7a511.png" alt="`11` commit made after `data/letter.txt` `rm`ed"><br><code>data/letter.txt</code> 删除后进行 <code>11</code> 提交</p>
<h3 id="复制一个库"><a href="#复制一个库" class="headerlink" title="复制一个库"></a>复制一个库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">cd</span> ..</span><br><span class="line">      ~ $ <span class="built_in">cp</span> -R alpha bravo</span><br></pre></td></tr></table></figure>

<p>用户复制 <code>alpha/</code> 库中的内容到 <code>bravo/</code> 目录中，使得目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~</span><br><span class="line">├── alpha</span><br><span class="line">|   └── data</span><br><span class="line">|       └── number.txt</span><br><span class="line">└── bravo</span><br><span class="line">    └── data</span><br><span class="line">        └── number.txt</span><br></pre></td></tr></table></figure>

<p><code>bravo</code> 目录即生成另一张 Git 图：</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/43030a5c-7727-4be4-a406-07bbb392256c.png" alt="New graph created when `alpha` `cp`ed to `bravo`"><br>当 <code>alpha</code> <code>cp</code> 至 <code>bravo</code> 后产生的新图</p>
<h3 id="链接至另一个库"><a href="#链接至另一个库" class="headerlink" title="链接至另一个库"></a>链接至另一个库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      ~ $ <span class="built_in">cd</span> alpha</span><br><span class="line">~/alpha $ git remote add bravo ../bravo</span><br></pre></td></tr></table></figure>

<p>用户回到 <code>alpha</code> 库中，设置 <code>bravo</code> 为一个 <code>alpha</code> 的远程库，这会使 <code>alpha/.git/config</code> 多了这几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[remote &quot;bravo&quot;]</span><br><span class="line">	url = ../bravo/</span><br></pre></td></tr></table></figure>

<p>这几行说明有个叫 <code>bravo</code> 的远程库在 <code>../bravo</code> 中。</p>
<h3 id="获取远程分支"><a href="#获取远程分支" class="headerlink" title="获取远程分支"></a>获取远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">cd</span> ../bravo</span><br><span class="line">~/bravo $ <span class="built_in">printf</span> <span class="string">&#x27;12&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/bravo $ git add data/number.txt</span><br><span class="line">~/bravo $ git commit -m <span class="string">&#x27;12&#x27;</span></span><br><span class="line">          [master 94cd04d] 12</span><br></pre></td></tr></table></figure>

<p>进入 <code>bravo</code> 目录. 覆写 文件 <code>data/number.txt</code> 为 <code>12</code> ，将改动提交到<code>bravo</code>仓库的分支 <code>master</code>.</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/148d51fe-fc62-4d70-901c-dbafe2d3d9f1.png" alt="`12` commit on `bravo` repository"></p>
<p><code>bravo</code> 仓库中的一个提交<code>12</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/bravo $ <span class="built_in">cd</span> ../alpha</span><br><span class="line">~/alpha $ git fetch bravo master</span><br><span class="line">          Unpacking objects: 100%</span><br><span class="line">          From ../bravo</span><br><span class="line">            * branch master -&gt; FETCH_HEAD</span><br></pre></td></tr></table></figure>

<p>进入 <code>alpha</code> 目录，从 <code>bravo </code>仓库获取 <code>master </code>分支到 <code>alpha</code> 仓库到 <code>master</code> 分支。这个过程包含了四个步骤。</p>
<p>第一步，Git 获取 <code>bravo </code>仓库中 <code>master</code> 分支所指向提交的 hash 值，即 提交 <code>12</code> 所对应的 hash 值。</p>
<p>第二步，Git 会给做出 <code>12</code> 这个提交依赖的所有对象组成的一个列表：包含了提交对象自身，树图中的对象，提交 <code>12</code> 所对应的父提交，父提交树图对象。然后从列表中移除所有在 alpha 仓库对象数据库中已有的对象。复制剩下的对象到目录 <code>alpha/.git/objects/</code>。</p>
<p>第三步，将 <code>12</code>这个提交的 hash 值 写入文件 <code>alpha/.git/refs/remotes/bravo/master</code> 。</p>
<p>第四步，文件 <code>alpha/.git/FETCH_HEAD</code> 内容被置为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">94cd04d93ae88a1f53a4646532b1e8cdfbc0977f branch &#x27;master&#x27; of ../bravo</span><br></pre></td></tr></table></figure>

<p>文件内容表明从 <code>bravo</code> 仓库 <code>master</code> 分支获取了 <code>12</code> 这个提交。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/e602667a-1277-4e27-ac0d-34c8b2ae00f6.png" alt="`alpha` after `bravo/master` fetched"></p>
<p>从 <code>bravo/master</code> 获取后的<code>alpha</code>仓库状态</p>
<p><strong>图属性</strong>： 对象可以被复制。以为址不同仓库间可以共享对象。</p>
<p><strong>图属性</strong>：一个仓库可以存储远程分支的引用，例如 <code>alpha/.git/refs/remotes/bravo/master</code> 。意味着，仓库可以在本地记录远程分支的状态。如果远程分支没有改变，这个状态就一直是正确的。</p>
<h3 id="合并分支-FETCH-HEAD"><a href="#合并分支-FETCH-HEAD" class="headerlink" title="合并分支 FETCH_HEAD"></a>合并分支 FETCH_HEAD</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git merge FETCH_HEAD</span><br><span class="line">          Updating d14c7d2..94cd04d</span><br><span class="line">          Fast-forward</span><br></pre></td></tr></table></figure>

<p>用户合并了分支<code>FETCH_HEAD</code>，这个分支也是一个指向某个提交的一个引用，被解析为指向 <code>12</code> 这个提交的一个引用。</p>
<p>合并前，<code>HEAD</code> 指向此次被合并的引用,  <code>11</code> 这个提交。 完成 <code>fast-forward</code> 合并后， <code>HEAD   </code>指向提交 <code>12</code>。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/e8af2aaf-ab84-4c4d-bb1a-1934a956f7af.png" alt="`alpha` after `FETCH_HEAD` merged"></p>
<p><code>alpha</code>仓库合并<code>FETCH_HEAD</code>后的状态</p>
<h3 id="拉取远程仓库"><a href="#拉取远程仓库" class="headerlink" title="拉取远程仓库"></a>拉取远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git pull bravo master</span><br><span class="line">          Already up-to-date.</span><br></pre></td></tr></table></figure>

<p>拉取远程仓库 <code>bravo</code> 的 <code>master</code> 分支到本地仓库 <code>alpha</code>。<code>pull</code> 操作是 “获取然后合并<code>FETCH_HEAD</code> “ 这两个命令的一个快捷方式。执行了这个命令后，反馈 <code>Already up-to-date</code>, 说明本地和远程内容一样。</p>
<h3 id="克隆一个仓库"><a href="#克隆一个仓库" class="headerlink" title="克隆一个仓库"></a>克隆一个仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">cd</span> ..</span><br><span class="line">      ~ $ git <span class="built_in">clone</span> alpha charlie</span><br><span class="line">          Cloning into <span class="string">&#x27;charlie&#x27;</span></span><br></pre></td></tr></table></figure>

<p>切换到 <code>alpha</code> 的上级目录，克隆仓库<code>alpha</code> 到目录 <code>charlie</code>，这个操作的结果，如同通过复制到到<code>bravo</code>仓库。</p>
<p>克隆仓库做的事情包括：创建新目录<code>charlie</code>; 在目录<code>charlie</code>下初始化仓库；将 <code>alpha</code> 作为远程仓库的 <code>origin</code>分支； 获取 <code>origin</code> 分支到本地；合并分支 <code>FETCH_HEAD</code>。</p>
<h3 id="推送本地分支到远程仓库"><a href="#推送本地分支到远程仓库" class="headerlink" title="推送本地分支到远程仓库"></a>推送本地分支到远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      ~ $ <span class="built_in">cd</span> alpha</span><br><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;13&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m <span class="string">&#x27;13&#x27;</span></span><br><span class="line">          [master 3238468] 13</span><br></pre></td></tr></table></figure>

<p>切换回 <code>alpha</code>仓库， 覆写文件 <code>data/number.txt</code> 为 <code>13</code> ，将改动提交到<code>alpha</code>仓库的分支 <code>master</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git remote add charlie ../charlie</span><br></pre></td></tr></table></figure>

<p>将本地目录<code>charlie</code> 作为本地仓库的<code>alpha</code> 的一个远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git push charlie master</span><br><span class="line">          Writing objects: 100%</span><br><span class="line">          remote error: refusing to update checked out</span><br><span class="line">          branch: refs/heads/master because it will make</span><br><span class="line">          the index and work tree inconsistent</span><br></pre></td></tr></table></figure>

<p>推送本地仓库的<code>master</code> 分支到远程仓库 <code>charlie</code>。</p>
<p><code>13</code> 这个提交所需要的所有对象，被复制到到远程仓库<code>charlie</code>中。</p>
<p>至此，推送操作完成。和之前一样，如果操作出错，Git 会提示出错内容。例如，Git 会拒绝推送到一个在远程切出的分支。听起来是不是很有道理 ？由于一次推送操作会更新远程索引和 <code>HEAD</code>的指向，如果这个时候有人正在编辑远程副本的时候，就会导致冲突，出现不一致。</p>
<p>现在，可以创建一个新分支，合并 <code>13</code>这个内容到新分支 ，推送到远程仓库 <code>charlie</code>。但是，希望达到的是可以推送任何想推送的内容到仓库，希望又有一个可以推送和拉取到中心仓库，但是没人能直接推送到此中心仓库。有点像 GitHub 远程操作，最后的解决方案就是，裸库。</p>
<h3 id="克隆一个裸库"><a href="#克隆一个裸库" class="headerlink" title="克隆一个裸库"></a>克隆一个裸库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">cd</span> ..</span><br><span class="line">      ~ $ git <span class="built_in">clone</span> alpha delta --bare</span><br><span class="line">          Cloning into bare repository <span class="string">&#x27;delta&#x27;</span></span><br></pre></td></tr></table></figure>

<p>切换到 <code>alpha</code>上级目录，将裸库到目录 <code>delta</code> 。这个克隆有两点不同。一是<code>config</code>文件表明这是一个裸库；二是，通常位于 <code>.git</code>目录下的文件被现在存放在仓库的根目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delta</span><br><span class="line">├── HEAD</span><br><span class="line">├── config</span><br><span class="line">├── objects</span><br><span class="line">└── refs</span><br></pre></td></tr></table></figure>

<p><img src="https://dn-coding-net-production-pp.qbox.me/c67037dc-7598-4eb7-b2f2-0d2ce01652bf.png" alt="`alpha` and `delta` graphs after `alpha` cloned to `delta`"></p>
<p>克隆<code>alpha</code> 到 <code>delta</code>后的仓库图</p>
<h3 id="推送分支到裸库"><a href="#推送分支到裸库" class="headerlink" title="推送分支到裸库"></a>推送分支到裸库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      ~ $ <span class="built_in">cd</span> alpha</span><br><span class="line">~/alpha $ git remote add delta ../delta</span><br></pre></td></tr></table></figure>

<p>切换到 <code>alpha</code>目录。使用 <code>../delta</code> 目录 创建远程仓库<code>delta</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ <span class="built_in">printf</span> <span class="string">&#x27;14&#x27;</span> &gt; data/number.txt</span><br><span class="line">~/alpha $ git add data/number.txt</span><br><span class="line">~/alpha $ git commit -m <span class="string">&#x27;14&#x27;</span></span><br><span class="line">          [master cb51da8] 14</span><br></pre></td></tr></table></figure>

<p> 覆写文件 <code>data/number.txt</code> 为 <code>14</code> ，将改动提交到<code>alpha</code>仓库的分支 <code>master</code>。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/237349c4-8460-479d-b97b-c56e68c8dcb8.png" alt="`14` commit on `alpha`"></p>
<p><code>alpha</code> 仓库中的<code>14</code> 提交 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/alpha $ git push delta master</span><br><span class="line">          Writing objects: 100%</span><br><span class="line">          To ../delta</span><br><span class="line">            3238468..cb51da8 master -&gt; master</span><br></pre></td></tr></table></figure>

<p>推送<code>master</code>到仓库<code>delat</code>。推送过程包含三步：</p>
<p>第一步，<code>14</code>提交需要的所有对象，从<code>alpha/.git/objects/</code>目录，复制到目录<code>delta/objects/</code>。</p>
<p>第二步，更新文件<code>delta/refs/heads/master</code>内容，指向提交 <code>14</code>。</p>
<p>第三步，更新文件<code>alpha/.git/refs/remotes/delta/master</code>内容，指向提交 <code>14</code>。本地仓库<code>alpha</code>就有了远程仓库<code>delta</code>的一份最新状态记录。</p>
<p><img src="https://dn-coding-net-production-pp.qbox.me/546452c9-b324-46d5-a873-134fb5636a5b.png" alt="`14` commit pushed from `alpha` to `delta`"></p>
<p>推送<code>alpha</code>仓库到提交<code>14</code>到仓库<code>delta</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Git 是在基于图的思想上构建的，几乎所有的 Git 命令都在维护这个图。想要深入理解 Git，就需要把精力集中在这个图的属性上，而不是在 Git 操作流程 或者 Git 命令。</p>
<p>想要更多的理解 Git，就去详细剖析 <code>.git</code> 目录，看里面都有些什么文件。通过改变文件内容，观察里面这些文件的变化。手动创建提交，看看可以把这个仓库搞什么鬼样子，然后尝试修复这些问题。</p>
<ol>
<li>通过这个案例，hash 值比原始文件内容要长。但是，所有文件的内容比 hash 值要长，这样的效果就是，表达的意思比原始文件要更加简洁明了。</li>
<li>有可能会出现两个不同的文件内容的 hash 值一样，但是，这个 <a target="_blank" rel="noopener" href="http://crypto.stackexchange.com/a/2584">机率很小</a>.。</li>
<li><code>git prune</code>会删除一个引用不能获取的所有对象。如果使用此命令，可能导致文件内容丢失。</li>
<li><code>git stash</code>会在一个安全的地方存储<code>HEAD</code>与当前工作区的差异。因此稍后可以恢复工作区。</li>
<li><code>rebase</code>可以对历史命令进行操作，达到新增，修改，删除提交的目的。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2017/04/19/%E5%88%A9%E7%94%A8GitLab%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%A3%E7%A0%81%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/04/19/%E5%88%A9%E7%94%A8GitLab%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%A3%E7%A0%81%E5%BA%93/" class="post-title-link" itemprop="url">利用GitLab搭建私有代码库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-19 15:44:28" itemprop="dateCreated datePublished" datetime="2017-04-19T15:44:28+08:00">2017-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 19:01:09" itemprop="dateModified" datetime="2022-05-19T19:01:09+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="GitLab-简介"><a href="#GitLab-简介" class="headerlink" title="GitLab 简介"></a>GitLab 简介</h2><p>GitLab 是利用 Ruby On Rails 一个开源的版本管理系统，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与 GitHub 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序( Wall )进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。</p>
<p>GitHub 它是一个开源的社区, 如果你想把你们公司的项目放在上面就得交钱, 如果不交钱就得开源, 而 GitLab 是一个本地的项目管理仓库, 既然是本地那么想怎么玩就怎么玩儿</p>
<p><strong>优点</strong></p>
<ul>
<li>社区版基于 MIT License 开源完全免费</li>
<li>无用户，协作和仓库限制</li>
<li>保护项目源码安全</li>
<li>管理仓库，用户与访问权限</li>
</ul>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul>
<li>服务器：微软Azure主机</li>
<li>操作系统：Ubuntu 16.04 X64</li>
<li>软件包：LNMP组件</li>
</ul>
<h2 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h2><h3 id="选择版本"><a href="#选择版本" class="headerlink" title="选择版本"></a>选择版本</h3><p>GitLab分为社区版（GitLab Community Edition）和企业版（GitLab Enterprise Edition）。社区版免费，企业版收费，但是功能比社区版多。根据目前的需求，选择安装社区版（GitLab-CE）。</p>
<h3 id="安装配置依赖项"><a href="#安装配置依赖项" class="headerlink" title="安装配置依赖项"></a>安装配置依赖项</h3><p>如想使用Postfix来发送邮件,在安装期间请选择’Internet Site’. 您也可以用sendmai或者 配置SMTP服务 并 使用SMTP发送邮件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install curl openssh-server ca-certificates postfix</span><br></pre></td></tr></table></figure>

<h3 id="添加GitLab仓库，并安装到服务器上"><a href="#添加GitLab仓库，并安装到服务器上" class="headerlink" title="添加GitLab仓库，并安装到服务器上"></a>添加GitLab仓库，并安装到服务器上</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.deb.sh | sudo bash</span><br><span class="line">apt install gitlab-ce</span><br></pre></td></tr></table></figure>

<h3 id="启动GitLab"><a href="#启动GitLab" class="headerlink" title="启动GitLab"></a>启动GitLab</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>

<h3 id="使用浏览器访问GitLab"><a href="#使用浏览器访问GitLab" class="headerlink" title="使用浏览器访问GitLab"></a>使用浏览器访问GitLab</h3><p>首次访问GitLab,系统会让你重新设置管理员的密码,设置成功后会返回登录界面.<br>默认的管理员账号是root,如果你想更改默认管理员账号,请输入上面设置的新密码登录系统后修改帐号名.</p>
<h2 id="未完待续。。。。。。"><a href="#未完待续。。。。。。" class="headerlink" title="未完待续。。。。。。"></a>未完待续。。。。。。</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2017/04/16/LEDE%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/04/16/LEDE%E7%BC%96%E8%AF%91%E6%95%99%E7%A8%8B/" class="post-title-link" itemprop="url">LEDE编译教程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-04-16 18:20:01" itemprop="dateCreated datePublished" datetime="2017-04-16T18:20:01+08:00">2017-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 19:00:23" itemprop="dateModified" datetime="2022-05-19T19:00:23+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LEDE-project是 OpenWrt 的一个分支，是为了解决OpenWrt遗留的一些问题而设立，拥有更多的支持。</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>LEDE-project开发环境及依赖：</p>
<ul>
<li>系统：ubuntu 16.04 x64</li>
<li>依赖：build-essential subversion git-core libncurses5-dev zlib1g-dev gawk flex quilt libssl-dev xsltproc libxml-parser-perl mercurial bzr ecj cvs unzip</li>
</ul>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt upgrade -y</span><br><span class="line"></span><br><span class="line">apt install build-essential subversion git-core libncurses5-dev zlib1g-dev gawk flex quilt libssl-dev xsltproc libxml-parser-perl mercurial bzr ecj cvs unzip</span><br></pre></td></tr></table></figure>

<h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lede-project/source.git LEDE-project</span><br><span class="line"></span><br><span class="line">cd LEDE-project</span><br><span class="line"></span><br><span class="line">./scripts/feeds update -a</span><br><span class="line"></span><br><span class="line">./scripts/feeds install -a</span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="编辑固件设置"><a href="#编辑固件设置" class="headerlink" title="编辑固件设置"></a>编辑固件设置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p>执行后出现配置界面，根据需要选择自己的配置选项。</p>
<p>备注：记得勾选<code>SDK</code></p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=s</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>编译时间较长；</li>
<li>编译过程中，需要爬墙下载相关软件包；</li>
</ul>
<h3 id="完成编译"><a href="#完成编译" class="headerlink" title="完成编译"></a>完成编译</h3><p>编译完成后，便可以在<code>/bin/$target</code>目录下找到刷机的固件和SDK.这里最好做一个备份，方便以后使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/lede-project/source">lede-project</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2016/08/19/%E9%92%A2%E9%93%81%E9%9B%84%E5%BF%83IV%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/08/19/%E9%92%A2%E9%93%81%E9%9B%84%E5%BF%83IV%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">钢铁雄心IV控制台命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-08-19 17:27:05" itemprop="dateCreated datePublished" datetime="2016-08-19T17:27:05+08:00">2016-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 18:58:03" itemprop="dateModified" datetime="2022-05-19T18:58:03+08:00">2022-05-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>按“~”键打开控制台，输入指令。</p>
<h2 id="以下代码经测试对AI无效，仅对玩家有效"><a href="#以下代码经测试对AI无效，仅对玩家有效" class="headerlink" title="以下代码经测试对AI无效，仅对玩家有效"></a>以下代码经测试对AI无效，仅对玩家有效</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">　　tdebug 输入后显示鼠标停留地的国家代码以及省份代码</span><br><span class="line"></span><br><span class="line">　　annex(空格)(国家代码) 直接吞并该国家 例：annex jap 吞并日本</span><br><span class="line"></span><br><span class="line">　　tag(空格)(国家代码) 切换所控制的国家，如果玩到一半想换一个国家玩可以使用此代码，如想玩法国输入tag fra</span><br><span class="line"></span><br><span class="line">　　delall(空格)(国家代码) 删除指定国家所有的军队和舰队</span><br><span class="line"></span><br><span class="line">　　add_core(省份代码) 添加该省份为我国核心，可作为宣战理由</span><br><span class="line"></span><br><span class="line">　　remove_core(省份代码)去除省份核心</span><br><span class="line"></span><br><span class="line">　　research complete 第一个研发槽的科技研发完成</span><br><span class="line"></span><br><span class="line">　　research all 所有科技研发完成</span><br><span class="line"></span><br><span class="line">　　manpower 增加10M人力</span><br><span class="line"></span><br><span class="line">　　XP 三军经验各加500</span><br><span class="line"></span><br><span class="line">　　PP 加999政治力量</span><br><span class="line"></span><br><span class="line">　　nu(空格)(数字)加国家凝聚力，不输数字则无效果</span><br><span class="line"></span><br><span class="line">　　threat(空格)(数字)世界紧张度增加(玩家导致)，最好别用，会被所有国家仇视</span><br><span class="line"></span><br><span class="line">　　fow 去除战争迷雾</span><br><span class="line"></span><br><span class="line">　　tp 开启后部队瞬间移动，选择部队然后右键点击即可瞬间移动，可以将部队瞬移到敌国，免去了登陆和空降</span><br></pre></td></tr></table></figure>

<h2 id="下面的虽然对AI有效，但经测试在暂停时使用对AI无效，故暂停时使用完立刻关闭可避免AI使用，关闭方法为再输一遍代码"><a href="#下面的虽然对AI有效，但经测试在暂停时使用对AI无效，故暂停时使用完立刻关闭可避免AI使用，关闭方法为再输一遍代码" class="headerlink" title="下面的虽然对AI有效，但经测试在暂停时使用对AI无效，故暂停时使用完立刻关闭可避免AI使用，关闭方法为再输一遍代码"></a>下面的虽然对AI有效，但经测试在暂停时使用对AI无效，故暂停时使用完立刻关闭可避免AI使用，关闭方法为再输一遍代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">　　Focus.AutoComplete 所点击的国家焦点立即完成，注意如果使用时已经选择了国家焦点则无效，必须等当前国家焦点完成后使用</span><br><span class="line"></span><br><span class="line">　　instantconstruction 建筑瞬间建造，建造界面点击地点即可建造</span><br><span class="line"></span><br><span class="line">　　allowdiplo 外交无条件，可无条件宣战</span><br><span class="line"></span><br><span class="line">　　yesman 对方答应任何外交要求，如签条约加派系等</span><br><span class="line"></span><br><span class="line">以下代码用处不大，仅供娱乐</span><br><span class="line"></span><br><span class="line">　　debug_nuking 可在任意省份丢核弹，无论你有没有核弹对方是否交战，不过这种方法的核弹丢了和没丢一样，炸不死军队</span><br><span class="line"></span><br><span class="line">　　winwars 给你所参加的战争增加最大进度，然而没啥用，对方死不投降，还是要继续打</span><br><span class="line"></span><br><span class="line">　　time 查看系统时间</span><br><span class="line"></span><br><span class="line">　　nextsong 换下一首配乐</span><br><span class="line"></span><br><span class="line">　　event(空格)(事件代码)执行该事件，由于事件代码不清楚所以用处不大</span><br><span class="line"></span><br><span class="line">　　resign 退出游戏</span><br><span class="line"></span><br><span class="line">　　fullscreen 全屏</span><br></pre></td></tr></table></figure>
<h2 id="具体国家代码："><a href="#具体国家代码：" class="headerlink" title="具体国家代码："></a>具体国家代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">AFG--阿富汗</span><br><span class="line">ALB--阿尔巴尼亚</span><br><span class="line">ARG--阿根廷</span><br><span class="line">AST--澳大利亚</span><br><span class="line">AUS--奥地利</span><br><span class="line">BEL--比利时</span><br><span class="line">BHU--不丹</span><br><span class="line">BOL--玻利维亚</span><br><span class="line">BRA--巴西</span><br><span class="line">BUL--保加利亚</span><br><span class="line">CAN--加拿大</span><br><span class="line">CGX--桂系</span><br><span class="line">CHC--中共</span><br><span class="line">CHI--中华民国</span><br><span class="line">CHL--智利</span><br><span class="line">COL--哥伦比亚</span><br><span class="line">COS--哥斯达黎加</span><br><span class="line">CRO--克罗地亚</span><br><span class="line">CSX--晋系</span><br><span class="line">CUB--古巴</span><br><span class="line">CXB--西北三马</span><br><span class="line">CYN--滇系</span><br><span class="line">CZE--捷克斯洛伐克</span><br><span class="line">DDR--德意志共和国，简称东德</span><br><span class="line">DEN--丹麦</span><br><span class="line">DFR--联邦德国，简称西德</span><br><span class="line">DOM--多米尼加</span><br><span class="line">ECU--厄瓜多尔</span><br><span class="line">EGY--埃及</span><br><span class="line">ENG--英国</span><br><span class="line">EST--爱沙尼亚</span><br><span class="line">ETH--埃塞俄比亚</span><br><span class="line">FIN--芬兰</span><br><span class="line">FRA--法国</span><br><span class="line">GER--纳粹德国</span><br><span class="line">GRE--希腊</span><br><span class="line">GUA--危地马拉</span><br><span class="line">GUY--圭亚那</span><br><span class="line">HAI--海地</span><br><span class="line">HOL--荷兰</span><br><span class="line">HON--洪都拉斯</span><br><span class="line">HUN--匈牙利</span><br><span class="line">ICL--冰岛</span><br><span class="line">IDC--印度支那</span><br><span class="line">IND--印度</span><br><span class="line">INO--印度尼西亚</span><br><span class="line">IRE--爱尔兰</span><br><span class="line">IRQ--伊拉克</span><br><span class="line">ISR--以色列</span><br><span class="line">ITA--意大利</span><br><span class="line">JAP--日本</span><br><span class="line">JOR--约旦</span><br><span class="line">KOR--韩国</span><br><span class="line">LAT--拉脱维亚</span><br><span class="line">LEB--黎巴嫩</span><br><span class="line">LIB--利比里亚</span><br><span class="line">LIT--立陶宛</span><br><span class="line">LUX--卢森堡</span><br><span class="line">MAN--伪满洲国</span><br><span class="line">MEN--伪蒙古</span><br><span class="line">MEX--墨西哥</span><br><span class="line">MON--蒙古</span><br><span class="line">NEP--尼泊尔</span><br><span class="line">NIC--尼加拉瓜</span><br><span class="line">NOR--挪威</span><br><span class="line">NZL--新西兰</span><br><span class="line">OMN--阿曼</span><br><span class="line">PAK--巴基斯坦</span><br><span class="line">PAL--巴勒斯坦</span><br><span class="line">PAN--巴拿马</span><br><span class="line">PAR--巴拉圭</span><br><span class="line">PER--波斯（伊朗）</span><br><span class="line">PHI--菲律宾</span><br><span class="line">POL--波兰</span><br><span class="line">POR--葡萄牙</span><br><span class="line">PRK--朝鲜</span><br><span class="line">PRU--秘鲁</span><br><span class="line">REB--叛军</span><br><span class="line">ROM--罗马尼亚</span><br><span class="line">RSI--意大利共和国</span><br><span class="line">SAF--南非</span><br><span class="line">SAL--萨尔瓦多</span><br><span class="line">SAU--沙特阿拉伯</span><br><span class="line">SCH--瑞士</span><br><span class="line">SIA--泰国</span><br><span class="line">SIK--新疆</span><br><span class="line">SLO--斯洛伐克</span><br><span class="line">SOV--苏联</span><br><span class="line">SPA--西班牙</span><br><span class="line">SPR--西班牙共和国</span><br><span class="line">SWE--瑞典</span><br><span class="line">SYR--叙利亚</span><br><span class="line">TAN--唐努图瓦</span><br><span class="line">TIB--西藏</span><br><span class="line">TUR--土耳其</span><br><span class="line">URU--乌拉圭</span><br><span class="line">USA--美国</span><br><span class="line">VEN--委内瑞拉</span><br><span class="line">VIC--维希法国</span><br><span class="line">YEM--也门</span><br><span class="line">YUG--南斯拉夫</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2016/07/04/VLAN-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/07/04/VLAN-%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">VLAN 基础理论知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-07-04 10:23:48" itemprop="dateCreated datePublished" datetime="2016-07-04T10:23:48+08:00">2016-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-04 10:26:06" itemprop="dateModified" datetime="2022-05-04T10:26:06+08:00">2022-05-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>VLAN（Virtual Local Area Network）即虚拟局域网，是将一个物理的LAN在逻辑上划分成多个广播域的通信技术。VLAN内的主机间可以直接通信，而VLAN间不能直接互通，从而将广播报文限制在一个VLAN内。</p>
<p>以太网是一种基于CSMA&#x2F;CD（Carrier Sense Multiple Access&#x2F;Collision Detection）的共享通讯介质的数据网络通讯技术。</p>
<p>当主机数目较多时会导致冲突严重、广播泛滥、性能显著下降甚至造成网络不可用等问题。</p>
<p>通过交换机实现LAN互连虽然可以解决冲突严重的问题，但仍然不能隔离广播报文和提升网络质量。</p>
<p>在这种情况下出现了VLAN技术，这种技术可以把一个LAN划分成多个逻辑的VLAN，每个VLAN是一个广播域，VLAN内的主机间通信就和在一个LAN内一样，而VLAN间则不能直接互通，这样，广播报文就被限制在一个VLAN内。</p>
<h2 id="使用VLAN能给用户带来以下受益"><a href="#使用VLAN能给用户带来以下受益" class="headerlink" title="使用VLAN能给用户带来以下受益"></a>使用VLAN能给用户带来以下受益</h2><ol>
<li>列表项限制广播域：</li>
</ol>
<p>广播域被限制在一个VLAN内，节省了带宽，提高了网络处理能力。</p>
<ol start="2">
<li>增强局域网的安全性：</li>
</ol>
<p>不同VLAN内的报文在传输时是相互隔离的，即一个VLAN内的用户不能和其它VLAN内的用户直接通信。</p>
<ol start="3">
<li>提高了网络的健壮性：</li>
</ol>
<p>故障被限制在一个VLAN内，本VLAN内的故障不会影响其他VLAN的正常工作。</p>
<ol start="4">
<li>灵活构建虚拟工作组：</li>
</ol>
<p>用VLAN可以划分不同的用户到不同的工作组，同一工作组的用户也不必局限于某一固定的物理范围，网络构建和维护更方便灵活。</p>
<p>在物理vlan中，各主机可以直接通过网络体系结构中的第二层（数据链路层）进行通信，但划分vlan后，不同vlan中的主机不可用直接通过第二层进行通信，必须通过第三层（网络层）才能通信。</p>
<p>从物理来看待vlan：</p>
<p>即同一台交换机上不同的vlan间不通；处于同一IP网段不同vlan位于不同交换机有时是可以直接互通的；从逻辑来看待vlan：一个vlan可以跨越多台物理交换机，即vlan的中继（trunk）功能。</p>
<p><strong>同一物理交换机不可能存在两个相同的vlan；不同交换机可以有相同的vlan，且不同物理交换机上的相同vlan间一般情况下是可以直接互访的（前提是他们都位于同一IP网段，且物理连接端口上允许这些vlan通过）；位于不同交换机上不同vlan处于同一IP网段，且交换机之间连接的两个端口分别隶属于双方vlan的access或不带vlan标签的hybrid端口，则这两个vlan也可以直接通信。</strong></p>
<h2 id="Vlan中继"><a href="#Vlan中继" class="headerlink" title="Vlan中继"></a>Vlan中继</h2><p>一台交换机上的vlan配置信息可以传播、复制到网络中相连的其他交换机上，采用GVRP自动注册来实现</p>
<h2 id="中继端口"><a href="#中继端口" class="headerlink" title="中继端口"></a>中继端口</h2><p>trunk（中继）端口指在一个交换机端口允许一个或多个vlan通信到达网络中相连的另一台交换机上<strong>相同的vlan中</strong>。</p>
<p>vlanID取值范围0-4095,0和4095为协议保留。</p>
<hr>
<h1 id="VLAN基本概念"><a href="#VLAN基本概念" class="headerlink" title="VLAN基本概念"></a>VLAN基本概念</h1><h2 id="VLAN的帧格式"><a href="#VLAN的帧格式" class="headerlink" title="VLAN的帧格式"></a>VLAN的帧格式</h2><p>传统的以太网数据帧在目的MAC地址和源MAC地址之后封装的是上层协议的类型字段。</p>
<p>802.1Q Tag包含4个字段，各字段解释如下所示：</p>
<ol>
<li>TPID</li>
</ol>
<p>长度2bytes，Tag Protocol Identifier（标签协议标识符），表示帧类型。取值为0x8100时表示802.1Q Tag帧。如果不支持802.1Q的设备收到这样的帧，会将其丢弃。</p>
<ol start="2">
<li>PRI</li>
</ol>
<p>长度3bits，Priority，表示帧的优先级。 取值范围为0～7，值越大优先级越高。用于当交换机阻塞时，优先发送优先级高的数据帧。</p>
<ol start="3">
<li>CFI</li>
</ol>
<p>长度1bit ，Canonical Format Indicator（标准格式指示位），表示MAC地址是否是经典格式。 CFI为0说明是经典格式，CFI为1表示为非经典格式。用于兼容以太网和令牌环网。在以太网中，CFI的值为0。</p>
<ol start="4">
<li>VID</li>
</ol>
<p>长度12bits，VLAN ID，表示该帧所属的VLAN。VLAN ID取值范围是0～4095。由于0和4095为协议保留取值，所以VLAN ID的有效取值范围是1～4094。</p>
<p>每台支持802.1Q协议的交换机发送的数据包都会包含VLAN ID，以指明交换机属于哪一个VLAN。因此，在一个VLAN交换网络中，以太网帧有以下两种形式：</p>
<p>有标记帧（tagged frame）：</p>
<p>加入了4字节802.1Q Tag的帧</p>
<p>无标记帧（untagged frame）：</p>
<p>原始的未加入4字节802.1Q Tag的帧</p>
<h2 id="链路类型"><a href="#链路类型" class="headerlink" title="链路类型"></a>链路类型</h2><ol>
<li>接入链路（Access Link）：</li>
</ol>
<p>用于连接用户主机和交换机的链路。</p>
<p>通常情况下，主机并不需要知道自己属于哪个VLAN，主机硬件通常也不能识别带有VLAN标记的帧。因此，主机发送和接收的帧都是untagged帧。</p>
<ol start="2">
<li>干道链路（Trunk Link）：</li>
</ol>
<p>用于交换机间的互连或交换机与路由器之间的连接。</p>
<p>干道链路可以承载多个不同VLAN数据，数据帧在干道链路传输时，干道链路的两端设备需要能够识别数据帧属于哪个VLAN，所以在干道链路上传输的帧都是Tagged帧。</p>
<p> 说明：</p>
<p>对于主机来说，它不需要知道VLAN的存在。主机发出的是untagged报文。</p>
<p>交换设备接收到报文后，根据配置规则（如接口信息）判断出报文所属的VLAN后，再进行处理。</p>
<p>如果报文需要通过另一台交换机转发，则该报文必须通过干道链路透传到对端交换设备上。为了保证其它交换设备能够正确处理报文中的VLAN信息，在干道链路上传输的报文必须都打上了VLAN标记。</p>
<p>当交换设备最终确定报文出接口后，将报文发送给主机前，需要将VLAN标记从帧中删除，这样主机接收到的报文都是不带VLAN标记的以太网帧。</p>
<p>所以，一般情况下，干道链路上传输的都是tagged帧，接入链路上传送到的都是untagged帧。这样处理的好处是：网络中配置的VLAN信息可以被所有交换设备正确处理，而主机不需要了解VLAN信息。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://auska.github.io/2016/06/21/Shell-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Auska">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="博客">
      <meta itemprop="description" content="随便写点啥">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2016/06/21/Shell-%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">Shell 基本运算符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2016-06-21 10:32:28" itemprop="dateCreated datePublished" datetime="2016-06-21T10:32:28+08:00">2016-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-01 10:33:23" itemprop="dateModified" datetime="2022-05-01T10:33:23+08:00">2022-05-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><code>Shell</code> 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<!---more--->

<p>原生<code>bash</code>不支持简单的数学运算，但是可以通过其他命令来实现，例如 <code>awk</code> 和 <code>expr</code>，<code>expr</code> 最常用。</p>
<p><code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p>两点注意：</p>
<ul>
<li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>完整的表达式要被 ` ` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li>
</ul>
<hr>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td>`expr $a + $b` 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>`expr $a - $b` 结果为 -10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>`expr $a \* $b` 结果为  200。</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
<td>`expr $b &#x2F; $a` 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>`expr $b % $a` 结果为 0。</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>赋值</td>
<td>a&#x3D;$b 把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td>[ $a &#x3D;&#x3D; $b ] 返回 false。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td>[ $a !&#x3D; $b ] 返回 true。</td>
</tr>
</tbody></table>
<p><strong>注意</strong>:条件表达式要放在方括号之间，并且要有空格，例如: <strong>[$a&#x3D;&#x3D;$b]</strong> 是错误的，必须写成 **[ $a &#x3D;&#x3D; $b ]**。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>乘号(*)前边必须加反斜杠(\)才能实现乘法运算；</li>
<li>if…then…fi 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 expr 语法是：**$((表达式))*<em>，此处表达式中的 “</em>“ 不需要转义符号 “\“ 。</li>
</ul>
</blockquote>
<hr>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td>[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否不相等，不相等返回 true。</td>
<td>[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td>[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td>[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td>[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td>[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<hr>
<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td>[ ! false ] 返回 true。</td>
</tr>
<tr>
<td>-o</td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td>-a</td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<hr>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑的 AND</td>
<td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>
<tr>
<td>|</td>
<td>逻辑的 OR</td>
<td>[[ $a -lt 100 | $b -gt 100 ]] 返回 true</td>
</tr>
</tbody></table>
<hr>
<h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a &#x3D; $b ] 返回 false。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检测两个字符串是否不相等，不相等返回 true。</td>
<td>[ $a !&#x3D; $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否不为 0，不为 0 返回 true。</td>
<td>[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td>$</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<hr>
<h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td>[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td>[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td>[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td>[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td>[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td>[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是有名管道，如果是，则返回 true。</td>
<td>[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td>[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td>[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td>[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td>[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td>[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td>[ -e $file ] 返回 true。</td>
</tr>
</tbody></table>
<p>其他检查符：</p>
<ul>
<li><strong>-S</strong>: 判断某文件是否 socket。</li>
<li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Auska</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
